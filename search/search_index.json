{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"whitecanvas","text":"<p><code>whitecanvas</code> is a type safe and backend independent plotting library for Python.</p>"},{"location":"#source","title":"Source","text":"<p>Jump to GitHub repository.</p>"},{"location":"#project-philosophy","title":"Project Philosophy","text":""},{"location":"#type-safety","title":"Type safety","text":"<p>All the methods should be designed to have nice signature, and should return the same type of object, so that your program can be statically checked by the IDE.</p>"},{"location":"#backend-independency","title":"Backend independency","text":"<p>Every plotting library has their own strength and weakness. Same code should work on different backends, so that you can choose the best one for different purposes.</p> <p>Currently supported backends are <code>matplotlib</code>, <code>pyqtgraph</code>, <code>vispy</code>, <code>plotly</code> and <code>bokeh</code>. If you want other backends, please feel free to open an issue.</p>"},{"location":"#api-tidiness","title":"API tidiness","text":"<p>Most of (probably all of) the plotting libraries rely on the large number of arguments to configure the plot elements. They are usually hard to remember, forcing you to look up the documentation every time you want to make a plot.</p> <p><code>whitecanvas</code> tries to organize the methods, namespaces and arguments carefully so that you can make any kind of plot only with the help of the IDE's auto-completion and suggestions.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>whitecanvas</code> is available on PyPI.</p> <pre><code>pip install whitecanvas -U\n</code></pre> <p>You can also install backend optional dependencies using one of the following commands.</p> <pre><code>pip install whitecanvas[matplotlib] -U\npip install whitecanvas[pyqtgraph] -U\npip install whitecanvas[vispy] -U\npip install whitecanvas[plotly] -U\npip install whitecanvas[bokeh] -U\n</code></pre>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#create-a-canvas","title":"Create a canvas","text":"<p>The <code>new_canvas</code> function creates a new canvas, in which you can add many graphical elements. Created canvas can be shown by calling <code>show</code>.</p> <p><pre><code>from whitecanvas import new_canvas\n\n# create a canvas\ncanvas = new_canvas()\n\n# show the canvas\ncanvas.show()\n</code></pre> </p> <p>As <code>whitecanvas</code> is backend independent, you can specify a plotting backend when creating the canvas.</p> <pre><code>canvas = new_canvas(backend=\"matplotlib\")  # matplotlib backend\n</code></pre> <p>Currently supported backends are:</p> <ul> <li>matplotlib</li> <li>pyqtgraph</li> <li>vispy</li> <li>plotly</li> <li>bokeh</li> </ul> <p>For each backend, they also have their own application backend. For example, <code>matplotlib</code> has <code>Qt</code>, <code>Tk</code> and many other backends, and <code>pyqtgraph</code> has <code>Qt</code> and <code>notebook</code> backend. You can add a suffix with separator \":\" to the backend name to specify which application backend to use.</p> <pre><code>canvas = new_canvas(backend=\"matplotlib:qt\")  # matplotlib with Qt backend\ncanvas = new_canvas(backend=\"pyqtgraph:notebook\")  # pyqtgraph with notebook backend\n</code></pre>"},{"location":"quick_start/#lets-plot","title":"Let's plot!","text":"<p>Here is a simple example to add a line and a scatter plot to the canvas.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1])\ncanvas.show()\n</code></pre> </p> <p>You can also add more options.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line([0, 1, 2, 3], [0, 1, 1, 0], color=\"red\", width=2, style=\":\")\ncanvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1], symbol=\"s\", size=20, color=\"blue\")\ncanvas.show()\n</code></pre> </p> <p>Methods always return a <code>Layer</code> object (with minor exceptions), which is also added to the list-like <code>layers</code> attribute of the canvas.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\nline_layer = canvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\nmarkers_layer = canvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1])\ncanvas.layers[0] is line_layer  # True\ncanvas.layers[1] is markers_layer  # True\n</code></pre> <p>Color, size, style, etc. can also be configured via the layer properties.</p> <pre><code>line_layer.color = \"red\"\nmarkers_layer.symbol = \"s\"\n</code></pre> <p>A major difference between <code>whitecanvas</code> and other plotting libraries is that all the edge properties are set using <code>with_edge</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\nmarkers_layer = canvas.add_markers(\n    [0, 1, 2, 3], [1, 2, 0, 1]\n).with_edge(color=\"black\", width=1)\ncanvas.show()\n</code></pre> </p>"},{"location":"quick_start/#wanna-use-dataframes","title":"Wanna use DataFrames?","text":"<p><code>whitecanvas</code> has a built-in support for DataFrame-like objects for categorical plotting. See Categorical Plotting for more details.</p>"},{"location":"api/canvas/","title":"whitecanvas.canvas","text":""},{"location":"api/canvas/#whitecanvas.canvas.Canvas","title":"<code>Canvas</code>","text":"Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>class Canvas(CanvasBase):\n    _CURRENT_INSTANCE: Canvas | None = None\n\n    def __init__(\n        self,\n        backend: str | None = None,\n        *,\n        palette: ColormapType | None = None,\n    ):\n        self._backend = Backend(backend)\n        self._backend_object = self._create_backend_object()\n        super().__init__(palette=palette)\n        self.__class__._CURRENT_INSTANCE = self\n\n    @classmethod\n    def from_backend(\n        cls,\n        obj: protocols.CanvasProtocol,\n        *,\n        palette: ColormapType | None = None,\n        backend: str | None = None,\n    ) -&gt; Self:\n        \"\"\"Create a canvas object from a backend object.\"\"\"\n        with patch_dummy_backend() as name:\n            # this patch will delay initialization by \"_init_canvas\" until the backend\n            # objects are created.\n            self = cls(backend=name, palette=palette)\n        self._backend = Backend(backend)\n        self._backend_object = obj\n        self._init_canvas()\n        return self\n\n    def _create_backend_object(self) -&gt; protocols.CanvasProtocol:\n        return self._backend.get(\"Canvas\")()\n\n    def _get_backend(self):\n        return self._backend\n\n    def _canvas(self) -&gt; protocols.CanvasProtocol:\n        return self._backend_object\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.Canvas.from_backend","title":"<code>from_backend(obj, *, palette=None, backend=None)</code>  <code>classmethod</code>","text":"<p>Create a canvas object from a backend object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>@classmethod\ndef from_backend(\n    cls,\n    obj: protocols.CanvasProtocol,\n    *,\n    palette: ColormapType | None = None,\n    backend: str | None = None,\n) -&gt; Self:\n    \"\"\"Create a canvas object from a backend object.\"\"\"\n    with patch_dummy_backend() as name:\n        # this patch will delay initialization by \"_init_canvas\" until the backend\n        # objects are created.\n        self = cls(backend=name, palette=palette)\n    self._backend = Backend(backend)\n    self._backend_object = obj\n    self._init_canvas()\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase","title":"<code>CanvasBase</code>","text":"<p>Base class for any canvas object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>class CanvasBase(ABC):\n    \"\"\"Base class for any canvas object.\"\"\"\n\n    title = _ns.TitleNamespace()\n    x = _ns.XAxisNamespace()\n    y = _ns.YAxisNamespace()\n    dims = Dims()\n    layers = _ll.LayerList()\n    overlays = _ll.LayerList()\n    mouse = _ns.MouseNamespace()\n    events: CanvasEvents\n\n    def __init__(self, palette: ColormapType | None = None):\n        if palette is None:\n            palette = theme.get_theme().palette\n        self._color_palette = ColorPalette(palette)\n        self.events = CanvasEvents()\n        self._is_grouping = False\n        self._autoscale_enabled = True\n        if not self._get_backend().is_dummy():\n            self._init_canvas()\n\n    def _init_canvas(self):\n        # default colors and font\n        _t = theme.get_theme()\n        _ft = _t.font\n        self.x.color = _t.foreground_color\n        self.y.color = _t.foreground_color\n        self.x.label.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.y.label.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.title.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.x.ticks.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.y.ticks.update(family=_ft.family, color=_ft.color, size=_ft.size)\n\n        # connect layer events\n        self.layers.events.inserted.connect(\n            self._cb_inserted, unique=True, max_args=None\n        )\n        self.layers.events.removed.connect(self._cb_removed, unique=True, max_args=None)\n        self.layers.events.reordered.connect(\n            self._cb_reordered, unique=True, max_args=None\n        )\n        self.layers.events.connect(self._draw_canvas, unique=True, max_args=None)\n\n        self.overlays.events.inserted.connect(\n            self._cb_overlay_inserted, unique=True, max_args=None\n        )\n        self.overlays.events.removed.connect(\n            self._cb_removed, unique=True, max_args=None\n        )\n        self.overlays.events.connect(self._draw_canvas, unique=True, max_args=None)\n\n        canvas = self._canvas()\n        canvas._plt_connect_xlim_changed(self._emit_xlim_changed)\n        canvas._plt_connect_ylim_changed(self._emit_ylim_changed)\n\n        if hasattr(canvas, \"_plt_canvas_hook\"):\n            canvas._plt_canvas_hook(self)\n\n    def _install_mouse_events(self):\n        canvas = self._canvas()\n        canvas._plt_connect_mouse_click(self.mouse.clicked.emit)\n        canvas._plt_connect_mouse_click(self.mouse.moved.emit)\n        canvas._plt_connect_mouse_drag(self.mouse.moved.emit)\n        canvas._plt_connect_mouse_release(self.mouse.moved.emit)\n        canvas._plt_connect_mouse_double_click(self.mouse.double_clicked.emit)\n        canvas._plt_connect_mouse_double_click(self.mouse.moved.emit)\n\n    def _emit_xlim_changed(self, lim):\n        self.x.events.lim.emit(lim)\n        self.events.lims.emit(Rect(*lim, *self.y.lim))\n\n    def _emit_ylim_changed(self, lim):\n        self.y.events.lim.emit(lim)\n        self.events.lims.emit(Rect(*self.x.lim, *lim))\n\n    def _emit_mouse_moved(self, ev):\n        \"\"\"Emit mouse moved event with autoscaling blocked\"\"\"\n        self.mouse.moved.emit(ev)\n\n    @property\n    def mouse_clicked(self):\n        warnings.warn(\n            \"`canvas.events.mouse_clicked` is deprecated. Use `canvas.mouse.clicked` \"\n            \"instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.mouse.clicked\n\n    @property\n    def mouse_moved(self):\n        warnings.warn(\n            \"`canvas.events.mouse_moved` is deprecated. Use `canvas.mouse.moved` \"\n            \"instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.mouse.clicked\n\n    @property\n    def mouse_double_clicked(self):\n        warnings.warn(\n            \"`canvas.events.mouse_double_clicked` is deprecated. Use \"\n            \"`canvas.mouse.double_clicked` instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.mouse.clicked\n\n    @property\n    def autoscale_enabled(self) -&gt; bool:\n        \"\"\"Return whether autoscale is enabled.\"\"\"\n        return self._autoscale_enabled\n\n    @autoscale_enabled.setter\n    def autoscale_enabled(self, enabled: bool):\n        if not isinstance(enabled, bool):\n            raise TypeError(f\"Expected a bool, got {type(enabled)}.\")\n        self._autoscale_enabled = enabled\n\n    @contextmanager\n    def autoscale_context(self, enabled: bool):\n        \"\"\"Context manager to temporarily change the autoscale state.\"\"\"\n        _was_enabled = self.autoscale_enabled\n        self.autoscale_enabled = enabled\n        try:\n            yield\n        finally:\n            self.autoscale_enabled = _was_enabled\n\n    @abstractmethod\n    def _get_backend(self) -&gt; Backend:\n        \"\"\"Return the backend.\"\"\"\n\n    @abstractmethod\n    def _canvas(self) -&gt; protocols.CanvasProtocol:\n        \"\"\"Return the canvas object.\"\"\"\n\n    def _draw_canvas(self):\n        self._canvas()._plt_draw()\n        self.events.drawn.emit()\n\n    @property\n    def native(self) -&gt; Any:\n        \"\"\"Return the native canvas object.\"\"\"\n        return self._canvas()._plt_get_native()\n\n    @property\n    def aspect_ratio(self) -&gt; float | None:\n        \"\"\"Aspect ratio of the canvas (None if not locked).\"\"\"\n        return self._canvas()._plt_get_aspect_ratio()\n\n    @aspect_ratio.setter\n    def aspect_ratio(self, ratio: float | None):\n        if ratio is not None:\n            ratio = float(ratio)\n        self._canvas()._plt_set_aspect_ratio(ratio)\n\n    @property\n    def mouse_enabled(self) -&gt; bool:\n        warnings.warn(\n            \"`canvas.mouse_enabled` is deprecated. Use `canvas.mouse.enabled` instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.mouse.enabled\n\n    @mouse_enabled.setter\n    def mouse_enabled(self, enabled: bool):\n        warnings.warn(\n            \"`canvas.mouse_enabled` is deprecated. Use `canvas.mouse.enabled` instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.mouse.enabled = enabled\n\n    def autoscale(\n        self,\n        xpad: float | tuple[float, float] | None = None,\n        ypad: float | tuple[float, float] | None = None,\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Autoscale the canvas to fit the contents.\n\n        Parameters\n        ----------\n        xpad : float or (float, float), optional\n            Padding in the x direction.\n        ypad : float or (float, float), optional\n            Padding in the y direction.\n        \"\"\"\n        ar = np.stack([layer.bbox_hint() for layer in self.layers], axis=0)\n        xmin = np.min(ar[:, 0])\n        xmax = np.max(ar[:, 1])\n        ymin = np.min(ar[:, 2])\n        ymax = np.max(ar[:, 3])\n        x0, x1 = self.x.lim\n        y0, y1 = self.y.lim\n        if np.isnan(xmin):\n            xmin = x0\n        if np.isnan(xmax):\n            xmax = x1\n        if np.isnan(ymin):\n            ymin = y0\n        if np.isnan(ymax):\n            ymax = y1\n        if xpad is not None:\n            xrange = xmax - xmin\n            if is_real_number(xpad):\n                dx0 = dx1 = xpad * xrange\n            else:\n                dx0, dx1 = xpad[0] * xrange, xpad[1] * xrange\n            xmin -= dx0\n            xmax += dx1\n        if ypad is not None:\n            yrange = ymax - ymin\n            if is_real_number(ypad):\n                dy0 = dy1 = ypad * yrange\n            else:\n                dy0, dy1 = ypad[0] * yrange, ypad[1] * yrange\n            ymin -= dy0\n            ymax += dy1\n        small_diff = 1e-6\n        if xmax - xmin &lt; small_diff:\n            xmin -= 0.05\n            xmax += 0.05\n        if ymax - ymin &lt; small_diff:\n            ymin -= 0.05\n            ymax += 0.05\n        self.x.lim = xmin, xmax\n        self.y.lim = ymin, ymax\n        return xmin, xmax, ymin, ymax\n\n    def install_second_x(self, *, palette: ColormapType | None = None) -&gt; Canvas:\n        \"\"\"Create a twin canvas that has a secondary x-axis and shared y-axis.\"\"\"\n        try:\n            new = self._canvas()._plt_twiny()\n        except AttributeError:\n            raise NotImplementedError(\n                f\"Backend {self._get_backend()} does not support `install_second_x`.\"\n            ) from None\n        canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n        canvas._init_canvas()\n        return canvas\n\n    def install_second_y(self, *, palette: ColormapType | None = None) -&gt; Canvas:\n        \"\"\"Create a twin canvas that has a secondary y-axis and shared x-axis.\"\"\"\n        try:\n            new = self._canvas()._plt_twinx()\n        except AttributeError:\n            raise NotImplementedError(\n                f\"Backend {self._get_backend()} does not support `install_second_y`.\"\n            ) from None\n        canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n        canvas._init_canvas()\n        return canvas\n\n    @overload\n    def install_inset(\n        self, left: float, right: float, bottom: float, top: float, *,\n        palette: ColormapType | None = None\n    ) -&gt; Canvas:  # fmt: skip\n        ...\n\n    @overload\n    def install_inset(\n        self, rect: Rect | tuple[float, float, float, float], /, *,\n        palette: ColormapType | None = None\n    ) -&gt; Canvas:  # fmt: skip\n        ...\n\n    def install_inset(self, *args, palette=None, **kwargs) -&gt; Canvas:\n        \"\"\"\n        Install a new canvas pointing to an inset of the current canvas.\n\n        &gt;&gt;&gt; canvas.install_inset(left=0.1, right=0.9, bottom=0.1, top=0.9)\n        &gt;&gt;&gt; canvas.install_inset([0.1, 0.9, 0.1, 0.9])  # or a sequence\n        \"\"\"\n        # normalize input\n        if len(args) == 1 and not kwargs:\n            rect = args[0]\n            if not isinstance(rect, Rect):\n                rect = Rect.with_check(*rect)\n        else:\n            rect = Rect.with_check(*args, **kwargs)\n        try:\n            new = self._canvas()._plt_inset(rect)\n        except AttributeError:\n            raise NotImplementedError(\n                f\"Backend {self._get_backend()} does not support `install_inset`\"\n            ) from None\n        canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n        canvas._init_canvas()\n        return canvas\n\n    @property\n    def visible(self):\n        \"\"\"Show the canvas.\"\"\"\n        return self._canvas()._plt_get_visible()\n\n    @visible.setter\n    def visible(self, visible):\n        \"\"\"Hide the canvas.\"\"\"\n        self._canvas()._plt_set_visible(visible)\n\n    @property\n    def lims(self) -&gt; Rect:\n        \"\"\"Return the x/y limits of the canvas.\"\"\"\n        return Rect(*self.x.lim, *self.y.lim)\n\n    @lims.setter\n    def lims(self, lims: tuple[float, float, float, float]):\n        xmin, xmax, ymin, ymax = lims\n        if xmin &gt;= xmax or ymin &gt;= ymax:\n            raise ValueError(f\"Invalid view rect: {Rect(*lims)}\")\n        with self.events.lims.blocked():\n            self.x.lim = xmin, xmax\n            self.y.lim = ymin, ymax\n        self.events.lims.emit(Rect(xmin, xmax, ymin, ymax))\n\n    def update_axes(\n        self,\n        *,\n        visible: bool = _void,\n        color: ColorType | None = _void,\n    ):\n        \"\"\"\n        Update axes appearance.\n\n        Parameters\n        ----------\n        visible : bool, optional\n            Whether to show the axes.\n        color : color-like, optional\n            Color of the axes.\n        \"\"\"\n        if visible is not _void:\n            self.x.ticks.visible = visible\n            self.y.ticks.visible = visible\n        if color is not _void:\n            self.x.color = color\n            self.x.ticks.color = color\n            self.x.label.color = color\n            self.y.color = color\n            self.y.ticks.color = color\n            self.y.label.color = color\n        return self\n\n    def update_labels(\n        self,\n        title: str | None = None,\n        x: str | None = None,\n        y: str | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Helper function to update the title, x, and y labels.\n\n        &gt;&gt;&gt; from whitecanvas import new_canvas\n        &gt;&gt;&gt; canvas = new_canvas(\"matplotlib\").update_labels(\"Title\", \"X\", \"Y\")\n        \"\"\"\n        if title is not None:\n            self.title.text = title\n            self.title.visible = True\n        if x is not None:\n            self.x.label.text = x\n            self.x.label.visible = True\n        if y is not None:\n            self.y.label.text = y\n            self.y.label.visible = True\n        return self\n\n    def update_font(\n        self,\n        size: float | _Void = _void,\n        color: ColorType | _Void = _void,\n        family: str | _Void = _void,\n    ) -&gt; Self:\n        \"\"\"\n        Update all the fonts, including the title, x/y labels and x/y tick labels.\n\n        Parameters\n        ----------\n        size : float, optional\n            New font size.\n        color : color-like, optional\n            New font color.\n        family : str, optional\n            New font family.\n        \"\"\"\n        if size is not _void:\n            self.title.size = self.x.label.size = self.y.label.size = size\n            self.x.ticks.size = self.y.ticks.size = size\n        if family is not _void:\n            self.title.family = self.x.label.family = self.y.label.family = family\n            self.x.ticks.family = self.y.ticks.family = family\n        if color is not _void:\n            self.title.color = self.x.label.color = self.y.label.color = color\n            self.x.ticks.color = self.y.ticks.color = color\n        return self\n\n    def cat(\n        self,\n        data: _DF,\n        x: str | None = None,\n        y: str | None = None,\n        *,\n        update_labels: bool = True,\n    ) -&gt; _df.CatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting.\n\n        This method provides categorical plotting methods for the input data.\n        Methods are very similar to `seaborn` and `plotly.express`.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str, optional\n            Name of the column that will be used for the x-axis. Must be numerical.\n        y : str, optional\n            Name of the column that will be used for the y-axis. Must be numerical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n\n        Returns\n        -------\n        CatPlotter\n            Plotter object.\n        \"\"\"\n        plotter = _df.CatPlotter(self, data, x, y, update_labels=update_labels)\n        return plotter\n\n    def cat_x(\n        self,\n        data: _DF,\n        x: str | Sequence[str] | None = None,\n        y: str | None = None,\n        *,\n        update_labels: bool = True,\n        numeric_axis: bool = False,\n    ) -&gt; _df.XCatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting with x-axis as a categorical axis.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str or sequence of str, optional\n            Name of the column(s) that will be used for the x-axis. Must be categorical.\n        y : str, optional\n            Name of the column that will be used for the y-axis. Must be numerical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n        numeric_axis : bool, default False\n            If True, the x-axis will be treated as a numerical axis. For example, if\n            categories are [2, 4, 8], the x coordinates will be mapped to [0, 1, 2] by\n            default, but if this option is True, the x coordinates will be [2, 4, 8].\n\n        Returns\n        -------\n        XCatPlotter\n            Plotter object.\n        \"\"\"\n        return _df.XCatPlotter(self, data, x, y, update_labels, numeric=numeric_axis)\n\n    def cat_y(\n        self,\n        data: _DF,\n        x: str | None = None,\n        y: str | Sequence[str] | None = None,\n        *,\n        update_labels: bool = True,\n        numeric_axis: bool = False,\n    ) -&gt; _df.YCatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting with y-axis as a categorical axis.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str, optional\n            Name of the column that will be used for the x-axis. Must be numerical.\n        y : str or sequence of str, optional\n            Name of the column(s) that will be used for the y-axis. Must be categorical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n        numeric_axis : bool, default False\n            If True, the x-axis will be treated as a numerical axis. For example, if\n            categories are [2, 4, 8], the y coordinates will be mapped to [0, 1, 2] by\n            default, but if this option is True, the y coordinates will be [2, 4, 8].\n\n        Returns\n        -------\n        YCatPlotter\n            Plotter object\n        \"\"\"\n        return _df.YCatPlotter(self, data, y, x, update_labels, numeric=numeric_axis)\n\n    def cat_xy(\n        self,\n        data: _DF,\n        x: str | Sequence[str],\n        y: str | Sequence[str],\n        *,\n        update_labels: bool = True,\n    ) -&gt; _df.XYCatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting with both axes as categorical.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str or sequence of str, optional\n            Name of the column(s) that will be used for the x-axis. Must be categorical.\n        y : str or sequence of str, optional\n            Name of the column(s) that will be used for the y-axis. Must be categorical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n\n        Returns\n        -------\n        XYCatPlotter\n            Plotter object\n        \"\"\"\n        return _df.XYCatPlotter(self, data, x, y, update_labels)\n\n    def stack_over(self, layer: _L0) -&gt; StackOverPlotter[Self, _L0]:\n        \"\"\"\n        Stack new data over the existing layer.\n\n        For example following code\n\n        &gt;&gt;&gt; bars_0 = canvas.add_bars(x, y0)\n        &gt;&gt;&gt; bars_1 = canvas.stack_over(bars_0).add(y1)\n        &gt;&gt;&gt; bars_2 = canvas.stack_over(bars_1).add(y2)\n\n        will result in a bar plot like this\n\n        ```\n         \u250c\u2500\u2500\u2500\u2510\n         \u251c\u2500\u2500\u2500\u2502\u250c\u2500\u2500\u2500\u2510\n         \u2502   \u2502\u251c\u2500\u2500\u2500\u2502\n         \u251c\u2500\u2500\u2500\u2502\u251c\u2500\u2500\u2500\u2502\n        \u2500\u2534\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\n        ```\n        \"\"\"\n        if not isinstance(layer, (_l.Bars, _l.Band, _lg.StemPlot, _lg.LabeledBars)):\n            raise TypeError(\n                f\"Only Bars, StemPlot and Band are supported as an input, \"\n                f\"got {type(layer)!r}.\"\n            )\n        return StackOverPlotter(self, layer)\n\n    # TODO\n    # def annotate(self, layer, at: int):\n    #     ...\n\n    def between(self, l0, l1) -&gt; BetweenPlotter[Self]:\n        return BetweenPlotter(self, l0, l1)\n\n    @deprecated(\n        \"ImageRef is deprecated and will be removed in the future. \"\n        \"Please use the Image methods `with_text`, `with_colorbar` instead.\",\n    )\n    def imref(self, layer: _l.Image):\n        \"\"\"The Image reference namespace.\"\"\"\n        from whitecanvas.canvas._imageref import ImageRef\n\n        while isinstance(layer, _l.LayerWrapper):\n            layer = layer._base_layer\n        if not isinstance(layer, _l.Image):\n            raise TypeError(\n                f\"Expected an Image layer or its wrapper, got {type(layer)}.\"\n            )\n        return ImageRef(self, layer)\n\n    def fit(self, layer: _l.DataBoundLayer[_P]) -&gt; FitPlotter[Self, _P]:\n        \"\"\"The fit plotter namespace.\"\"\"\n        return FitPlotter(self, layer)\n\n    def add_legend(\n        self,\n        layers: Sequence[str | _l.Layer] | None = None,\n        *,\n        location: Location | LocationStr = \"top_right\",\n        title: str | None = None,\n    ):\n        \"\"\"\n        Add legend item to the canvas.\n\n        Parameters\n        ----------\n        layers : sequence of layer or str, optional\n            Which item to be added to the legend. If str is given, it will be converted\n            into a title label.\n        location : LegendLocation, default \"top_right\"\n            Location of the legend. Can be following strings. Combination of the\n            following strings (e.g., \"top_left\", \"center_right\").\n\n            ```\n                   (2) left  center right\n                         v     v     v\n              (1)     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               top -&gt; \u2502                 \u2502\n            center -&gt; \u2502     canvas      \u2502\n            bottom -&gt; \u2502                 \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            ```\n\n            Some backends also support adding legend outside the canvas. Following\n            strings suffixed with \"_side\" can be used in combination with those strings\n            above (e.g., \"bottom_side_rigth\", \"right_side_top\").\n\n            ```\n               top_side -&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u250c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2510\n            left_side -&gt;\u2502  \u2502 canvas \u2502  \u2502&lt;- right_side\n                        \u2514\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2518\n            bottom_side -&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            ```\n        title : str, optional\n            If given, title label will be added as the first legend item.\n        \"\"\"\n        if layers is None:\n            layers = list(self.layers)\n        if title is not None:\n            layers = [title, *layers]\n        location = Location(location)\n\n        items = list[tuple[str, _legend.LegendItem]]()\n        for layer in layers:\n            if isinstance(layer, str):\n                items.append((layer, _legend.TitleItem()))\n            elif isinstance(layer, _l.Layer):\n                items.append((layer.name, layer._as_legend_item()))\n            else:\n                raise TypeError(f\"Expected a list of layer or str, got {type(layer)}.\")\n        self._canvas()._plt_make_legend(items, location)\n\n    @overload\n    def add_line(\n        self, ydata: ArrayLike1D, *, name: str | None = None,\n        color: ColorType | None = None, width: float = 1.0,\n        style: LineStyle | str = LineStyle.SOLID, alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.Line:  # fmt: skip\n        ...\n\n    @overload\n    def add_line(\n        self, xdata: ArrayLike1D, ydata: ArrayLike1D, *, name: str | None = None,\n        color: ColorType | None = None, width: float | None = None,\n        style: LineStyle | str | None = None, alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.Line:  # fmt: skip\n        ...\n\n    @overload\n    def add_line(\n        self, xdata: ArrayLike1D, ydata: Callable[[ArrayLike1D], ArrayLike1D], *,\n        name: str | None = None, color: ColorType | None = None,\n        width: float | None = None, style: LineStyle | str | None = None,\n        alpha: float = 1.0, antialias: bool = True,\n    ) -&gt; _l.Line:  # fmt: skip\n        ...\n\n    def add_line(\n        self,\n        *args,\n        name=None,\n        color=None,\n        width=None,\n        style=None,\n        alpha=1.0,\n        antialias=True,\n    ):\n        \"\"\"\n        Add a Line layer to the canvas.\n\n        &gt;&gt;&gt; canvas.add_line(y, ...)\n        &gt;&gt;&gt; canvas.add_line(x, y, ...)\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        Line\n            The line layer.\n        \"\"\"\n        xdata, ydata = normalize_xy(*args)\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.Line(\n            xdata, ydata, name=name, color=color, width=width, style=style,\n            alpha=alpha, antialias=antialias, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    @overload\n    def add_markers(\n        self, xdata: ArrayLike1D, ydata: ArrayLike1D, *,\n        name: str | None = None, symbol: Symbol | str | None = None,\n        size: float | None = None, color: ColorType | None = None, alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Markers[_mixin.ConstFace, _mixin.ConstEdge, float]:  # fmt: skip\n        ...\n\n    @overload\n    def add_markers(\n        self, ydata: ArrayLike1D, *,\n        name: str | None = None, symbol: Symbol | str | None = None,\n        size: float | None = None, color: ColorType | None = None, alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Markers[_mixin.ConstFace, _mixin.ConstEdge, float]:  # fmt: skip\n        ...\n\n    def add_markers(\n        self,\n        *args,\n        name=None,\n        symbol=None,\n        size=None,\n        color=None,\n        alpha=1.0,\n        hatch=None,\n    ):\n        \"\"\"\n        Add markers (scatter plot).\n\n        &gt;&gt;&gt; canvas.add_markers(x, y)  # standard usage\n        &gt;&gt;&gt; canvas.add_markers(y)  # use 0, 1, ... for the x values\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the layer.\n        symbol : str or Symbol, optional\n            Marker symbols. Use the theme default if not specified.\n        size : float, optional\n            Marker size. Use the theme default if not specified.\n        color : color-like, optional\n            Color of the marker faces.\n        alpha : float, default 1.0\n            Alpha channel of the marker faces.\n        hatch : str or FacePattern, optional\n            Pattern of the marker faces. Use the theme default if not specified.\n\n        Returns\n        -------\n        Markers\n            The markers layer.\n        \"\"\"\n        xdata, ydata = normalize_xy(*args)\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        symbol = theme._default(\"markers.symbol\", symbol)\n        size = theme._default(\"markers.size\", size)\n        hatch = theme._default(\"markers.hatch\", hatch)\n        layer = _l.Markers(\n            xdata, ydata, name=name, symbol=symbol, size=size, color=color,\n            alpha=alpha, hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    @overload\n    def add_bars(\n        self, center: ArrayLike1D, height: ArrayLike1D, *,\n        bottom: ArrayLike1D | None = None, name=None,\n        orient: OrientationLike = \"vertical\", extent: float | None = None,\n        color: ColorType | None = None, alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Bars[_mixin.ConstFace, _mixin.ConstEdge]:  # fmt: skip\n        ...\n\n    @overload\n    def add_bars(\n        self, height: ArrayLike1D, *, bottom: ArrayLike1D | None = None,\n        name=None, orient: OrientationLike = \"vertical\",\n        extent: float | None = None, color: ColorType | None = None,\n        alpha: float = 1.0, hatch: str | Hatch | None = None,\n    ) -&gt; _l.Bars[_mixin.ConstFace, _mixin.ConstEdge]:  # fmt: skip\n        ...\n\n    def add_bars(\n        self,\n        *args,\n        bottom=None,\n        name=None,\n        orient=\"vertical\",\n        extent=None,\n        color=None,\n        alpha=1.0,\n        hatch=None,\n    ):\n        \"\"\"\n        Add a bar plot.\n\n        &gt;&gt;&gt; canvas.add_bars(x, heights)  # standard usage\n        &gt;&gt;&gt; canvas.add_bars(heights)  # use 0, 1, ... for the x values\n        &gt;&gt;&gt; canvas.add_bars(..., orient=\"horizontal\")  # horizontal bars\n\n        Parameters\n        ----------\n        bottom : float or array-like, optional\n            Bottom level of the bars.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default \"vertical\"\n            Orientation of the bars.\n        extent : float, default 0.8\n            Bar width in the canvas coordinate\n        color : color-like, optional\n            Color of the bars.\n        alpha : float, default 1.0\n            Alpha channel of the bars.\n        hatch : str or FacePattern, default FacePattern.SOLID\n            Pattern of the bar faces.\n\n        Returns\n        -------\n        Bars\n            The bars layer.\n        \"\"\"\n        center, height = normalize_xy(*args)\n        if bottom is not None:\n            bottom = as_array_1d(bottom)\n            if bottom.shape != height.shape:\n                raise ValueError(\"Expected bottom to have the same shape as height\")\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        extent = theme._default(\"bars.extent\", extent)\n        hatch = theme._default(\"bars.hatch\", hatch)\n        layer = _l.Bars(\n            center, height, bottom, extent=extent, name=name, orient=orient,\n            color=color, alpha=alpha, hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_hist(\n        self,\n        data: ArrayLike1D,\n        *,\n        bins: HistBinType = \"auto\",\n        limits: tuple[float, float] | None = None,\n        name: str | None = None,\n        shape: Literal[\"step\", \"polygon\", \"bars\"] = \"bars\",\n        kind: Literal[\"count\", \"density\", \"frequency\", \"percent\"] = \"count\",\n        orient: OrientationLike = \"vertical\",\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n    ) -&gt; _lg.Histogram:\n        \"\"\"\n        Add data as a histogram.\n\n        &gt;&gt;&gt; canvas.add_hist(np.random.normal(size=100), bins=12)\n\n        Parameters\n        ----------\n        data : array-like\n            1D Array of data.\n        bins : int or 1D array-like, default \"auto\"\n            Bins of the histogram. This parameter will directly be passed\n            to `np.histogram`.\n        limits : (float, float), optional\n            Limits in which histogram will be built. This parameter will equivalent to\n            the `range` paraneter of `np.histogram`.\n        name : str, optional\n            Name of the layer.\n        shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n            Shape of the histogram. This parameter defines how to convert the data into\n            the line nodes.\n        kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n            Kind of the histogram.\n        orient : str or Orientation, default \"vertical\"\n            Orientation of the bars.\n        color : color-like, optional\n            Color of the bars.\n\n        Returns\n        -------\n        Bars\n            The bars layer that represents the histogram.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _lg.Histogram.from_array(\n            data, bins=bins, limits=limits, shape=shape, kind=kind, name=name,\n            color=color, width=width, style=style, orient=orient,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_hist2d(\n        self,\n        x: ArrayLike1D,\n        y: ArrayLike1D,\n        *,\n        cmap: ColormapType = \"inferno\",\n        name: str | None = None,\n        bins: HistBinType | tuple[HistBinType, HistBinType] = \"auto\",\n        rangex: tuple[float, float] | None = None,\n        rangey: tuple[float, float] | None = None,\n        density: bool = False,\n    ) -&gt; _l.Image:\n        \"\"\"\n        Add a 2D histogram of given X/Y data.\n\n        &gt;&gt;&gt; x = np.random.normal(size=100)\n        &gt;&gt;&gt; y = np.random.normal(size=200)\n        &gt;&gt;&gt; canvas.add_hist2d(x, y)\n\n        Note that unlike `add_image()` method, this method does not lock the aspect\n        ratio and flip the canvas by default.\n\n        Parameters\n        ----------\n        x : array-like\n            1D Array of X data.\n        y : array-like\n            1D Array of Y data.\n        cmap : ColormapType, default \"gray\"\n            Colormap used for the image.\n        name : str, optional\n            Name of the layer.\n        bins : int or tuple[int, int], optional\n            Bins of the histogram of X/Y dimension respectively. If an integer is given,\n            it will be used for both dimensions.\n        rangex : (float, float), optional\n            Range of x values in which histogram will be built.\n        rangey : (float, float), optional\n            Range of y values in which histogram will be built.\n        density : bool, default False\n            If True, values of the histogram will be normalized so that the total\n            intensity of the histogram will be 1.\n\n        Returns\n        -------\n        Image\n            Image layer representing the 2D histogram.\n        \"\"\"\n        layer = _l.Image.build_hist(\n            x, y, bins=bins, range=(rangex, rangey), density=density, name=name,\n            cmap=cmap, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_rects(\n        self,\n        coords: ArrayLike,\n        *,\n        name=None,\n        color: ColorType | None = None,\n        alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Rects[_mixin.ConstFace, _mixin.ConstEdge]:\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        hatch = theme._default(\"bars.hatch\", hatch)\n        layer = _l.Rects(\n            coords, name=name, color=color, alpha=alpha, hatch=hatch,\n            backend=self._get_backend()\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_cdf(\n        self,\n        data: ArrayLike1D,\n        *,\n        name: str | None = None,\n        orient: OrientationLike = \"vertical\",\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.Line:\n        \"\"\"\n        Add a empirical cumulative distribution function (CDF) plot.\n\n        &gt;&gt;&gt; canvas.add_cdf(np.random.normal(size=100))\n\n        Parameters\n        ----------\n        data : array-like\n            1D Array of data.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default \"vertical\"\n            Orientation of the bars.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        Line\n            The line layer that represents the CDF.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.Line.build_cdf(\n            data, orient=orient, name=name, color=color, width=width, style=style,\n            alpha=alpha, antialias=antialias, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_spans(\n        self,\n        spans: ArrayLike,\n        *,\n        name: str | None = None,\n        orient: OrientationLike = \"vertical\",\n        color: ColorType = \"blue\",\n        alpha: float = 0.4,\n        hatch: str | Hatch = Hatch.SOLID,\n    ) -&gt; _l.Spans:\n        \"\"\"\n        Add spans that extends infinitely.\n\n        &gt;&gt;&gt; canvas.add_spans([[5, 10], [15, 20]])\n\n           |::::|     |::::|\n           |::::|     |::::|\n        \u2500\u2500\u25005\u2500\u2500\u2500\u250010\u2500\u2500\u2500\u250015\u2500\u2500\u250020\u2500\u2500\u2500\u2500\u2500&gt;\n           |::::|     |::::|\n           |::::|     |::::|\n\n        Parameters\n        ----------\n        spans : (N, 2) array-like\n            Array that contains the start and end points of the spans.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default \"vertical\"\n            Orientation of the bars.\n        color : color-like, optional\n            Color of the bars.\n        alpha : float, default 0.4\n            Alpha channel of the bars.\n        hatch : str or FacePattern, default FacePattern.SOLID\n            Pattern of the bar faces.\n\n        Returns\n        -------\n        Spans\n            The spans layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        layer = _l.Spans(\n            spans, name=name, orient=orient, color=color, alpha=alpha,\n            hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_infline(\n        self,\n        pos: tuple[float, float] = (0, 0),\n        angle: float = 0.0,\n        *,\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfLine:\n        \"\"\"\n        Add an infinitely long line to the canvas.\n\n        &gt;&gt;&gt; canvas.add_infline((0, 0), 45)  # y = x\n        &gt;&gt;&gt; canvas.add_infline((1, 0), 90)  # x = 1\n        &gt;&gt;&gt; canvas.add_infline((0, -1), 0)  # y = -1\n\n        Parameters\n        ----------\n        pos : (float, float), default (0, 0)\n            One of the points this line passes.\n        angle : float, default 0.0\n            Angle of the line in degree, defined by the counter-clockwise\n            rotation from the x axis.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfLine\n            The infline layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.InfLine(\n            pos, angle, name=name, color=color, alpha=alpha,\n            width=width, style=style, antialias=antialias,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_infcurve(\n        self,\n        model: Callable[Concatenate[Any, _P], Any],\n        *,\n        bounds: tuple[float, float] = (-float(\"inf\"), float(\"inf\")),\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: str | LineStyle | None = None,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfCurve[_P]:\n        \"\"\"\n        Add an infinite curve to the canvas.\n\n        &gt;&gt;&gt; canvas.add_infcurve(lambda x: x ** 2)  # parabola\n        &gt;&gt;&gt; canvas.add_infcurve(lambda x, a: np.sin(a*x)).update_params(2)  # parametric\n\n        Parameters\n        ----------\n        model : callable\n            The model function. The first argument must be the x coordinates. Same\n            signature as `scipy.optimize.curve_fit`.\n        bounds : (float, float), default (-inf, inf)\n            Lower and upper bounds that the function is defined.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfCurve\n            The infcurve layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.InfCurve(\n            model, bounds=bounds, name=name, color=color, width=width, alpha=alpha,\n            style=style, antialias=antialias, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_hline(\n        self,\n        y: float,\n        *,\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str = LineStyle.SOLID,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfLine:\n        \"\"\"\n        Add a infinite horizontal line to the canvas.\n\n        Parameters\n        ----------\n        y : float\n            Y coordinate of the line.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfLine\n            The infline layer.\n        \"\"\"\n        return self.add_infline(\n            (0, y), 0, name=name, color=color, width=width, style=style, alpha=alpha,\n            antialias=antialias\n        )  # fmt: skip\n\n    def add_vline(\n        self,\n        x: float,\n        *,\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str = LineStyle.SOLID,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfLine:\n        \"\"\"\n        Add a infinite vertical line to the canvas.\n\n        Parameters\n        ----------\n        x : float\n            X coordinate of the line.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfLine\n            The infline layer.\n        \"\"\"\n        return self.add_infline(\n            (x, 0), 90, name=name, color=color, width=width, style=style, alpha=alpha,\n            antialias=antialias,\n        )  # fmt: skip\n\n    def add_band(\n        self,\n        xdata: ArrayLike1D,\n        ylow: ArrayLike1D,\n        yhigh: ArrayLike1D,\n        *,\n        name: str | None = None,\n        orient: OrientationLike = \"vertical\",\n        color: ColorType | None = None,\n        alpha: float = 1.0,\n        hatch: str | Hatch = Hatch.SOLID,\n    ) -&gt; _l.Band:\n        \"\"\"\n        Add a band (fill-between) layer to the canvas.\n\n        Parameters\n        ----------\n        xdata : array-like\n            X coordinates of the band.\n        ylow : array-like\n            Either lower or upper y coordinates of the band.\n        yhigh : array-like\n            The other y coordinates of the band.\n        name : str, optional\n            Name of the layer, by default None\n        orient : str, Orientation, default \"vertical\"\n            Orientation of the band. If vertical, band will be filled between\n            vertical orientation.,\n        color : color-like, default None\n            Color of the band face.,\n        alpha : float, default 1.0\n            Alpha channel of the band face.\n        hatch : str, FacePattern, default FacePattern.SOLID\n            Hatch of the band face.\n\n        Returns\n        -------\n        Band\n            The band layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        layer = _l.Band(\n            xdata, ylow, yhigh, name=name, orient=orient, color=color,\n            alpha=alpha, hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_errorbars(\n        self,\n        xdata: ArrayLike1D,\n        ylow: ArrayLike1D,\n        yhigh: ArrayLike1D,\n        *,\n        name: str | None = None,\n        orient: OrientationLike = \"vertical\",\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n        alpha: float = 1.0,\n        antialias: bool = False,\n        capsize: float = 0.0,\n    ) -&gt; _l.Errorbars:\n        \"\"\"\n        Add parallel lines as errorbars.\n\n        Parameters\n        ----------\n        xdata : array-like\n            X coordinates of the errorbars.\n        ylow : array-like\n            Lower bound of the errorbars.\n        yhigh : array-like\n            Upper bound of the errorbars.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default \"vertical\"\n            Orientation of the errorbars. If vertical, errorbars will be parallel\n            to the y axis.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n        capsize : float, default 0.0\n            Size of the caps of the error indicators\n\n        Returns\n        -------\n        Errorbars\n            The errorbars layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.Errorbars(\n            xdata, ylow, yhigh, name=name, color=color, width=width,\n            style=style, antialias=antialias, capsize=capsize, alpha=alpha,\n            orient=orient, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_rug(\n        self,\n        events: ArrayLike1D,\n        *,\n        low: float = 0.0,\n        high: float = 1.0,\n        name: str | None = None,\n        orient: OrientationLike = \"vertical\",\n        color: ColorType = \"black\",\n        width: float = 1.0,\n        style: LineStyle | str = LineStyle.SOLID,\n        antialias: bool = True,\n        alpha: float = 1.0,\n    ) -&gt; _l.Rug:\n        \"\"\"\n        Add input data as a rug plot.\n\n        &gt;&gt;&gt; canvas.add_rug([2, 4, 5, 8, 11])\n\n        ```\n          \u2502 \u2502\u2502  \u2502   \u2502\n        \u2500\u2500\u2534\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500&gt; x\n          2 45  8   11\n        ```\n\n        Parameters\n        ----------\n        events : array-like\n            A 1D array of events.\n        low : float, default 0.0\n            The lower bound of the rug lines.\n        high : float, default 1.0\n            The upper bound of the rug lines.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default \"vertical\"\n            Orientation of the errorbars. If vertical, rug lines will be parallel\n            to the y axis.\n        color : color-like, optional\n            Color of the bars.\n        width : float, default 1.0\n            Line width.\n        style : str or LineStyle, default LineStyle.SOLID\n            Line style.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        Rug\n            The rug layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        layer = _l.Rug(\n            events, low=low, high=high, name=name, color=color, alpha=alpha,\n            width=width, style=style, antialias=antialias, orient=orient,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_kde(\n        self,\n        data: ArrayLike1D,\n        *,\n        bottom: float = 0.0,\n        name: str | None = None,\n        orient: OrientationLike = \"vertical\",\n        band_width: KdeBandWidthType = \"scott\",\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n    ) -&gt; _lg.Kde:\n        \"\"\"\n        Add data as a band layer representing kernel density estimation (KDE).\n\n        Parameters\n        ----------\n        data : array-like\n            1D data to calculate the KDE.\n        bottom : float, default 0.0\n            Scalar value that define the height of the bottom line.\n        name : str, optional\n            Name of the layer, by default None\n        orient : str, Orientation, default \"vertical\"\n            Orientation of the KDE.\n        band_width : float or str, default \"scott\"\n            Method to calculate the estimator bandwidth.\n        color : color-like, default None\n            Color of the band face.\n        width : float, optional\n            Line width of the outline.\n        style : str or LineStyle, optional\n            Line style of the outline.\n\n        Returns\n        -------\n        Kde\n            The KDE layer.\n        \"\"\"\n        name = self._coerce_name(name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n\n        layer = _lg.Kde.from_array(\n            data, bottom=bottom, scale=1, band_width=band_width, name=name,\n            orient=orient, color=color, width=width, style=style,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    @overload\n    def add_text(\n        self, x: ArrayLike1D, y: ArrayLike1D, string: list[str], *,\n        color: ColorType = \"black\", size: float = 12, rotation: float = 0.0,\n        anchor: str | Alignment = Alignment.BOTTOM_LEFT, family: str | None = None,\n    ) -&gt; _l.Texts[_mixin.ConstFace, _mixin.ConstEdge, _mixin.ConstFont]:  # fmt: skip\n        ...\n\n    @overload\n    def add_text(\n        self, x: float, y: float, string: str, *, color: ColorType = \"black\",\n        size: float = 12, rotation: float = 0.0,\n        anchor: str | Alignment = Alignment.BOTTOM_LEFT, family: str | None = None,\n    ) -&gt; _l.Texts[_mixin.ConstFace, _mixin.ConstEdge, _mixin.ConstFont]:  # fmt: skip\n        ...\n\n    def add_text(\n        self,\n        x,\n        y,\n        string,\n        *,\n        color=\"black\",\n        size=12,\n        rotation=0.0,\n        anchor=Alignment.BOTTOM_LEFT,\n        family=None,\n    ):\n        \"\"\"\n        Add a text layer to the canvas.\n\n        &gt;&gt;&gt; canvas.add_text([0, 0], [1, 1], [\"text-0\", \"text-1])\n        &gt;&gt;&gt; canvas.add_text(...).with_face(color=\"red\")  # with background\n        &gt;&gt;&gt; canvas.add_text(...).with_edge(color=\"red\")  # with outline\n\n        Parameters\n        ----------\n        x : float or array-like\n            X position(s) of the text.\n        y : float or array-like\n            Y position(s) of the text.\n        string : str or list[str]\n            Text string to display.\n        color : ColorType, optional\n            Color of the text string.\n        size : float, default 12\n            Point size of the text.\n        rotation : float, default 0.0\n            Rotation angle of the text in degrees.\n        anchor : str or Alignment, default Alignment.BOTTOM_LEFT\n            Anchor position of the text. The anchor position will be the coordinate\n            given by (x, y).\n        family : str, optional\n            Font family of the text.\n\n        Returns\n        -------\n        Texts\n            The text layer.\n        \"\"\"\n        if is_real_number(x) and is_real_number(y) and isinstance(string, str):\n            x, y, string = [x], [y], [string]\n        x_, y_ = normalize_xy(x, y)\n        if isinstance(string, str):\n            string = [string] * x_.size\n        elif len(string) != x_.size:\n            raise ValueError(\"Expected string to have the same size as x/y\")\n        layer = _l.Texts(\n            x_, y_, string, color=color, size=size, rotation=rotation, anchor=anchor,\n            family=family, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_image(\n        self,\n        image: ArrayLike,\n        *,\n        name: str | None = None,\n        cmap: ColormapType = \"gray\",\n        clim: tuple[float | None, float | None] | None = None,\n        flip_canvas: bool = True,\n        lock_aspect: bool = True,\n    ) -&gt; _l.Image:\n        \"\"\"\n        Add an image layer to the canvas.\n\n        This method automatically flips the image vertically by default. `add_heatmap`\n        does the similar thing with slightly different default settings.\n\n        Parameters\n        ----------\n        image : ArrayLike\n            Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n            RGB(A). Note that the first dimension is the vertical axis.\n        cmap : ColormapType, default \"gray\"\n            Colormap used for the image.\n        clim : (float or None, float or None) or None\n            Contrast limits. If None, the limits are automatically determined by min and\n            max of the data. You can also pass None separately to either limit to use\n            the default behavior.\n        flip_canvas : bool, default True\n            If True, flip the canvas vertically so that the image looks normal.\n        lock_aspect : bool, default True\n            If True, lock the aspect ratio of the canvas to 1:1.\n\n        Returns\n        -------\n        Image\n            The image layer.\n        \"\"\"\n        layer = _l.Image(\n            image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n        )\n        self.add_layer(layer)\n        if flip_canvas and not self.y.flipped:\n            self.y.flipped = True\n        if lock_aspect:\n            self.aspect_ratio = 1.0\n        return layer\n\n    def add_heatmap(\n        self,\n        image: ArrayLike,\n        *,\n        name: str | None = None,\n        cmap: ColormapType = \"inferno\",\n        clim: tuple[float | None, float | None] | None = None,\n        flip_canvas: bool = False,\n    ) -&gt; _l.Image:\n        \"\"\"\n        Add an image layer to the canvas as a heatmap.\n\n        Use `add_image` to add the layer as an image.\n\n        Parameters\n        ----------\n        image : ArrayLike\n            Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n            RGB(A). Note that the first dimension is the vertical axis.\n        cmap : ColormapType, default \"gray\"\n            Colormap used for the image.\n        clim : (float or None, float or None) or None\n            Contrast limits. If None, the limits are automatically determined by min and\n            max of the data. You can also pass None separately to either limit to use\n            the default behavior.\n        flip_canvas : bool, default False\n            If True, flip the canvas vertically so that the image looks normal.\n\n        Returns\n        -------\n        Image\n            The image layer.\n        \"\"\"\n        layer = _l.Image(\n            image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n        )\n        self.add_layer(layer)\n        if flip_canvas and not self.y.flipped:\n            self.y.flipped = True\n        return layer\n\n    def add_layer(\n        self,\n        layer: _L,\n        *,\n        over: _l.Layer | Iterable[_l.Layer] | None = None,\n        under: _l.Layer | Iterable[_l.Layer] | None = None,\n    ) -&gt; _L:\n        \"\"\"Add a layer to the canvas.\"\"\"\n        if over is None and under is None:\n            self.layers.append(layer)\n        elif over is not None:\n            if under is not None:\n                raise ValueError(\"Cannot specify both `over` and `under`\")\n            if isinstance(over, _l.Layer):\n                idx = self.layers.index(over)\n            else:\n                idx = max([self.layers.index(l) for l in over])\n            self.layers.insert(idx + 1, layer)\n        else:\n            if isinstance(under, _l.Layer):\n                idx = self.layers.index(under)\n            else:\n                idx = min([self.layers.index(l) for l in under])\n            self.layers.insert(idx, layer)\n        return layer\n\n    @overload\n    def group_layers(\n        self,\n        layers: Iterable[_l.Layer],\n        name: str | None = None,\n    ) -&gt; _l.LayerGroup: ...\n\n    @overload\n    def group_layers(\n        self, *layers: _l.Layer, name: str | None = None\n    ) -&gt; _l.LayerGroup: ...\n\n    def group_layers(self, layers, *more_layers, name=None):\n        \"\"\"\n        Group layers.\n\n        Parameters\n        ----------\n        layers : iterable of Layer\n            Layers to group.\n\n        Returns\n        -------\n        LayerGroup\n            The grouped layer.\n        \"\"\"\n        if more_layers:\n            if not isinstance(layers, _l.Layer):\n                raise TypeError(\"No overload matches the arguments\")\n            layers = [layers, *more_layers]\n        return _lg.LayerTuple(layers, name=name)\n\n    def _coerce_name(self, name: str | None, default: str = \"data\") -&gt; str:\n        if name is None:\n            basename = default\n            name = f\"{default}-0\"\n        else:\n            basename = name\n        i = 0\n        _exists = {layer.name for layer in self.layers}\n        while name in _exists:\n            name = f\"{basename}-{i}\"\n            i += 1\n        return name\n\n    def _autoscale_for_layer(\n        self,\n        layer: _l.Layer,\n        pad_rel: float | None = None,\n        maybe_empty: bool = True,\n    ):\n        \"\"\"This function will be called when a layer is inserted to the canvas.\"\"\"\n        if not self.autoscale_enabled:\n            return\n        if pad_rel is None:\n            pad_rel = 0 if layer._NO_PADDING_NEEDED else 0.025\n        xmin, xmax, ymin, ymax = layer.bbox_hint()\n        if len(self.layers) &gt; 1 or not maybe_empty:\n            # NOTE: if there was no layer, so backend may not have xlim/ylim,\n            # or they may be set to a default value.\n            _xmin, _xmax = self.x.lim\n            _ymin, _ymax = self.y.lim\n            _dx = (_xmax - _xmin) * pad_rel\n            _dy = (_ymax - _ymin) * pad_rel\n            xmin = np.min([xmin, _xmin + _dx])\n            xmax = np.max([xmax, _xmax - _dx])\n            ymin = np.min([ymin, _ymin + _dy])\n            ymax = np.max([ymax, _ymax - _dy])\n\n        # this happens when there is &lt;= 1 data\n        small_diff = 1e-6\n        if np.isnan(xmax) or np.isnan(xmin):\n            xmin, xmax = self.x.lim\n        elif xmax - xmin &lt; small_diff:\n            xmin -= 0.05\n            xmax += 0.05\n        else:\n            dx = (xmax - xmin) * pad_rel\n            if (\n                xmin != 0\n                or not layer._ATTACH_TO_AXIS\n                or getattr(layer, \"orient\", None) is not Orientation.HORIZONTAL\n            ):\n                xmin -= dx\n            xmax += dx\n        if np.isnan(ymax) or np.isnan(ymin):\n            ymin, ymax = self.y.lim\n        elif ymax - ymin &lt; small_diff:\n            ymin -= 0.05\n            ymax += 0.05\n        else:\n            dy = (ymax - ymin) * pad_rel\n            if (\n                ymin != 0\n                or not layer._ATTACH_TO_AXIS\n                or getattr(layer, \"orient\", None) is not Orientation.VERTICAL\n            ):\n                ymin -= dy\n            ymax += dy\n        self.lims = xmin, xmax, ymin, ymax\n\n    def _cb_inserted(self, idx: int, layer: _l.Layer):\n        if self._is_grouping:\n            # this happens when the grouped layer is inserted\n            layer._connect_canvas(self)\n            return\n\n        _canvas = self._canvas()\n        for l in _iter_layers(layer):\n            _canvas._plt_add_layer(l._backend)\n            l._connect_canvas(self)\n\n        if isinstance(layer, _l.LayerWrapper):\n            # TODO: check if connecting LayerGroup is necessary\n            layer._connect_canvas(self)\n        # autoscale\n        self._autoscale_for_layer(layer)\n        self._cb_reordered()\n\n    def _cb_overlay_inserted(self, idx: int, layer: _l.Layer):\n        _canvas = self._canvas()\n        fn = self._get_backend().get(\"as_overlay\")\n        for l in _iter_layers(layer):\n            _canvas._plt_add_layer(l._backend)\n            fn(l._backend, _canvas)\n            l._connect_canvas(self)\n\n        if isinstance(layer, _l.LayerWrapper):\n            # TODO: check if connecting LayerGroup is necessary\n            fn(l._backend, _canvas)\n            layer._connect_canvas(self)\n\n    def _cb_removed(self, idx: int, layer: _l.Layer):\n        if self._is_grouping:\n            return\n        _canvas = self._canvas()\n        for l in _iter_layers(layer):\n            _canvas._plt_remove_layer(l._backend)\n            l._disconnect_canvas(self)\n\n    def _cb_reordered(self):\n        layer_backends = []\n        for layer in self.layers:\n            if isinstance(layer, _l.PrimitiveLayer):\n                layer_backends.append(layer._backend)\n            elif isinstance(layer, _l.LayerGroup):\n                for child in layer.iter_primitive():\n                    layer_backends.append(child._backend)\n            elif isinstance(layer, _l.LayerWrapper):\n                for child in _iter_layers(layer):\n                    layer_backends.append(child._backend)\n            else:\n                raise RuntimeError(f\"type {type(layer)} not expected\")\n        self._canvas()._plt_reorder_layers(layer_backends)\n\n    def _cb_layer_grouped(self, group: _l.LayerGroup):\n        indices: list[int] = []  # layers to remove\n        not_found: list[_l.PrimitiveLayer] = []  # primitive layers to add\n        id_exists = set(map(id, self.layers.iter_primitives()))\n        for layer in group.iter_children():\n            try:\n                idx = self.layers.index(layer)\n                indices.append(idx)\n            except ValueError:\n                not_found.extend(_iter_layers(layer))\n        if not indices:\n            return\n        self._is_grouping = True\n        try:\n            for idx in reversed(indices):\n                # remove from the layer list since it is directly grouped\n                self.layers.pop(idx)\n            self.layers.append(group)\n            _canvas = self._canvas()\n            for child in not_found:\n                if id(child) in id_exists:\n                    # skip since it is already in the canvas\n                    continue\n                child._connect_canvas(self)\n                _canvas._plt_add_layer(child._backend)\n        finally:\n            self._is_grouping = False\n        self._cb_reordered()\n        self._autoscale_for_layer(group)\n\n    def _generate_colors(self, color: ColorType | None) -&gt; Color:\n        if color is None:\n            color = self._color_palette.next()\n        return color\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.aspect_ratio","title":"<code>aspect_ratio: float | None</code>  <code>property</code> <code>writable</code>","text":"<p>Aspect ratio of the canvas (None if not locked).</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.autoscale_enabled","title":"<code>autoscale_enabled: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether autoscale is enabled.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.lims","title":"<code>lims: Rect</code>  <code>property</code> <code>writable</code>","text":"<p>Return the x/y limits of the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.native","title":"<code>native: Any</code>  <code>property</code>","text":"<p>Return the native canvas object.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.visible","title":"<code>visible</code>  <code>property</code> <code>writable</code>","text":"<p>Show the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_band","title":"<code>add_band(xdata, ylow, yhigh, *, name=None, orient='vertical', color=None, alpha=1.0, hatch=Hatch.SOLID)</code>","text":"<p>Add a band (fill-between) layer to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>xdata</code> <code>array - like</code> <p>X coordinates of the band.</p> required <code>ylow</code> <code>array - like</code> <p>Either lower or upper y coordinates of the band.</p> required <code>yhigh</code> <code>array - like</code> <p>The other y coordinates of the band.</p> required <code>name</code> <code>str</code> <p>Name of the layer, by default None</p> <code>None</code> <code>orient</code> <code>(str, Orientation)</code> <p>Orientation of the band. If vertical, band will be filled between vertical orientation.,</p> <code>\"vertical\"</code> <code>color</code> <code>color - like</code> <p>Color of the band face.,</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the band face.</p> <code>1.0</code> <code>hatch</code> <code>(str, FacePattern)</code> <p>Hatch of the band face.</p> <code>FacePattern.SOLID</code> <p>Returns:</p> Type Description <code>Band</code> <p>The band layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_band(\n    self,\n    xdata: ArrayLike1D,\n    ylow: ArrayLike1D,\n    yhigh: ArrayLike1D,\n    *,\n    name: str | None = None,\n    orient: OrientationLike = \"vertical\",\n    color: ColorType | None = None,\n    alpha: float = 1.0,\n    hatch: str | Hatch = Hatch.SOLID,\n) -&gt; _l.Band:\n    \"\"\"\n    Add a band (fill-between) layer to the canvas.\n\n    Parameters\n    ----------\n    xdata : array-like\n        X coordinates of the band.\n    ylow : array-like\n        Either lower or upper y coordinates of the band.\n    yhigh : array-like\n        The other y coordinates of the band.\n    name : str, optional\n        Name of the layer, by default None\n    orient : str, Orientation, default \"vertical\"\n        Orientation of the band. If vertical, band will be filled between\n        vertical orientation.,\n    color : color-like, default None\n        Color of the band face.,\n    alpha : float, default 1.0\n        Alpha channel of the band face.\n    hatch : str, FacePattern, default FacePattern.SOLID\n        Hatch of the band face.\n\n    Returns\n    -------\n    Band\n        The band layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    layer = _l.Band(\n        xdata, ylow, yhigh, name=name, orient=orient, color=color,\n        alpha=alpha, hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_bars","title":"<code>add_bars(*args, bottom=None, name=None, orient='vertical', extent=None, color=None, alpha=1.0, hatch=None)</code>","text":"<p>Add a bar plot.</p> <p>canvas.add_bars(x, heights)  # standard usage canvas.add_bars(heights)  # use 0, 1, ... for the x values canvas.add_bars(..., orient=\"horizontal\")  # horizontal bars</p> <p>Parameters:</p> Name Type Description Default <code>bottom</code> <code>float or array - like</code> <p>Bottom level of the bars.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>\"vertical\"</code> <code>extent</code> <code>float</code> <p>Bar width in the canvas coordinate</p> <code>0.8</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the bars.</p> <code>1.0</code> <code>hatch</code> <code>str or FacePattern</code> <p>Pattern of the bar faces.</p> <code>FacePattern.SOLID</code> <p>Returns:</p> Type Description <code>Bars</code> <p>The bars layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_bars(\n    self,\n    *args,\n    bottom=None,\n    name=None,\n    orient=\"vertical\",\n    extent=None,\n    color=None,\n    alpha=1.0,\n    hatch=None,\n):\n    \"\"\"\n    Add a bar plot.\n\n    &gt;&gt;&gt; canvas.add_bars(x, heights)  # standard usage\n    &gt;&gt;&gt; canvas.add_bars(heights)  # use 0, 1, ... for the x values\n    &gt;&gt;&gt; canvas.add_bars(..., orient=\"horizontal\")  # horizontal bars\n\n    Parameters\n    ----------\n    bottom : float or array-like, optional\n        Bottom level of the bars.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default \"vertical\"\n        Orientation of the bars.\n    extent : float, default 0.8\n        Bar width in the canvas coordinate\n    color : color-like, optional\n        Color of the bars.\n    alpha : float, default 1.0\n        Alpha channel of the bars.\n    hatch : str or FacePattern, default FacePattern.SOLID\n        Pattern of the bar faces.\n\n    Returns\n    -------\n    Bars\n        The bars layer.\n    \"\"\"\n    center, height = normalize_xy(*args)\n    if bottom is not None:\n        bottom = as_array_1d(bottom)\n        if bottom.shape != height.shape:\n            raise ValueError(\"Expected bottom to have the same shape as height\")\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    extent = theme._default(\"bars.extent\", extent)\n    hatch = theme._default(\"bars.hatch\", hatch)\n    layer = _l.Bars(\n        center, height, bottom, extent=extent, name=name, orient=orient,\n        color=color, alpha=alpha, hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_cdf","title":"<code>add_cdf(data, *, name=None, orient='vertical', color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add a empirical cumulative distribution function (CDF) plot.</p> <p>canvas.add_cdf(np.random.normal(size=100))</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>1D Array of data.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>\"vertical\"</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>Line</code> <p>The line layer that represents the CDF.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_cdf(\n    self,\n    data: ArrayLike1D,\n    *,\n    name: str | None = None,\n    orient: OrientationLike = \"vertical\",\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.Line:\n    \"\"\"\n    Add a empirical cumulative distribution function (CDF) plot.\n\n    &gt;&gt;&gt; canvas.add_cdf(np.random.normal(size=100))\n\n    Parameters\n    ----------\n    data : array-like\n        1D Array of data.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default \"vertical\"\n        Orientation of the bars.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    Line\n        The line layer that represents the CDF.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.Line.build_cdf(\n        data, orient=orient, name=name, color=color, width=width, style=style,\n        alpha=alpha, antialias=antialias, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_errorbars","title":"<code>add_errorbars(xdata, ylow, yhigh, *, name=None, orient='vertical', color=None, width=None, style=None, alpha=1.0, antialias=False, capsize=0.0)</code>","text":"<p>Add parallel lines as errorbars.</p> <p>Parameters:</p> Name Type Description Default <code>xdata</code> <code>array - like</code> <p>X coordinates of the errorbars.</p> required <code>ylow</code> <code>array - like</code> <p>Lower bound of the errorbars.</p> required <code>yhigh</code> <code>array - like</code> <p>Upper bound of the errorbars.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the errorbars. If vertical, errorbars will be parallel to the y axis.</p> <code>\"vertical\"</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <code>capsize</code> <code>float</code> <p>Size of the caps of the error indicators</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Errorbars</code> <p>The errorbars layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_errorbars(\n    self,\n    xdata: ArrayLike1D,\n    ylow: ArrayLike1D,\n    yhigh: ArrayLike1D,\n    *,\n    name: str | None = None,\n    orient: OrientationLike = \"vertical\",\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n    alpha: float = 1.0,\n    antialias: bool = False,\n    capsize: float = 0.0,\n) -&gt; _l.Errorbars:\n    \"\"\"\n    Add parallel lines as errorbars.\n\n    Parameters\n    ----------\n    xdata : array-like\n        X coordinates of the errorbars.\n    ylow : array-like\n        Lower bound of the errorbars.\n    yhigh : array-like\n        Upper bound of the errorbars.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default \"vertical\"\n        Orientation of the errorbars. If vertical, errorbars will be parallel\n        to the y axis.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n    capsize : float, default 0.0\n        Size of the caps of the error indicators\n\n    Returns\n    -------\n    Errorbars\n        The errorbars layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.Errorbars(\n        xdata, ylow, yhigh, name=name, color=color, width=width,\n        style=style, antialias=antialias, capsize=capsize, alpha=alpha,\n        orient=orient, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_heatmap","title":"<code>add_heatmap(image, *, name=None, cmap='inferno', clim=None, flip_canvas=False)</code>","text":"<p>Add an image layer to the canvas as a heatmap.</p> <p>Use <code>add_image</code> to add the layer as an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ArrayLike</code> <p>Image data. Must be 2D or 3D array. If 3D, the last dimension must be RGB(A). Note that the first dimension is the vertical axis.</p> required <code>cmap</code> <code>ColormapType</code> <p>Colormap used for the image.</p> <code>\"gray\"</code> <code>clim</code> <code>(float or None, float or None) or None</code> <p>Contrast limits. If None, the limits are automatically determined by min and max of the data. You can also pass None separately to either limit to use the default behavior.</p> <code>None</code> <code>flip_canvas</code> <code>bool</code> <p>If True, flip the canvas vertically so that the image looks normal.</p> <code>False</code> <p>Returns:</p> Type Description <code>Image</code> <p>The image layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_heatmap(\n    self,\n    image: ArrayLike,\n    *,\n    name: str | None = None,\n    cmap: ColormapType = \"inferno\",\n    clim: tuple[float | None, float | None] | None = None,\n    flip_canvas: bool = False,\n) -&gt; _l.Image:\n    \"\"\"\n    Add an image layer to the canvas as a heatmap.\n\n    Use `add_image` to add the layer as an image.\n\n    Parameters\n    ----------\n    image : ArrayLike\n        Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n        RGB(A). Note that the first dimension is the vertical axis.\n    cmap : ColormapType, default \"gray\"\n        Colormap used for the image.\n    clim : (float or None, float or None) or None\n        Contrast limits. If None, the limits are automatically determined by min and\n        max of the data. You can also pass None separately to either limit to use\n        the default behavior.\n    flip_canvas : bool, default False\n        If True, flip the canvas vertically so that the image looks normal.\n\n    Returns\n    -------\n    Image\n        The image layer.\n    \"\"\"\n    layer = _l.Image(\n        image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n    )\n    self.add_layer(layer)\n    if flip_canvas and not self.y.flipped:\n        self.y.flipped = True\n    return layer\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_hist","title":"<code>add_hist(data, *, bins='auto', limits=None, name=None, shape='bars', kind='count', orient='vertical', color=None, width=None, style=None)</code>","text":"<p>Add data as a histogram.</p> <p>canvas.add_hist(np.random.normal(size=100), bins=12)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>1D Array of data.</p> required <code>bins</code> <code>int or 1D array-like</code> <p>Bins of the histogram. This parameter will directly be passed to <code>np.histogram</code>.</p> <code>\"auto\"</code> <code>limits</code> <code>(float, float)</code> <p>Limits in which histogram will be built. This parameter will equivalent to the <code>range</code> paraneter of <code>np.histogram</code>.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>shape</code> <code>('step', 'polygon', 'bars')</code> <p>Shape of the histogram. This parameter defines how to convert the data into the line nodes.</p> <code>\"step\"</code> <code>kind</code> <code>('count', 'density', 'probability', 'frequency', 'percent')</code> <p>Kind of the histogram.</p> <code>\"count\"</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>\"vertical\"</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bars</code> <p>The bars layer that represents the histogram.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_hist(\n    self,\n    data: ArrayLike1D,\n    *,\n    bins: HistBinType = \"auto\",\n    limits: tuple[float, float] | None = None,\n    name: str | None = None,\n    shape: Literal[\"step\", \"polygon\", \"bars\"] = \"bars\",\n    kind: Literal[\"count\", \"density\", \"frequency\", \"percent\"] = \"count\",\n    orient: OrientationLike = \"vertical\",\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n) -&gt; _lg.Histogram:\n    \"\"\"\n    Add data as a histogram.\n\n    &gt;&gt;&gt; canvas.add_hist(np.random.normal(size=100), bins=12)\n\n    Parameters\n    ----------\n    data : array-like\n        1D Array of data.\n    bins : int or 1D array-like, default \"auto\"\n        Bins of the histogram. This parameter will directly be passed\n        to `np.histogram`.\n    limits : (float, float), optional\n        Limits in which histogram will be built. This parameter will equivalent to\n        the `range` paraneter of `np.histogram`.\n    name : str, optional\n        Name of the layer.\n    shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n        Shape of the histogram. This parameter defines how to convert the data into\n        the line nodes.\n    kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n        Kind of the histogram.\n    orient : str or Orientation, default \"vertical\"\n        Orientation of the bars.\n    color : color-like, optional\n        Color of the bars.\n\n    Returns\n    -------\n    Bars\n        The bars layer that represents the histogram.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _lg.Histogram.from_array(\n        data, bins=bins, limits=limits, shape=shape, kind=kind, name=name,\n        color=color, width=width, style=style, orient=orient,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_hist2d","title":"<code>add_hist2d(x, y, *, cmap='inferno', name=None, bins='auto', rangex=None, rangey=None, density=False)</code>","text":"<p>Add a 2D histogram of given X/Y data.</p> <p>x = np.random.normal(size=100) y = np.random.normal(size=200) canvas.add_hist2d(x, y)</p> <p>Note that unlike <code>add_image()</code> method, this method does not lock the aspect ratio and flip the canvas by default.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>1D Array of X data.</p> required <code>y</code> <code>array - like</code> <p>1D Array of Y data.</p> required <code>cmap</code> <code>ColormapType</code> <p>Colormap used for the image.</p> <code>\"gray\"</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>bins</code> <code>int or tuple[int, int]</code> <p>Bins of the histogram of X/Y dimension respectively. If an integer is given, it will be used for both dimensions.</p> <code>'auto'</code> <code>rangex</code> <code>(float, float)</code> <p>Range of x values in which histogram will be built.</p> <code>None</code> <code>rangey</code> <code>(float, float)</code> <p>Range of y values in which histogram will be built.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, values of the histogram will be normalized so that the total intensity of the histogram will be 1.</p> <code>False</code> <p>Returns:</p> Type Description <code>Image</code> <p>Image layer representing the 2D histogram.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_hist2d(\n    self,\n    x: ArrayLike1D,\n    y: ArrayLike1D,\n    *,\n    cmap: ColormapType = \"inferno\",\n    name: str | None = None,\n    bins: HistBinType | tuple[HistBinType, HistBinType] = \"auto\",\n    rangex: tuple[float, float] | None = None,\n    rangey: tuple[float, float] | None = None,\n    density: bool = False,\n) -&gt; _l.Image:\n    \"\"\"\n    Add a 2D histogram of given X/Y data.\n\n    &gt;&gt;&gt; x = np.random.normal(size=100)\n    &gt;&gt;&gt; y = np.random.normal(size=200)\n    &gt;&gt;&gt; canvas.add_hist2d(x, y)\n\n    Note that unlike `add_image()` method, this method does not lock the aspect\n    ratio and flip the canvas by default.\n\n    Parameters\n    ----------\n    x : array-like\n        1D Array of X data.\n    y : array-like\n        1D Array of Y data.\n    cmap : ColormapType, default \"gray\"\n        Colormap used for the image.\n    name : str, optional\n        Name of the layer.\n    bins : int or tuple[int, int], optional\n        Bins of the histogram of X/Y dimension respectively. If an integer is given,\n        it will be used for both dimensions.\n    rangex : (float, float), optional\n        Range of x values in which histogram will be built.\n    rangey : (float, float), optional\n        Range of y values in which histogram will be built.\n    density : bool, default False\n        If True, values of the histogram will be normalized so that the total\n        intensity of the histogram will be 1.\n\n    Returns\n    -------\n    Image\n        Image layer representing the 2D histogram.\n    \"\"\"\n    layer = _l.Image.build_hist(\n        x, y, bins=bins, range=(rangex, rangey), density=density, name=name,\n        cmap=cmap, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_hline","title":"<code>add_hline(y, *, name=None, color=None, width=None, style=LineStyle.SOLID, alpha=1.0, antialias=True)</code>","text":"<p>Add a infinite horizontal line to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>float</code> <p>Y coordinate of the line.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>SOLID</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfLine</code> <p>The infline layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_hline(\n    self,\n    y: float,\n    *,\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str = LineStyle.SOLID,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfLine:\n    \"\"\"\n    Add a infinite horizontal line to the canvas.\n\n    Parameters\n    ----------\n    y : float\n        Y coordinate of the line.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfLine\n        The infline layer.\n    \"\"\"\n    return self.add_infline(\n        (0, y), 0, name=name, color=color, width=width, style=style, alpha=alpha,\n        antialias=antialias\n    )  # fmt: skip\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_image","title":"<code>add_image(image, *, name=None, cmap='gray', clim=None, flip_canvas=True, lock_aspect=True)</code>","text":"<p>Add an image layer to the canvas.</p> <p>This method automatically flips the image vertically by default. <code>add_heatmap</code> does the similar thing with slightly different default settings.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ArrayLike</code> <p>Image data. Must be 2D or 3D array. If 3D, the last dimension must be RGB(A). Note that the first dimension is the vertical axis.</p> required <code>cmap</code> <code>ColormapType</code> <p>Colormap used for the image.</p> <code>\"gray\"</code> <code>clim</code> <code>(float or None, float or None) or None</code> <p>Contrast limits. If None, the limits are automatically determined by min and max of the data. You can also pass None separately to either limit to use the default behavior.</p> <code>None</code> <code>flip_canvas</code> <code>bool</code> <p>If True, flip the canvas vertically so that the image looks normal.</p> <code>True</code> <code>lock_aspect</code> <code>bool</code> <p>If True, lock the aspect ratio of the canvas to 1:1.</p> <code>True</code> <p>Returns:</p> Type Description <code>Image</code> <p>The image layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_image(\n    self,\n    image: ArrayLike,\n    *,\n    name: str | None = None,\n    cmap: ColormapType = \"gray\",\n    clim: tuple[float | None, float | None] | None = None,\n    flip_canvas: bool = True,\n    lock_aspect: bool = True,\n) -&gt; _l.Image:\n    \"\"\"\n    Add an image layer to the canvas.\n\n    This method automatically flips the image vertically by default. `add_heatmap`\n    does the similar thing with slightly different default settings.\n\n    Parameters\n    ----------\n    image : ArrayLike\n        Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n        RGB(A). Note that the first dimension is the vertical axis.\n    cmap : ColormapType, default \"gray\"\n        Colormap used for the image.\n    clim : (float or None, float or None) or None\n        Contrast limits. If None, the limits are automatically determined by min and\n        max of the data. You can also pass None separately to either limit to use\n        the default behavior.\n    flip_canvas : bool, default True\n        If True, flip the canvas vertically so that the image looks normal.\n    lock_aspect : bool, default True\n        If True, lock the aspect ratio of the canvas to 1:1.\n\n    Returns\n    -------\n    Image\n        The image layer.\n    \"\"\"\n    layer = _l.Image(\n        image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n    )\n    self.add_layer(layer)\n    if flip_canvas and not self.y.flipped:\n        self.y.flipped = True\n    if lock_aspect:\n        self.aspect_ratio = 1.0\n    return layer\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_infcurve","title":"<code>add_infcurve(model, *, bounds=(-float('inf'), float('inf')), name=None, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add an infinite curve to the canvas.</p> <p>canvas.add_infcurve(lambda x: x ** 2)  # parabola canvas.add_infcurve(lambda x, a: np.sin(a*x)).update_params(2)  # parametric</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>callable</code> <p>The model function. The first argument must be the x coordinates. Same signature as <code>scipy.optimize.curve_fit</code>.</p> required <code>bounds</code> <code>(float, float)</code> <p>Lower and upper bounds that the function is defined.</p> <code>(-inf, inf)</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfCurve</code> <p>The infcurve layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_infcurve(\n    self,\n    model: Callable[Concatenate[Any, _P], Any],\n    *,\n    bounds: tuple[float, float] = (-float(\"inf\"), float(\"inf\")),\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: str | LineStyle | None = None,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfCurve[_P]:\n    \"\"\"\n    Add an infinite curve to the canvas.\n\n    &gt;&gt;&gt; canvas.add_infcurve(lambda x: x ** 2)  # parabola\n    &gt;&gt;&gt; canvas.add_infcurve(lambda x, a: np.sin(a*x)).update_params(2)  # parametric\n\n    Parameters\n    ----------\n    model : callable\n        The model function. The first argument must be the x coordinates. Same\n        signature as `scipy.optimize.curve_fit`.\n    bounds : (float, float), default (-inf, inf)\n        Lower and upper bounds that the function is defined.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfCurve\n        The infcurve layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.InfCurve(\n        model, bounds=bounds, name=name, color=color, width=width, alpha=alpha,\n        style=style, antialias=antialias, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_infline","title":"<code>add_infline(pos=(0, 0), angle=0.0, *, name=None, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add an infinitely long line to the canvas.</p> <p>canvas.add_infline((0, 0), 45)  # y = x canvas.add_infline((1, 0), 90)  # x = 1 canvas.add_infline((0, -1), 0)  # y = -1</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>(float, float)</code> <p>One of the points this line passes.</p> <code>(0, 0)</code> <code>angle</code> <code>float</code> <p>Angle of the line in degree, defined by the counter-clockwise rotation from the x axis.</p> <code>0.0</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfLine</code> <p>The infline layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_infline(\n    self,\n    pos: tuple[float, float] = (0, 0),\n    angle: float = 0.0,\n    *,\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfLine:\n    \"\"\"\n    Add an infinitely long line to the canvas.\n\n    &gt;&gt;&gt; canvas.add_infline((0, 0), 45)  # y = x\n    &gt;&gt;&gt; canvas.add_infline((1, 0), 90)  # x = 1\n    &gt;&gt;&gt; canvas.add_infline((0, -1), 0)  # y = -1\n\n    Parameters\n    ----------\n    pos : (float, float), default (0, 0)\n        One of the points this line passes.\n    angle : float, default 0.0\n        Angle of the line in degree, defined by the counter-clockwise\n        rotation from the x axis.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfLine\n        The infline layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.InfLine(\n        pos, angle, name=name, color=color, alpha=alpha,\n        width=width, style=style, antialias=antialias,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_kde","title":"<code>add_kde(data, *, bottom=0.0, name=None, orient='vertical', band_width='scott', color=None, width=None, style=None)</code>","text":"<p>Add data as a band layer representing kernel density estimation (KDE).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>1D data to calculate the KDE.</p> required <code>bottom</code> <code>float</code> <p>Scalar value that define the height of the bottom line.</p> <code>0.0</code> <code>name</code> <code>str</code> <p>Name of the layer, by default None</p> <code>None</code> <code>orient</code> <code>(str, Orientation)</code> <p>Orientation of the KDE.</p> <code>\"vertical\"</code> <code>band_width</code> <code>float or str</code> <p>Method to calculate the estimator bandwidth.</p> <code>\"scott\"</code> <code>color</code> <code>color - like</code> <p>Color of the band face.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width of the outline.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style of the outline.</p> <code>None</code> <p>Returns:</p> Type Description <code>Kde</code> <p>The KDE layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_kde(\n    self,\n    data: ArrayLike1D,\n    *,\n    bottom: float = 0.0,\n    name: str | None = None,\n    orient: OrientationLike = \"vertical\",\n    band_width: KdeBandWidthType = \"scott\",\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n) -&gt; _lg.Kde:\n    \"\"\"\n    Add data as a band layer representing kernel density estimation (KDE).\n\n    Parameters\n    ----------\n    data : array-like\n        1D data to calculate the KDE.\n    bottom : float, default 0.0\n        Scalar value that define the height of the bottom line.\n    name : str, optional\n        Name of the layer, by default None\n    orient : str, Orientation, default \"vertical\"\n        Orientation of the KDE.\n    band_width : float or str, default \"scott\"\n        Method to calculate the estimator bandwidth.\n    color : color-like, default None\n        Color of the band face.\n    width : float, optional\n        Line width of the outline.\n    style : str or LineStyle, optional\n        Line style of the outline.\n\n    Returns\n    -------\n    Kde\n        The KDE layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n\n    layer = _lg.Kde.from_array(\n        data, bottom=bottom, scale=1, band_width=band_width, name=name,\n        orient=orient, color=color, width=width, style=style,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_layer","title":"<code>add_layer(layer, *, over=None, under=None)</code>","text":"<p>Add a layer to the canvas.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_layer(\n    self,\n    layer: _L,\n    *,\n    over: _l.Layer | Iterable[_l.Layer] | None = None,\n    under: _l.Layer | Iterable[_l.Layer] | None = None,\n) -&gt; _L:\n    \"\"\"Add a layer to the canvas.\"\"\"\n    if over is None and under is None:\n        self.layers.append(layer)\n    elif over is not None:\n        if under is not None:\n            raise ValueError(\"Cannot specify both `over` and `under`\")\n        if isinstance(over, _l.Layer):\n            idx = self.layers.index(over)\n        else:\n            idx = max([self.layers.index(l) for l in over])\n        self.layers.insert(idx + 1, layer)\n    else:\n        if isinstance(under, _l.Layer):\n            idx = self.layers.index(under)\n        else:\n            idx = min([self.layers.index(l) for l in under])\n        self.layers.insert(idx, layer)\n    return layer\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_legend","title":"<code>add_legend(layers=None, *, location='top_right', title=None)</code>","text":"<p>Add legend item to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>sequence of layer or str</code> <p>Which item to be added to the legend. If str is given, it will be converted into a title label.</p> <code>None</code> <code>location</code> <code>LegendLocation</code> <p>Location of the legend. Can be following strings. Combination of the following strings (e.g., \"top_left\", \"center_right\").</p> <pre><code>       (2) left  center right\n             v     v     v\n  (1)     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   top -&gt; \u2502                 \u2502\ncenter -&gt; \u2502     canvas      \u2502\nbottom -&gt; \u2502                 \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Some backends also support adding legend outside the canvas. Following strings suffixed with \"_side\" can be used in combination with those strings above (e.g., \"bottom_side_rigth\", \"right_side_top\").</p> <pre><code>   top_side -&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u250c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2510\nleft_side -&gt;\u2502  \u2502 canvas \u2502  \u2502&lt;- right_side\n            \u2514\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2518\nbottom_side -&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <code>\"top_right\"</code> <code>title</code> <code>str</code> <p>If given, title label will be added as the first legend item.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_legend(\n    self,\n    layers: Sequence[str | _l.Layer] | None = None,\n    *,\n    location: Location | LocationStr = \"top_right\",\n    title: str | None = None,\n):\n    \"\"\"\n    Add legend item to the canvas.\n\n    Parameters\n    ----------\n    layers : sequence of layer or str, optional\n        Which item to be added to the legend. If str is given, it will be converted\n        into a title label.\n    location : LegendLocation, default \"top_right\"\n        Location of the legend. Can be following strings. Combination of the\n        following strings (e.g., \"top_left\", \"center_right\").\n\n        ```\n               (2) left  center right\n                     v     v     v\n          (1)     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           top -&gt; \u2502                 \u2502\n        center -&gt; \u2502     canvas      \u2502\n        bottom -&gt; \u2502                 \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        ```\n\n        Some backends also support adding legend outside the canvas. Following\n        strings suffixed with \"_side\" can be used in combination with those strings\n        above (e.g., \"bottom_side_rigth\", \"right_side_top\").\n\n        ```\n           top_side -&gt; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u250c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2510\n        left_side -&gt;\u2502  \u2502 canvas \u2502  \u2502&lt;- right_side\n                    \u2514\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2518\n        bottom_side -&gt; \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        ```\n    title : str, optional\n        If given, title label will be added as the first legend item.\n    \"\"\"\n    if layers is None:\n        layers = list(self.layers)\n    if title is not None:\n        layers = [title, *layers]\n    location = Location(location)\n\n    items = list[tuple[str, _legend.LegendItem]]()\n    for layer in layers:\n        if isinstance(layer, str):\n            items.append((layer, _legend.TitleItem()))\n        elif isinstance(layer, _l.Layer):\n            items.append((layer.name, layer._as_legend_item()))\n        else:\n            raise TypeError(f\"Expected a list of layer or str, got {type(layer)}.\")\n    self._canvas()._plt_make_legend(items, location)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_line","title":"<code>add_line(*args, name=None, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add a Line layer to the canvas.</p> <p>canvas.add_line(y, ...) canvas.add_line(x, y, ...)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>Line</code> <p>The line layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_line(\n    self,\n    *args,\n    name=None,\n    color=None,\n    width=None,\n    style=None,\n    alpha=1.0,\n    antialias=True,\n):\n    \"\"\"\n    Add a Line layer to the canvas.\n\n    &gt;&gt;&gt; canvas.add_line(y, ...)\n    &gt;&gt;&gt; canvas.add_line(x, y, ...)\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    Line\n        The line layer.\n    \"\"\"\n    xdata, ydata = normalize_xy(*args)\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.Line(\n        xdata, ydata, name=name, color=color, width=width, style=style,\n        alpha=alpha, antialias=antialias, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_markers","title":"<code>add_markers(*args, name=None, symbol=None, size=None, color=None, alpha=1.0, hatch=None)</code>","text":"<p>Add markers (scatter plot).</p> <p>canvas.add_markers(x, y)  # standard usage canvas.add_markers(y)  # use 0, 1, ... for the x values</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>symbol</code> <code>str or Symbol</code> <p>Marker symbols. Use the theme default if not specified.</p> <code>None</code> <code>size</code> <code>float</code> <p>Marker size. Use the theme default if not specified.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the marker faces.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the marker faces.</p> <code>1.0</code> <code>hatch</code> <code>str or FacePattern</code> <p>Pattern of the marker faces. Use the theme default if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>Markers</code> <p>The markers layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_markers(\n    self,\n    *args,\n    name=None,\n    symbol=None,\n    size=None,\n    color=None,\n    alpha=1.0,\n    hatch=None,\n):\n    \"\"\"\n    Add markers (scatter plot).\n\n    &gt;&gt;&gt; canvas.add_markers(x, y)  # standard usage\n    &gt;&gt;&gt; canvas.add_markers(y)  # use 0, 1, ... for the x values\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the layer.\n    symbol : str or Symbol, optional\n        Marker symbols. Use the theme default if not specified.\n    size : float, optional\n        Marker size. Use the theme default if not specified.\n    color : color-like, optional\n        Color of the marker faces.\n    alpha : float, default 1.0\n        Alpha channel of the marker faces.\n    hatch : str or FacePattern, optional\n        Pattern of the marker faces. Use the theme default if not specified.\n\n    Returns\n    -------\n    Markers\n        The markers layer.\n    \"\"\"\n    xdata, ydata = normalize_xy(*args)\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    symbol = theme._default(\"markers.symbol\", symbol)\n    size = theme._default(\"markers.size\", size)\n    hatch = theme._default(\"markers.hatch\", hatch)\n    layer = _l.Markers(\n        xdata, ydata, name=name, symbol=symbol, size=size, color=color,\n        alpha=alpha, hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_rug","title":"<code>add_rug(events, *, low=0.0, high=1.0, name=None, orient='vertical', color='black', width=1.0, style=LineStyle.SOLID, antialias=True, alpha=1.0)</code>","text":"<p>Add input data as a rug plot.</p> <p>canvas.add_rug([2, 4, 5, 8, 11])</p> <pre><code>  \u2502 \u2502\u2502  \u2502   \u2502\n\u2500\u2500\u2534\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500&gt; x\n  2 45  8   11\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>array - like</code> <p>A 1D array of events.</p> required <code>low</code> <code>float</code> <p>The lower bound of the rug lines.</p> <code>0.0</code> <code>high</code> <code>float</code> <p>The upper bound of the rug lines.</p> <code>1.0</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the errorbars. If vertical, rug lines will be parallel to the y axis.</p> <code>\"vertical\"</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>'black'</code> <code>width</code> <code>float</code> <p>Line width.</p> <code>1.0</code> <code>style</code> <code>str or LineStyle</code> <p>Line style.</p> <code>LineStyle.SOLID</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>Rug</code> <p>The rug layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_rug(\n    self,\n    events: ArrayLike1D,\n    *,\n    low: float = 0.0,\n    high: float = 1.0,\n    name: str | None = None,\n    orient: OrientationLike = \"vertical\",\n    color: ColorType = \"black\",\n    width: float = 1.0,\n    style: LineStyle | str = LineStyle.SOLID,\n    antialias: bool = True,\n    alpha: float = 1.0,\n) -&gt; _l.Rug:\n    \"\"\"\n    Add input data as a rug plot.\n\n    &gt;&gt;&gt; canvas.add_rug([2, 4, 5, 8, 11])\n\n    ```\n      \u2502 \u2502\u2502  \u2502   \u2502\n    \u2500\u2500\u2534\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500&gt; x\n      2 45  8   11\n    ```\n\n    Parameters\n    ----------\n    events : array-like\n        A 1D array of events.\n    low : float, default 0.0\n        The lower bound of the rug lines.\n    high : float, default 1.0\n        The upper bound of the rug lines.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default \"vertical\"\n        Orientation of the errorbars. If vertical, rug lines will be parallel\n        to the y axis.\n    color : color-like, optional\n        Color of the bars.\n    width : float, default 1.0\n        Line width.\n    style : str or LineStyle, default LineStyle.SOLID\n        Line style.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    Rug\n        The rug layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    layer = _l.Rug(\n        events, low=low, high=high, name=name, color=color, alpha=alpha,\n        width=width, style=style, antialias=antialias, orient=orient,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_spans","title":"<code>add_spans(spans, *, name=None, orient='vertical', color='blue', alpha=0.4, hatch=Hatch.SOLID)</code>","text":"<p>Add spans that extends infinitely.</p> <p>canvas.add_spans([[5, 10], [15, 20]])</p> :::: :::: \u2500\u2500\u25005\u2500\u2500\u2500\u250010\u2500\u2500\u2500\u250015\u2500\u2500\u250020\u2500\u2500\u2500\u2500\u2500&gt; :::: :::: :::: :::: <p>Parameters:</p> Name Type Description Default <code>spans</code> <code>(N, 2) array-like</code> <p>Array that contains the start and end points of the spans.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>\"vertical\"</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>'blue'</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the bars.</p> <code>0.4</code> <code>hatch</code> <code>str or FacePattern</code> <p>Pattern of the bar faces.</p> <code>FacePattern.SOLID</code> <p>Returns:</p> Type Description <code>Spans</code> <p>The spans layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_spans(\n    self,\n    spans: ArrayLike,\n    *,\n    name: str | None = None,\n    orient: OrientationLike = \"vertical\",\n    color: ColorType = \"blue\",\n    alpha: float = 0.4,\n    hatch: str | Hatch = Hatch.SOLID,\n) -&gt; _l.Spans:\n    \"\"\"\n    Add spans that extends infinitely.\n\n    &gt;&gt;&gt; canvas.add_spans([[5, 10], [15, 20]])\n\n       |::::|     |::::|\n       |::::|     |::::|\n    \u2500\u2500\u25005\u2500\u2500\u2500\u250010\u2500\u2500\u2500\u250015\u2500\u2500\u250020\u2500\u2500\u2500\u2500\u2500&gt;\n       |::::|     |::::|\n       |::::|     |::::|\n\n    Parameters\n    ----------\n    spans : (N, 2) array-like\n        Array that contains the start and end points of the spans.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default \"vertical\"\n        Orientation of the bars.\n    color : color-like, optional\n        Color of the bars.\n    alpha : float, default 0.4\n        Alpha channel of the bars.\n    hatch : str or FacePattern, default FacePattern.SOLID\n        Pattern of the bar faces.\n\n    Returns\n    -------\n    Spans\n        The spans layer.\n    \"\"\"\n    name = self._coerce_name(name)\n    color = self._generate_colors(color)\n    layer = _l.Spans(\n        spans, name=name, orient=orient, color=color, alpha=alpha,\n        hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_text","title":"<code>add_text(x, y, string, *, color='black', size=12, rotation=0.0, anchor=Alignment.BOTTOM_LEFT, family=None)</code>","text":"<p>Add a text layer to the canvas.</p> <p>canvas.add_text([0, 0], [1, 1], [\"text-0\", \"text-1]) canvas.add_text(...).with_face(color=\"red\")  # with background canvas.add_text(...).with_edge(color=\"red\")  # with outline</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or array - like</code> <p>X position(s) of the text.</p> required <code>y</code> <code>float or array - like</code> <p>Y position(s) of the text.</p> required <code>string</code> <code>str or list[str]</code> <p>Text string to display.</p> required <code>color</code> <code>ColorType</code> <p>Color of the text string.</p> <code>'black'</code> <code>size</code> <code>float</code> <p>Point size of the text.</p> <code>12</code> <code>rotation</code> <code>float</code> <p>Rotation angle of the text in degrees.</p> <code>0.0</code> <code>anchor</code> <code>str or Alignment</code> <p>Anchor position of the text. The anchor position will be the coordinate given by (x, y).</p> <code>Alignment.BOTTOM_LEFT</code> <code>family</code> <code>str</code> <p>Font family of the text.</p> <code>None</code> <p>Returns:</p> Type Description <code>Texts</code> <p>The text layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_text(\n    self,\n    x,\n    y,\n    string,\n    *,\n    color=\"black\",\n    size=12,\n    rotation=0.0,\n    anchor=Alignment.BOTTOM_LEFT,\n    family=None,\n):\n    \"\"\"\n    Add a text layer to the canvas.\n\n    &gt;&gt;&gt; canvas.add_text([0, 0], [1, 1], [\"text-0\", \"text-1])\n    &gt;&gt;&gt; canvas.add_text(...).with_face(color=\"red\")  # with background\n    &gt;&gt;&gt; canvas.add_text(...).with_edge(color=\"red\")  # with outline\n\n    Parameters\n    ----------\n    x : float or array-like\n        X position(s) of the text.\n    y : float or array-like\n        Y position(s) of the text.\n    string : str or list[str]\n        Text string to display.\n    color : ColorType, optional\n        Color of the text string.\n    size : float, default 12\n        Point size of the text.\n    rotation : float, default 0.0\n        Rotation angle of the text in degrees.\n    anchor : str or Alignment, default Alignment.BOTTOM_LEFT\n        Anchor position of the text. The anchor position will be the coordinate\n        given by (x, y).\n    family : str, optional\n        Font family of the text.\n\n    Returns\n    -------\n    Texts\n        The text layer.\n    \"\"\"\n    if is_real_number(x) and is_real_number(y) and isinstance(string, str):\n        x, y, string = [x], [y], [string]\n    x_, y_ = normalize_xy(x, y)\n    if isinstance(string, str):\n        string = [string] * x_.size\n    elif len(string) != x_.size:\n        raise ValueError(\"Expected string to have the same size as x/y\")\n    layer = _l.Texts(\n        x_, y_, string, color=color, size=size, rotation=rotation, anchor=anchor,\n        family=family, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_vline","title":"<code>add_vline(x, *, name=None, color=None, width=None, style=LineStyle.SOLID, alpha=1.0, antialias=True)</code>","text":"<p>Add a infinite vertical line to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate of the line.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>SOLID</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfLine</code> <p>The infline layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_vline(\n    self,\n    x: float,\n    *,\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str = LineStyle.SOLID,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfLine:\n    \"\"\"\n    Add a infinite vertical line to the canvas.\n\n    Parameters\n    ----------\n    x : float\n        X coordinate of the line.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfLine\n        The infline layer.\n    \"\"\"\n    return self.add_infline(\n        (x, 0), 90, name=name, color=color, width=width, style=style, alpha=alpha,\n        antialias=antialias,\n    )  # fmt: skip\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.autoscale","title":"<code>autoscale(xpad=None, ypad=None)</code>","text":"<p>Autoscale the canvas to fit the contents.</p> <p>Parameters:</p> Name Type Description Default <code>xpad</code> <code>float or (float, float)</code> <p>Padding in the x direction.</p> <code>None</code> <code>ypad</code> <code>float or (float, float)</code> <p>Padding in the y direction.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def autoscale(\n    self,\n    xpad: float | tuple[float, float] | None = None,\n    ypad: float | tuple[float, float] | None = None,\n) -&gt; tuple[float, float, float, float]:\n    \"\"\"\n    Autoscale the canvas to fit the contents.\n\n    Parameters\n    ----------\n    xpad : float or (float, float), optional\n        Padding in the x direction.\n    ypad : float or (float, float), optional\n        Padding in the y direction.\n    \"\"\"\n    ar = np.stack([layer.bbox_hint() for layer in self.layers], axis=0)\n    xmin = np.min(ar[:, 0])\n    xmax = np.max(ar[:, 1])\n    ymin = np.min(ar[:, 2])\n    ymax = np.max(ar[:, 3])\n    x0, x1 = self.x.lim\n    y0, y1 = self.y.lim\n    if np.isnan(xmin):\n        xmin = x0\n    if np.isnan(xmax):\n        xmax = x1\n    if np.isnan(ymin):\n        ymin = y0\n    if np.isnan(ymax):\n        ymax = y1\n    if xpad is not None:\n        xrange = xmax - xmin\n        if is_real_number(xpad):\n            dx0 = dx1 = xpad * xrange\n        else:\n            dx0, dx1 = xpad[0] * xrange, xpad[1] * xrange\n        xmin -= dx0\n        xmax += dx1\n    if ypad is not None:\n        yrange = ymax - ymin\n        if is_real_number(ypad):\n            dy0 = dy1 = ypad * yrange\n        else:\n            dy0, dy1 = ypad[0] * yrange, ypad[1] * yrange\n        ymin -= dy0\n        ymax += dy1\n    small_diff = 1e-6\n    if xmax - xmin &lt; small_diff:\n        xmin -= 0.05\n        xmax += 0.05\n    if ymax - ymin &lt; small_diff:\n        ymin -= 0.05\n        ymax += 0.05\n    self.x.lim = xmin, xmax\n    self.y.lim = ymin, ymax\n    return xmin, xmax, ymin, ymax\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.autoscale_context","title":"<code>autoscale_context(enabled)</code>","text":"<p>Context manager to temporarily change the autoscale state.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>@contextmanager\ndef autoscale_context(self, enabled: bool):\n    \"\"\"Context manager to temporarily change the autoscale state.\"\"\"\n    _was_enabled = self.autoscale_enabled\n    self.autoscale_enabled = enabled\n    try:\n        yield\n    finally:\n        self.autoscale_enabled = _was_enabled\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat","title":"<code>cat(data, x=None, y=None, *, update_labels=True)</code>","text":"<p>Categorize input data for plotting.</p> <p>This method provides categorical plotting methods for the input data. Methods are very similar to <code>seaborn</code> and <code>plotly.express</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str</code> <p>Name of the column that will be used for the x-axis. Must be numerical.</p> <code>None</code> <code>y</code> <code>str</code> <p>Name of the column that will be used for the y-axis. Must be numerical.</p> <code>None</code> <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <p>Returns:</p> Type Description <code>CatPlotter</code> <p>Plotter object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat(\n    self,\n    data: _DF,\n    x: str | None = None,\n    y: str | None = None,\n    *,\n    update_labels: bool = True,\n) -&gt; _df.CatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting.\n\n    This method provides categorical plotting methods for the input data.\n    Methods are very similar to `seaborn` and `plotly.express`.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str, optional\n        Name of the column that will be used for the x-axis. Must be numerical.\n    y : str, optional\n        Name of the column that will be used for the y-axis. Must be numerical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n\n    Returns\n    -------\n    CatPlotter\n        Plotter object.\n    \"\"\"\n    plotter = _df.CatPlotter(self, data, x, y, update_labels=update_labels)\n    return plotter\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat_x","title":"<code>cat_x(data, x=None, y=None, *, update_labels=True, numeric_axis=False)</code>","text":"<p>Categorize input data for plotting with x-axis as a categorical axis.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the x-axis. Must be categorical.</p> <code>None</code> <code>y</code> <code>str</code> <p>Name of the column that will be used for the y-axis. Must be numerical.</p> <code>None</code> <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <code>numeric_axis</code> <code>bool</code> <p>If True, the x-axis will be treated as a numerical axis. For example, if categories are [2, 4, 8], the x coordinates will be mapped to [0, 1, 2] by default, but if this option is True, the x coordinates will be [2, 4, 8].</p> <code>False</code> <p>Returns:</p> Type Description <code>XCatPlotter</code> <p>Plotter object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat_x(\n    self,\n    data: _DF,\n    x: str | Sequence[str] | None = None,\n    y: str | None = None,\n    *,\n    update_labels: bool = True,\n    numeric_axis: bool = False,\n) -&gt; _df.XCatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting with x-axis as a categorical axis.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str or sequence of str, optional\n        Name of the column(s) that will be used for the x-axis. Must be categorical.\n    y : str, optional\n        Name of the column that will be used for the y-axis. Must be numerical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n    numeric_axis : bool, default False\n        If True, the x-axis will be treated as a numerical axis. For example, if\n        categories are [2, 4, 8], the x coordinates will be mapped to [0, 1, 2] by\n        default, but if this option is True, the x coordinates will be [2, 4, 8].\n\n    Returns\n    -------\n    XCatPlotter\n        Plotter object.\n    \"\"\"\n    return _df.XCatPlotter(self, data, x, y, update_labels, numeric=numeric_axis)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat_xy","title":"<code>cat_xy(data, x, y, *, update_labels=True)</code>","text":"<p>Categorize input data for plotting with both axes as categorical.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the x-axis. Must be categorical.</p> required <code>y</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the y-axis. Must be categorical.</p> required <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <p>Returns:</p> Type Description <code>XYCatPlotter</code> <p>Plotter object</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat_xy(\n    self,\n    data: _DF,\n    x: str | Sequence[str],\n    y: str | Sequence[str],\n    *,\n    update_labels: bool = True,\n) -&gt; _df.XYCatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting with both axes as categorical.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str or sequence of str, optional\n        Name of the column(s) that will be used for the x-axis. Must be categorical.\n    y : str or sequence of str, optional\n        Name of the column(s) that will be used for the y-axis. Must be categorical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n\n    Returns\n    -------\n    XYCatPlotter\n        Plotter object\n    \"\"\"\n    return _df.XYCatPlotter(self, data, x, y, update_labels)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat_y","title":"<code>cat_y(data, x=None, y=None, *, update_labels=True, numeric_axis=False)</code>","text":"<p>Categorize input data for plotting with y-axis as a categorical axis.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str</code> <p>Name of the column that will be used for the x-axis. Must be numerical.</p> <code>None</code> <code>y</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the y-axis. Must be categorical.</p> <code>None</code> <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <code>numeric_axis</code> <code>bool</code> <p>If True, the x-axis will be treated as a numerical axis. For example, if categories are [2, 4, 8], the y coordinates will be mapped to [0, 1, 2] by default, but if this option is True, the y coordinates will be [2, 4, 8].</p> <code>False</code> <p>Returns:</p> Type Description <code>YCatPlotter</code> <p>Plotter object</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat_y(\n    self,\n    data: _DF,\n    x: str | None = None,\n    y: str | Sequence[str] | None = None,\n    *,\n    update_labels: bool = True,\n    numeric_axis: bool = False,\n) -&gt; _df.YCatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting with y-axis as a categorical axis.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str, optional\n        Name of the column that will be used for the x-axis. Must be numerical.\n    y : str or sequence of str, optional\n        Name of the column(s) that will be used for the y-axis. Must be categorical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n    numeric_axis : bool, default False\n        If True, the x-axis will be treated as a numerical axis. For example, if\n        categories are [2, 4, 8], the y coordinates will be mapped to [0, 1, 2] by\n        default, but if this option is True, the y coordinates will be [2, 4, 8].\n\n    Returns\n    -------\n    YCatPlotter\n        Plotter object\n    \"\"\"\n    return _df.YCatPlotter(self, data, y, x, update_labels, numeric=numeric_axis)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.fit","title":"<code>fit(layer)</code>","text":"<p>The fit plotter namespace.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def fit(self, layer: _l.DataBoundLayer[_P]) -&gt; FitPlotter[Self, _P]:\n    \"\"\"The fit plotter namespace.\"\"\"\n    return FitPlotter(self, layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.group_layers","title":"<code>group_layers(layers, *more_layers, name=None)</code>","text":"<p>Group layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>iterable of Layer</code> <p>Layers to group.</p> required <p>Returns:</p> Type Description <code>LayerGroup</code> <p>The grouped layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def group_layers(self, layers, *more_layers, name=None):\n    \"\"\"\n    Group layers.\n\n    Parameters\n    ----------\n    layers : iterable of Layer\n        Layers to group.\n\n    Returns\n    -------\n    LayerGroup\n        The grouped layer.\n    \"\"\"\n    if more_layers:\n        if not isinstance(layers, _l.Layer):\n            raise TypeError(\"No overload matches the arguments\")\n        layers = [layers, *more_layers]\n    return _lg.LayerTuple(layers, name=name)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.imref","title":"<code>imref(layer)</code>","text":"<p>The Image reference namespace.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>@deprecated(\n    \"ImageRef is deprecated and will be removed in the future. \"\n    \"Please use the Image methods `with_text`, `with_colorbar` instead.\",\n)\ndef imref(self, layer: _l.Image):\n    \"\"\"The Image reference namespace.\"\"\"\n    from whitecanvas.canvas._imageref import ImageRef\n\n    while isinstance(layer, _l.LayerWrapper):\n        layer = layer._base_layer\n    if not isinstance(layer, _l.Image):\n        raise TypeError(\n            f\"Expected an Image layer or its wrapper, got {type(layer)}.\"\n        )\n    return ImageRef(self, layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.install_inset","title":"<code>install_inset(*args, palette=None, **kwargs)</code>","text":"<p>Install a new canvas pointing to an inset of the current canvas.</p> <p>canvas.install_inset(left=0.1, right=0.9, bottom=0.1, top=0.9) canvas.install_inset([0.1, 0.9, 0.1, 0.9])  # or a sequence</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def install_inset(self, *args, palette=None, **kwargs) -&gt; Canvas:\n    \"\"\"\n    Install a new canvas pointing to an inset of the current canvas.\n\n    &gt;&gt;&gt; canvas.install_inset(left=0.1, right=0.9, bottom=0.1, top=0.9)\n    &gt;&gt;&gt; canvas.install_inset([0.1, 0.9, 0.1, 0.9])  # or a sequence\n    \"\"\"\n    # normalize input\n    if len(args) == 1 and not kwargs:\n        rect = args[0]\n        if not isinstance(rect, Rect):\n            rect = Rect.with_check(*rect)\n    else:\n        rect = Rect.with_check(*args, **kwargs)\n    try:\n        new = self._canvas()._plt_inset(rect)\n    except AttributeError:\n        raise NotImplementedError(\n            f\"Backend {self._get_backend()} does not support `install_inset`\"\n        ) from None\n    canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n    canvas._init_canvas()\n    return canvas\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.install_second_x","title":"<code>install_second_x(*, palette=None)</code>","text":"<p>Create a twin canvas that has a secondary x-axis and shared y-axis.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def install_second_x(self, *, palette: ColormapType | None = None) -&gt; Canvas:\n    \"\"\"Create a twin canvas that has a secondary x-axis and shared y-axis.\"\"\"\n    try:\n        new = self._canvas()._plt_twiny()\n    except AttributeError:\n        raise NotImplementedError(\n            f\"Backend {self._get_backend()} does not support `install_second_x`.\"\n        ) from None\n    canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n    canvas._init_canvas()\n    return canvas\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.install_second_y","title":"<code>install_second_y(*, palette=None)</code>","text":"<p>Create a twin canvas that has a secondary y-axis and shared x-axis.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def install_second_y(self, *, palette: ColormapType | None = None) -&gt; Canvas:\n    \"\"\"Create a twin canvas that has a secondary y-axis and shared x-axis.\"\"\"\n    try:\n        new = self._canvas()._plt_twinx()\n    except AttributeError:\n        raise NotImplementedError(\n            f\"Backend {self._get_backend()} does not support `install_second_y`.\"\n        ) from None\n    canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n    canvas._init_canvas()\n    return canvas\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.stack_over","title":"<code>stack_over(layer)</code>","text":"<p>Stack new data over the existing layer.</p> <p>For example following code</p> <p>bars_0 = canvas.add_bars(x, y0) bars_1 = canvas.stack_over(bars_0).add(y1) bars_2 = canvas.stack_over(bars_1).add(y2)</p> <p>will result in a bar plot like this</p> <pre><code> \u250c\u2500\u2500\u2500\u2510\n \u251c\u2500\u2500\u2500\u2502\u250c\u2500\u2500\u2500\u2510\n \u2502   \u2502\u251c\u2500\u2500\u2500\u2502\n \u251c\u2500\u2500\u2500\u2502\u251c\u2500\u2500\u2500\u2502\n\u2500\u2534\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\n</code></pre> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def stack_over(self, layer: _L0) -&gt; StackOverPlotter[Self, _L0]:\n    \"\"\"\n    Stack new data over the existing layer.\n\n    For example following code\n\n    &gt;&gt;&gt; bars_0 = canvas.add_bars(x, y0)\n    &gt;&gt;&gt; bars_1 = canvas.stack_over(bars_0).add(y1)\n    &gt;&gt;&gt; bars_2 = canvas.stack_over(bars_1).add(y2)\n\n    will result in a bar plot like this\n\n    ```\n     \u250c\u2500\u2500\u2500\u2510\n     \u251c\u2500\u2500\u2500\u2502\u250c\u2500\u2500\u2500\u2510\n     \u2502   \u2502\u251c\u2500\u2500\u2500\u2502\n     \u251c\u2500\u2500\u2500\u2502\u251c\u2500\u2500\u2500\u2502\n    \u2500\u2534\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\n    ```\n    \"\"\"\n    if not isinstance(layer, (_l.Bars, _l.Band, _lg.StemPlot, _lg.LabeledBars)):\n        raise TypeError(\n            f\"Only Bars, StemPlot and Band are supported as an input, \"\n            f\"got {type(layer)!r}.\"\n        )\n    return StackOverPlotter(self, layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.update_axes","title":"<code>update_axes(*, visible=_void, color=_void)</code>","text":"<p>Update axes appearance.</p> <p>Parameters:</p> Name Type Description Default <code>visible</code> <code>bool</code> <p>Whether to show the axes.</p> <code>_void</code> <code>color</code> <code>color - like</code> <p>Color of the axes.</p> <code>_void</code> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def update_axes(\n    self,\n    *,\n    visible: bool = _void,\n    color: ColorType | None = _void,\n):\n    \"\"\"\n    Update axes appearance.\n\n    Parameters\n    ----------\n    visible : bool, optional\n        Whether to show the axes.\n    color : color-like, optional\n        Color of the axes.\n    \"\"\"\n    if visible is not _void:\n        self.x.ticks.visible = visible\n        self.y.ticks.visible = visible\n    if color is not _void:\n        self.x.color = color\n        self.x.ticks.color = color\n        self.x.label.color = color\n        self.y.color = color\n        self.y.ticks.color = color\n        self.y.label.color = color\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.update_font","title":"<code>update_font(size=_void, color=_void, family=_void)</code>","text":"<p>Update all the fonts, including the title, x/y labels and x/y tick labels.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>New font size.</p> <code>_void</code> <code>color</code> <code>color - like</code> <p>New font color.</p> <code>_void</code> <code>family</code> <code>str</code> <p>New font family.</p> <code>_void</code> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def update_font(\n    self,\n    size: float | _Void = _void,\n    color: ColorType | _Void = _void,\n    family: str | _Void = _void,\n) -&gt; Self:\n    \"\"\"\n    Update all the fonts, including the title, x/y labels and x/y tick labels.\n\n    Parameters\n    ----------\n    size : float, optional\n        New font size.\n    color : color-like, optional\n        New font color.\n    family : str, optional\n        New font family.\n    \"\"\"\n    if size is not _void:\n        self.title.size = self.x.label.size = self.y.label.size = size\n        self.x.ticks.size = self.y.ticks.size = size\n    if family is not _void:\n        self.title.family = self.x.label.family = self.y.label.family = family\n        self.x.ticks.family = self.y.ticks.family = family\n    if color is not _void:\n        self.title.color = self.x.label.color = self.y.label.color = color\n        self.x.ticks.color = self.y.ticks.color = color\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.update_labels","title":"<code>update_labels(title=None, x=None, y=None)</code>","text":"<p>Helper function to update the title, x, and y labels.</p> <p>from whitecanvas import new_canvas canvas = new_canvas(\"matplotlib\").update_labels(\"Title\", \"X\", \"Y\")</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def update_labels(\n    self,\n    title: str | None = None,\n    x: str | None = None,\n    y: str | None = None,\n) -&gt; Self:\n    \"\"\"\n    Helper function to update the title, x, and y labels.\n\n    &gt;&gt;&gt; from whitecanvas import new_canvas\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib\").update_labels(\"Title\", \"X\", \"Y\")\n    \"\"\"\n    if title is not None:\n        self.title.text = title\n        self.title.visible = True\n    if x is not None:\n        self.x.label.text = x\n        self.x.label.visible = True\n    if y is not None:\n        self.y.label.text = y\n        self.y.label.visible = True\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid","title":"<code>CanvasGrid</code>","text":"Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>class CanvasGrid:\n    _CURRENT_INSTANCE: CanvasGrid | None = None\n    events: GridEvents\n\n    def __init__(\n        self,\n        heights: list[int],\n        widths: list[int],\n        *,\n        backend: Backend | str | None = None,\n    ) -&gt; None:\n        self._heights = heights\n        self._widths = widths\n        self._backend = Backend(backend)\n        self._backend_object = self._create_backend()\n        self._canvas_array = np.empty((len(heights), len(widths)), dtype=object)\n        self._canvas_array.fill(None)\n\n        # link axes\n        self._x_linked = False\n        self._y_linked = False\n        self._x_linker_ref = None\n        self._y_linker_ref = None\n\n        # update settings\n        theme = get_theme()\n        self.background_color = theme.background_color\n        self.size = theme.canvas_size\n        self.events = GridEvents()\n        self.__class__._CURRENT_INSTANCE = self\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        \"\"\"The (row, col) shape of the grid\"\"\"\n        return self._canvas_array.shape\n\n    def link_x(self, *, future: bool = True, hide_ticks: bool = True) -&gt; Self:\n        \"\"\"\n        Link all the x-axes of the canvases in the grid.\n\n        &gt;&gt;&gt; from whitecanvas import new_grid\n        &gt;&gt;&gt; g = new_grid(2, 2).link_x()  # link x-axes of all canvases\n\n        Parameters\n        ----------\n        future : bool, default True\n            If Ture, all the canvases added in the future will also be linked. Only link\n            the existing canvases if False.\n        \"\"\"\n        if self._x_linker_ref is not None:\n            self._x_linker_ref.unlink_all()  # initialize linker\n        to_link = []\n        for (_r, _), _canvas in self._iter_canvas():\n            to_link.append(_canvas.x)\n            if hide_ticks and _r != self.shape[0] - 1:\n                _canvas.x.ticks.visible = False\n        self._x_linker_ref = link_axes(to_link)\n        if future:\n            self._x_linked = True\n            if hide_ticks:\n                self._backend_object._plt_set_spacings(6, 6)\n        return self\n\n    def link_y(self, *, future: bool = True, hide_ticks: bool = True) -&gt; Self:\n        \"\"\"\n        Link all the y-axes of the canvases in the grid.\n\n        &gt;&gt;&gt; from whitecanvas import new_grid\n        &gt;&gt;&gt; g = new_grid(2, 2).link_y()  # link y-axes of all canvases\n\n        Parameters\n        ----------\n        future : bool, default True\n            If Ture, all the canvases added in the future will also be linked. Only link\n            the existing canvases if False.\n        \"\"\"\n        if self._y_linker_ref is not None:\n            self._y_linker_ref.unlink_all()\n        to_link = []\n        for (_, _c), _canvas in self._iter_canvas():\n            to_link.append(_canvas.y)\n            if hide_ticks and _c != 0:\n                _canvas.y.ticks.visible = False\n        self._y_linker_ref = link_axes(to_link)\n        if future:\n            self._y_linked = True\n            if hide_ticks:\n                self._backend_object._plt_set_spacings(6, 6)\n        return self\n\n    def __repr__(self) -&gt; str:\n        cname = type(self).__name__\n        w, h = self._size\n        hex_id = hex(id(self))\n        return f\"&lt;{cname} ({w:.1f} x {h:.1f}) at {hex_id}&gt;\"\n\n    def __getitem__(self, key: tuple[int, int]) -&gt; Canvas:\n        canvas = self._canvas_array[key]\n        if canvas is None:\n            raise ValueError(f\"Canvas at {key} is not set\")\n        elif isinstance(canvas, np.ndarray):\n            raise ValueError(f\"Cannot index by {key}.\")\n        return canvas\n\n    def _create_backend(self) -&gt; protocols.CanvasGridProtocol:\n        return self._backend.get(\"CanvasGrid\")(\n            self._heights, self._widths, self._backend._app\n        )\n\n    def fill(self, palette: ColormapType | None = None) -&gt; Self:\n        \"\"\"Fill the grid with canvases.\"\"\"\n        for _ in self._iter_add_canvas(palette=palette):\n            pass\n        return self\n\n    def add_canvas(\n        self,\n        row: int,\n        col: int,\n        rowspan: int = 1,\n        colspan: int = 1,\n        *,\n        palette: str | None = None,\n    ) -&gt; Canvas:\n        \"\"\"Add a canvas to the grid at the given position\"\"\"\n        for idx, item in np.ndenumerate(self._canvas_array[row, col]):\n            if item is not None:\n                raise ValueError(f\"Canvas already exists at {idx}\")\n        backend_canvas = self._backend_object._plt_add_canvas(\n            row, col, rowspan, colspan\n        )\n        canvas = self._canvas_array[row, col] = Canvas.from_backend(\n            backend_canvas,\n            backend=self._backend,\n            palette=palette,\n        )\n        # Now backend axes/viewbox are created, we can install mouse events\n        canvas._install_mouse_events()\n\n        # link axes if needed\n        if self._x_linked:\n            self._x_linker_ref.link(canvas.x)\n        if self._y_linked:\n            self._y_linker_ref.link(canvas.y)\n        canvas.events.drawn.connect(self.events.drawn.emit, unique=True, max_args=None)\n        return canvas\n\n    def _iter_add_canvas(self, **kwargs) -&gt; Iterator[Canvas]:\n        for row in range(len(self._heights)):\n            for col in range(len(self._widths)):\n                yield self.add_canvas(row, col, **kwargs)\n\n    def _iter_canvas(self) -&gt; Iterator[tuple[tuple[int, int], Canvas]]:\n        yielded: set[int] = set()\n        for idx, canvas in np.ndenumerate(self._canvas_array):\n            _id = id(canvas)\n            if canvas is None or _id in yielded:\n                continue\n            yield idx, canvas\n            yielded.add(_id)\n\n    def show(self, block=False) -&gt; None:\n        \"\"\"Show the grid.\"\"\"\n        from whitecanvas.backend._app import get_app\n\n        # TODO: implement other event loops\n        app = get_app(self._backend._app)\n        _backend_app = app.get_app()\n        out = self._backend_object._plt_show()\n\n        if out is NotImplemented:\n            from whitecanvas.backend._window import view\n\n            view(self, self._backend.app)\n\n        if block:\n            # TODO: automatically block the event loop or enable ipython\n            # GUI mode if needed.\n            app.run_app()\n\n    @property\n    def background_color(self) -&gt; NDArray[np.floating]:\n        \"\"\"Background color of the canvas.\"\"\"\n        return arr_color(self._backend_object._plt_get_background_color())\n\n    @background_color.setter\n    def background_color(self, color):\n        self._backend_object._plt_set_background_color(arr_color(color))\n\n    def screenshot(self) -&gt; NDArray[np.uint8]:\n        \"\"\"Return a screenshot of the grid.\"\"\"\n        return self._backend_object._plt_screenshot()\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        \"\"\"Size in width x height.\"\"\"\n        return self._size\n\n    @size.setter\n    def size(self, size: tuple[int, int]):\n        w, h = size\n        if w &lt;= 0 or h &lt;= 0:\n            raise ValueError(\"Size must be positive\")\n        self._size = (int(w), int(h))\n        self._backend_object._plt_set_figsize(*self._size)\n\n    def _repr_png_(self):\n        \"\"\"Return PNG representation of the widget for QtConsole.\"\"\"\n        from io import BytesIO\n\n        try:\n            from imageio import imwrite\n        except ImportError:\n            return None\n\n        rendered = self.screenshot()\n        if rendered is not None:\n            with BytesIO() as file_obj:\n                imwrite(file_obj, rendered, format=\"png\")\n                file_obj.seek(0)\n                return file_obj.read()\n        return None\n\n    def _ipython_display_(self, *args: Any, **kwargs: Any) -&gt; Any:\n        if hasattr(self._backend_object, \"_ipython_display_\"):\n            return self._backend_object._ipython_display_(*args, **kwargs)\n        raise NotImplementedError()\n\n    def _repr_mimebundle_(self, *args: Any, **kwargs: Any) -&gt; dict:\n        if hasattr(self._backend_object, \"_repr_mimebundle_\"):\n            return self._backend_object._repr_mimebundle_(*args, **kwargs)\n        raise NotImplementedError()\n\n    def _repr_html_(self, *args: Any, **kwargs: Any) -&gt; str:\n        if hasattr(self._backend_object, \"_repr_html_\"):\n            return self._backend_object._repr_html_(*args, **kwargs)\n        raise NotImplementedError()\n\n    def to_html(self, file: str | None = None) -&gt; str:\n        \"\"\"Return HTML representation of the grid.\"\"\"\n        html = self._backend.get(\"to_html\")(self._backend_object)\n        if file is not None:\n            Path(file).write_text(html, encoding=\"utf-8\")\n        return html\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.background_color","title":"<code>background_color: NDArray[np.floating]</code>  <code>property</code> <code>writable</code>","text":"<p>Background color of the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.shape","title":"<code>shape: tuple[int, int]</code>  <code>property</code>","text":"<p>The (row, col) shape of the grid</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.size","title":"<code>size: tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Size in width x height.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.add_canvas","title":"<code>add_canvas(row, col, rowspan=1, colspan=1, *, palette=None)</code>","text":"<p>Add a canvas to the grid at the given position</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def add_canvas(\n    self,\n    row: int,\n    col: int,\n    rowspan: int = 1,\n    colspan: int = 1,\n    *,\n    palette: str | None = None,\n) -&gt; Canvas:\n    \"\"\"Add a canvas to the grid at the given position\"\"\"\n    for idx, item in np.ndenumerate(self._canvas_array[row, col]):\n        if item is not None:\n            raise ValueError(f\"Canvas already exists at {idx}\")\n    backend_canvas = self._backend_object._plt_add_canvas(\n        row, col, rowspan, colspan\n    )\n    canvas = self._canvas_array[row, col] = Canvas.from_backend(\n        backend_canvas,\n        backend=self._backend,\n        palette=palette,\n    )\n    # Now backend axes/viewbox are created, we can install mouse events\n    canvas._install_mouse_events()\n\n    # link axes if needed\n    if self._x_linked:\n        self._x_linker_ref.link(canvas.x)\n    if self._y_linked:\n        self._y_linker_ref.link(canvas.y)\n    canvas.events.drawn.connect(self.events.drawn.emit, unique=True, max_args=None)\n    return canvas\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.fill","title":"<code>fill(palette=None)</code>","text":"<p>Fill the grid with canvases.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def fill(self, palette: ColormapType | None = None) -&gt; Self:\n    \"\"\"Fill the grid with canvases.\"\"\"\n    for _ in self._iter_add_canvas(palette=palette):\n        pass\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.link_x","title":"<code>link_x(*, future=True, hide_ticks=True)</code>","text":"<p>Link all the x-axes of the canvases in the grid.</p> <p>from whitecanvas import new_grid g = new_grid(2, 2).link_x()  # link x-axes of all canvases</p> <p>Parameters:</p> Name Type Description Default <code>future</code> <code>bool</code> <p>If Ture, all the canvases added in the future will also be linked. Only link the existing canvases if False.</p> <code>True</code> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def link_x(self, *, future: bool = True, hide_ticks: bool = True) -&gt; Self:\n    \"\"\"\n    Link all the x-axes of the canvases in the grid.\n\n    &gt;&gt;&gt; from whitecanvas import new_grid\n    &gt;&gt;&gt; g = new_grid(2, 2).link_x()  # link x-axes of all canvases\n\n    Parameters\n    ----------\n    future : bool, default True\n        If Ture, all the canvases added in the future will also be linked. Only link\n        the existing canvases if False.\n    \"\"\"\n    if self._x_linker_ref is not None:\n        self._x_linker_ref.unlink_all()  # initialize linker\n    to_link = []\n    for (_r, _), _canvas in self._iter_canvas():\n        to_link.append(_canvas.x)\n        if hide_ticks and _r != self.shape[0] - 1:\n            _canvas.x.ticks.visible = False\n    self._x_linker_ref = link_axes(to_link)\n    if future:\n        self._x_linked = True\n        if hide_ticks:\n            self._backend_object._plt_set_spacings(6, 6)\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.link_y","title":"<code>link_y(*, future=True, hide_ticks=True)</code>","text":"<p>Link all the y-axes of the canvases in the grid.</p> <p>from whitecanvas import new_grid g = new_grid(2, 2).link_y()  # link y-axes of all canvases</p> <p>Parameters:</p> Name Type Description Default <code>future</code> <code>bool</code> <p>If Ture, all the canvases added in the future will also be linked. Only link the existing canvases if False.</p> <code>True</code> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def link_y(self, *, future: bool = True, hide_ticks: bool = True) -&gt; Self:\n    \"\"\"\n    Link all the y-axes of the canvases in the grid.\n\n    &gt;&gt;&gt; from whitecanvas import new_grid\n    &gt;&gt;&gt; g = new_grid(2, 2).link_y()  # link y-axes of all canvases\n\n    Parameters\n    ----------\n    future : bool, default True\n        If Ture, all the canvases added in the future will also be linked. Only link\n        the existing canvases if False.\n    \"\"\"\n    if self._y_linker_ref is not None:\n        self._y_linker_ref.unlink_all()\n    to_link = []\n    for (_, _c), _canvas in self._iter_canvas():\n        to_link.append(_canvas.y)\n        if hide_ticks and _c != 0:\n            _canvas.y.ticks.visible = False\n    self._y_linker_ref = link_axes(to_link)\n    if future:\n        self._y_linked = True\n        if hide_ticks:\n            self._backend_object._plt_set_spacings(6, 6)\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.screenshot","title":"<code>screenshot()</code>","text":"<p>Return a screenshot of the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def screenshot(self) -&gt; NDArray[np.uint8]:\n    \"\"\"Return a screenshot of the grid.\"\"\"\n    return self._backend_object._plt_screenshot()\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.show","title":"<code>show(block=False)</code>","text":"<p>Show the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def show(self, block=False) -&gt; None:\n    \"\"\"Show the grid.\"\"\"\n    from whitecanvas.backend._app import get_app\n\n    # TODO: implement other event loops\n    app = get_app(self._backend._app)\n    _backend_app = app.get_app()\n    out = self._backend_object._plt_show()\n\n    if out is NotImplemented:\n        from whitecanvas.backend._window import view\n\n        view(self, self._backend.app)\n\n    if block:\n        # TODO: automatically block the event loop or enable ipython\n        # GUI mode if needed.\n        app.run_app()\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.to_html","title":"<code>to_html(file=None)</code>","text":"<p>Return HTML representation of the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def to_html(self, file: str | None = None) -&gt; str:\n    \"\"\"Return HTML representation of the grid.\"\"\"\n    html = self._backend.get(\"to_html\")(self._backend_object)\n    if file is not None:\n        Path(file).write_text(html, encoding=\"utf-8\")\n    return html\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid","title":"<code>JointGrid</code>","text":"<p>Grid with a main (joint) canvas and two marginal canvases.</p> <p>The marginal canvases shares the x-axis and y-axis with the main canvas.</p> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>class JointGrid(CanvasGrid):\n    \"\"\"\n    Grid with a main (joint) canvas and two marginal canvases.\n\n    The marginal canvases shares the x-axis and y-axis with the main canvas.\n    \"\"\"\n\n    def __init__(\n        self,\n        loc: tuple[_0_or_1, _0_or_1] = (1, 0),\n        palette: str | ColormapType | None = None,\n        ratio: int = 4,\n        backend: Backend | str | None = None,\n    ):\n        widths = [1, 1]\n        heights = [1, 1]\n        rloc, cloc = loc\n        if rloc not in (0, 1) or cloc not in (0, 1):\n            raise ValueError(f\"Invalid location {loc!r}.\")\n        widths[rloc] = heights[cloc] = ratio\n        super().__init__(widths, heights, backend=Backend(backend))\n        self._main_canvas = self.add_canvas(rloc, cloc, palette=palette)\n        self._x_canvas = self.add_canvas(1 - rloc, cloc)\n        self._y_canvas = self.add_canvas(rloc, 1 - cloc)\n\n        # flip the axes if needed\n        if rloc == 0:\n            self._x_canvas.y.flipped = True\n            self._x_namespace_canvas = self._x_canvas\n            self._main_canvas.x.ticks.visible = False\n            self._title_namespace_canvas = self._main_canvas\n        else:\n            self._x_namespace_canvas = self._main_canvas\n            self._x_canvas.x.ticks.visible = False\n            self._title_namespace_canvas = self._x_canvas\n        if cloc == 0:\n            self._ynamespace_canvas = self._main_canvas\n            self._y_canvas.y.ticks.visible = False\n        else:\n            self._y_canvas.x.flipped = True\n            self._ynamespace_canvas = self._y_canvas\n            self._main_canvas.y.ticks.visible = False\n\n        self._backend_object._plt_set_spacings(10, 10)\n\n        # link axes\n        self._x_linker = link_axes([self._main_canvas.x, self._x_canvas.x])\n        self._y_linker = link_axes([self._main_canvas.y, self._y_canvas.y])\n\n        # joint plotter\n        self._x_plotters = []\n        self._y_plotters = []\n\n    def _iter_x_plotters(self) -&gt; Iterator[MarginalPlotter]:\n        if len(self._x_plotters) == 0:\n            yield MarginalHistPlotter(Orientation.VERTICAL)\n        else:\n            yield from self._x_plotters\n\n    def _iter_y_plotters(self) -&gt; Iterator[MarginalPlotter]:\n        if len(self._y_plotters) == 0:\n            yield MarginalHistPlotter(Orientation.HORIZONTAL)\n        else:\n            yield from self._y_plotters\n\n    @property\n    def x_canvas(self) -&gt; Canvas:\n        \"\"\"The canvas at the x-axis.\"\"\"\n        return self._x_canvas\n\n    @property\n    def y_canvas(self) -&gt; Canvas:\n        \"\"\"The canvas at the y-axis.\"\"\"\n        return self._y_canvas\n\n    @property\n    def main_canvas(self) -&gt; Canvas:\n        \"\"\"The main (joint) canvas.\"\"\"\n        return self._main_canvas\n\n    @property\n    def x(self) -&gt; _ns.XAxisNamespace:\n        \"\"\"The x-axis namespace of the joint grid.\"\"\"\n        return self._x_namespace_canvas.x\n\n    @property\n    def y(self) -&gt; _ns.YAxisNamespace:\n        \"\"\"The y-axis namespace of the joint grid.\"\"\"\n        return self._ynamespace_canvas.y\n\n    @property\n    def title(self) -&gt; _ns.TitleNamespace:\n        \"\"\"Title namespace of the joint grid.\"\"\"\n        return self._title_namespace_canvas.title\n\n    def cat(\n        self,\n        data: _DF,\n        x: str | None = None,\n        y: str | None = None,\n        *,\n        update_labels: bool = True,\n    ) -&gt; JointCatPlotter[Self, _DF]:\n        \"\"\"Create a joint categorical canvas.\"\"\"\n        from whitecanvas.canvas.dataframe import JointCatPlotter\n\n        return JointCatPlotter(self, data, x, y, update_labels=update_labels)\n\n    def _link_marginal_to_main(self, layer: _l.Layer, main: _l.Layer) -&gt; None:\n        # TODO: this is not the only thing to be done\n        main.events.visible.connect_setattr(layer, \"visible\")\n\n    def add_legend(\n        self,\n        layers: Sequence[str | _l.Layer] | None = None,\n        location: Location | LocationStr = \"top_right\",\n        *,\n        title: str | None = None,\n    ):\n        \"\"\"Add legend to the main canvas.\"\"\"\n        self.main_canvas.add_legend(layers, location=location, title=title)\n        return None\n\n    def add_markers(\n        self,\n        xdata: ArrayLike1D,\n        ydata: ArrayLike1D,\n        *,\n        name: str | None = None,\n        symbol: Symbol | str | None = None,\n        size: float | None = None,\n        color: ColorType | None = None,\n        alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Markers[_mixin.ConstFace, _mixin.ConstEdge, float]:\n        color = self._main_canvas._generate_colors(color)\n        out = self._main_canvas.add_markers(\n            xdata, ydata, name=name, symbol=symbol, size=size, color=color,\n            alpha=alpha, hatch=hatch,\n        )  # fmt: skip\n        for _x_plt in self._iter_x_plotters():\n            xlayer = _x_plt.add_layer_for_markers(\n                xdata, color, hatch, backend=self._backend\n            )\n            self.x_canvas.add_layer(xlayer)\n            self._link_marginal_to_main(xlayer, out)\n        for _y_plt in self._iter_y_plotters():\n            ylayer = _y_plt.add_layer_for_markers(\n                ydata, color, hatch, backend=self._backend\n            )\n            self.y_canvas.add_layer(ylayer)\n            self._link_marginal_to_main(ylayer, out)\n        self._autoscale_layers()\n        return out\n\n    def with_hist_x(\n        self,\n        *,\n        bins: HistBinType = \"auto\",\n        limits: tuple[float, float] | None = None,\n        kind: str | HistogramKind = HistogramKind.density,\n        shape: str | HistogramShape = HistogramShape.bars,\n    ) -&gt; Self:\n        \"\"\"\n        Configure the x-marginal canvas to have a histogram.\n\n        Parameters\n        ----------\n        bins : int or 1D array-like, default \"auto\"\n            Bins of the histogram. This parameter will directly be passed\n            to `np.histogram`.\n        limits : (float, float), optional\n            Limits in which histogram will be built. This parameter will equivalent to\n            the `range` paraneter of `np.histogram`.\n        shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n            Shape of the histogram. This parameter defines how to convert the data into\n            the line nodes.\n        kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n            Kind of the histogram.\n        \"\"\"\n        self._x_plotters.append(\n            MarginalHistPlotter(\n                Orientation.VERTICAL, bins=bins, limits=limits, kind=kind, shape=shape\n            )\n        )\n        return self\n\n    def with_hist_y(\n        self,\n        *,\n        bins: HistBinType = \"auto\",\n        limits: tuple[float, float] | None = None,\n        kind: str | HistogramKind = HistogramKind.density,\n        shape: str | HistogramShape = HistogramShape.bars,\n    ) -&gt; Self:\n        \"\"\"\n        Configure the y-marginal canvas to have a histogram.\n\n        Parameters\n        ----------\n        bins : int or 1D array-like, default \"auto\"\n            Bins of the histogram. This parameter will directly be passed\n            to `np.histogram`.\n        limits : (float, float), optional\n            Limits in which histogram will be built. This parameter will equivalent to\n            the `range` paraneter of `np.histogram`.\n        shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n            Shape of the histogram. This parameter defines how to convert the data into\n            the line nodes.\n        kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n            Kind of the histogram.\n        \"\"\"\n        self._y_plotters.append(\n            MarginalHistPlotter(\n                Orientation.HORIZONTAL, bins=bins, limits=limits, kind=kind, shape=shape\n            )\n        )\n        return self\n\n    def with_hist(\n        self,\n        *,\n        bins: HistBinType | tuple[HistBinType, HistBinType] = \"auto\",\n        limits: tuple[float, float] | None = None,\n        kind: str | HistogramKind = HistogramKind.density,\n        shape: str | HistogramShape = HistogramShape.bars,\n    ) -&gt; Self:\n        \"\"\"\n        Configure both of the marginal canvases to have histograms.\n\n        Parameters\n        ----------\n        bins : int or 1D array-like, default \"auto\"\n            Bins of the histogram. This parameter will directly be passed\n            to `np.histogram`.\n        limits : (float, float), optional\n            Limits in which histogram will be built. This parameter will equivalent to\n            the `range` paraneter of `np.histogram`.\n        shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n            Shape of the histogram. This parameter defines how to convert the data into\n            the line nodes.\n        kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n            Kind of the histogram.\n        \"\"\"\n        if isinstance(bins, tuple):\n            bins_x, bins_y = bins\n        else:\n            bins_x = bins_y = bins\n        self.with_hist_x(bins=bins_x, limits=limits, kind=kind, shape=shape)\n        self.with_hist_y(bins=bins_y, limits=limits, kind=kind, shape=shape)\n        return self\n\n    def with_kde_x(\n        self,\n        *,\n        width: float | None = None,\n        band_width: KdeBandWidthType = \"scott\",\n        fill_alpha: float = 0.2,\n    ) -&gt; Self:\n        \"\"\"\n        Configure the x-marginal canvas to have a kernel density estimate (KDE) plot.\n\n        Parameters\n        ----------\n        width : float, optional\n            Width of the line. Use theme default if not specified.\n        band_width : \"scott\", \"silverman\" or float, default \"scott\"\n            Bandwidth of the kernel.\n        fill_alpha : float, default 0.2\n            Alpha value of the fill color.\n        \"\"\"\n        width = theme._default(\"line.width\", width)\n        self._x_plotters.append(\n            MarginalKdePlotter(\n                Orientation.VERTICAL,\n                width=width,\n                band_width=band_width,\n                fill_alpha=fill_alpha,\n            )\n        )\n        return self\n\n    def with_kde_y(\n        self,\n        *,\n        width: float | None = None,\n        band_width: KdeBandWidthType = \"scott\",\n        fill_alpha: float = 0.2,\n    ) -&gt; Self:\n        \"\"\"\n        Configure the y-marginal canvas to have a kernel density estimate (KDE) plot.\n\n        Parameters\n        ----------\n        width : float, optional\n            Width of the line. Use theme default if not specified.\n        band_width : \"scott\", \"silverman\" or float, default \"scott\"\n            Bandwidth of the kernel.\n        fill_alpha : float, default 0.2\n            Alpha value of the fill color.\n        \"\"\"\n        width = theme._default(\"line.width\", width)\n        self._y_plotters.append(\n            MarginalKdePlotter(\n                Orientation.HORIZONTAL,\n                width=width,\n                band_width=band_width,\n                fill_alpha=fill_alpha,\n            )\n        )\n        return self\n\n    def with_kde(\n        self,\n        *,\n        width: float | None = None,\n        band_width: KdeBandWidthType = \"scott\",\n        fill_alpha: float = 0.2,\n    ) -&gt; Self:\n        \"\"\"\n        Configure both of the marginal canvases to have KDE plots.\n\n        Parameters\n        ----------\n        width : float, optional\n            Width of the line. Use theme default if not specified.\n        band_width : \"scott\", \"silverman\" or float, default \"scott\"\n            Bandwidth of the kernel.\n        fill_alpha : float, default 0.2\n            Alpha value of the fill color.\n        \"\"\"\n        self.with_kde_x(width=width, band_width=band_width, fill_alpha=fill_alpha)\n        self.with_kde_y(width=width, band_width=band_width, fill_alpha=fill_alpha)\n        return self\n\n    def with_rug_x(self, *, width: float | None = None) -&gt; Self:\n        \"\"\"\n        Configure the x-marginal canvas to have a rug plot.\n\n        Parameters\n        ----------\n        width : float, optional\n            Width of the line. Use theme default if not specified.\n        \"\"\"\n        width = theme._default(\"line.width\", width)\n        self._x_plotters.append(MarginalRugPlotter(Orientation.VERTICAL, width=width))\n        return self\n\n    def with_rug_y(self, *, width: float | None = None) -&gt; Self:\n        \"\"\"\n        Configure the y-marginal canvas to have a rug plot.\n\n        Parameters\n        ----------\n        width : float, optional\n            Width of the line. Use theme default if not specified.\n        \"\"\"\n        width = theme._default(\"line.width\", width)\n        self._y_plotters.append(MarginalRugPlotter(Orientation.HORIZONTAL, width=width))\n        return self\n\n    def with_rug(self, *, width: float | None = None) -&gt; Self:\n        \"\"\"\n        Configure both of the marginal canvases to have rug plots.\n\n        Parameters\n        ----------\n        width : float, optional\n            Width of the line. Use theme default if not specified.\n        \"\"\"\n        self.with_rug_x(width=width)\n        self.with_rug_y(width=width)\n        return self\n\n    def _autoscale_layers(self):\n        for layer in self.x_canvas.layers:\n            if isinstance(layer, (_l.Rug, _lt.DFRug)):\n                ylow, yhigh = self.x_canvas.y.lim\n                layer.update_length((yhigh - ylow) * 0.1)\n        for layer in self.y_canvas.layers:\n            if isinstance(layer, (_l.Rug, _lt.DFRug)):\n                xlow, xhigh = self.y_canvas.x.lim\n                layer.update_length((xhigh - xlow) * 0.1)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.main_canvas","title":"<code>main_canvas: Canvas</code>  <code>property</code>","text":"<p>The main (joint) canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.title","title":"<code>title: _ns.TitleNamespace</code>  <code>property</code>","text":"<p>Title namespace of the joint grid.</p>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.x","title":"<code>x: _ns.XAxisNamespace</code>  <code>property</code>","text":"<p>The x-axis namespace of the joint grid.</p>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.x_canvas","title":"<code>x_canvas: Canvas</code>  <code>property</code>","text":"<p>The canvas at the x-axis.</p>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.y","title":"<code>y: _ns.YAxisNamespace</code>  <code>property</code>","text":"<p>The y-axis namespace of the joint grid.</p>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.y_canvas","title":"<code>y_canvas: Canvas</code>  <code>property</code>","text":"<p>The canvas at the y-axis.</p>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.add_legend","title":"<code>add_legend(layers=None, location='top_right', *, title=None)</code>","text":"<p>Add legend to the main canvas.</p> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def add_legend(\n    self,\n    layers: Sequence[str | _l.Layer] | None = None,\n    location: Location | LocationStr = \"top_right\",\n    *,\n    title: str | None = None,\n):\n    \"\"\"Add legend to the main canvas.\"\"\"\n    self.main_canvas.add_legend(layers, location=location, title=title)\n    return None\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.cat","title":"<code>cat(data, x=None, y=None, *, update_labels=True)</code>","text":"<p>Create a joint categorical canvas.</p> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def cat(\n    self,\n    data: _DF,\n    x: str | None = None,\n    y: str | None = None,\n    *,\n    update_labels: bool = True,\n) -&gt; JointCatPlotter[Self, _DF]:\n    \"\"\"Create a joint categorical canvas.\"\"\"\n    from whitecanvas.canvas.dataframe import JointCatPlotter\n\n    return JointCatPlotter(self, data, x, y, update_labels=update_labels)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_hist","title":"<code>with_hist(*, bins='auto', limits=None, kind=HistogramKind.density, shape=HistogramShape.bars)</code>","text":"<p>Configure both of the marginal canvases to have histograms.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>int or 1D array-like</code> <p>Bins of the histogram. This parameter will directly be passed to <code>np.histogram</code>.</p> <code>\"auto\"</code> <code>limits</code> <code>(float, float)</code> <p>Limits in which histogram will be built. This parameter will equivalent to the <code>range</code> paraneter of <code>np.histogram</code>.</p> <code>None</code> <code>shape</code> <code>('step', 'polygon', 'bars')</code> <p>Shape of the histogram. This parameter defines how to convert the data into the line nodes.</p> <code>\"step\"</code> <code>kind</code> <code>('count', 'density', 'probability', 'frequency', 'percent')</code> <p>Kind of the histogram.</p> <code>\"count\"</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_hist(\n    self,\n    *,\n    bins: HistBinType | tuple[HistBinType, HistBinType] = \"auto\",\n    limits: tuple[float, float] | None = None,\n    kind: str | HistogramKind = HistogramKind.density,\n    shape: str | HistogramShape = HistogramShape.bars,\n) -&gt; Self:\n    \"\"\"\n    Configure both of the marginal canvases to have histograms.\n\n    Parameters\n    ----------\n    bins : int or 1D array-like, default \"auto\"\n        Bins of the histogram. This parameter will directly be passed\n        to `np.histogram`.\n    limits : (float, float), optional\n        Limits in which histogram will be built. This parameter will equivalent to\n        the `range` paraneter of `np.histogram`.\n    shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n        Shape of the histogram. This parameter defines how to convert the data into\n        the line nodes.\n    kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n        Kind of the histogram.\n    \"\"\"\n    if isinstance(bins, tuple):\n        bins_x, bins_y = bins\n    else:\n        bins_x = bins_y = bins\n    self.with_hist_x(bins=bins_x, limits=limits, kind=kind, shape=shape)\n    self.with_hist_y(bins=bins_y, limits=limits, kind=kind, shape=shape)\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_hist_x","title":"<code>with_hist_x(*, bins='auto', limits=None, kind=HistogramKind.density, shape=HistogramShape.bars)</code>","text":"<p>Configure the x-marginal canvas to have a histogram.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>int or 1D array-like</code> <p>Bins of the histogram. This parameter will directly be passed to <code>np.histogram</code>.</p> <code>\"auto\"</code> <code>limits</code> <code>(float, float)</code> <p>Limits in which histogram will be built. This parameter will equivalent to the <code>range</code> paraneter of <code>np.histogram</code>.</p> <code>None</code> <code>shape</code> <code>('step', 'polygon', 'bars')</code> <p>Shape of the histogram. This parameter defines how to convert the data into the line nodes.</p> <code>\"step\"</code> <code>kind</code> <code>('count', 'density', 'probability', 'frequency', 'percent')</code> <p>Kind of the histogram.</p> <code>\"count\"</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_hist_x(\n    self,\n    *,\n    bins: HistBinType = \"auto\",\n    limits: tuple[float, float] | None = None,\n    kind: str | HistogramKind = HistogramKind.density,\n    shape: str | HistogramShape = HistogramShape.bars,\n) -&gt; Self:\n    \"\"\"\n    Configure the x-marginal canvas to have a histogram.\n\n    Parameters\n    ----------\n    bins : int or 1D array-like, default \"auto\"\n        Bins of the histogram. This parameter will directly be passed\n        to `np.histogram`.\n    limits : (float, float), optional\n        Limits in which histogram will be built. This parameter will equivalent to\n        the `range` paraneter of `np.histogram`.\n    shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n        Shape of the histogram. This parameter defines how to convert the data into\n        the line nodes.\n    kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n        Kind of the histogram.\n    \"\"\"\n    self._x_plotters.append(\n        MarginalHistPlotter(\n            Orientation.VERTICAL, bins=bins, limits=limits, kind=kind, shape=shape\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_hist_y","title":"<code>with_hist_y(*, bins='auto', limits=None, kind=HistogramKind.density, shape=HistogramShape.bars)</code>","text":"<p>Configure the y-marginal canvas to have a histogram.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>int or 1D array-like</code> <p>Bins of the histogram. This parameter will directly be passed to <code>np.histogram</code>.</p> <code>\"auto\"</code> <code>limits</code> <code>(float, float)</code> <p>Limits in which histogram will be built. This parameter will equivalent to the <code>range</code> paraneter of <code>np.histogram</code>.</p> <code>None</code> <code>shape</code> <code>('step', 'polygon', 'bars')</code> <p>Shape of the histogram. This parameter defines how to convert the data into the line nodes.</p> <code>\"step\"</code> <code>kind</code> <code>('count', 'density', 'probability', 'frequency', 'percent')</code> <p>Kind of the histogram.</p> <code>\"count\"</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_hist_y(\n    self,\n    *,\n    bins: HistBinType = \"auto\",\n    limits: tuple[float, float] | None = None,\n    kind: str | HistogramKind = HistogramKind.density,\n    shape: str | HistogramShape = HistogramShape.bars,\n) -&gt; Self:\n    \"\"\"\n    Configure the y-marginal canvas to have a histogram.\n\n    Parameters\n    ----------\n    bins : int or 1D array-like, default \"auto\"\n        Bins of the histogram. This parameter will directly be passed\n        to `np.histogram`.\n    limits : (float, float), optional\n        Limits in which histogram will be built. This parameter will equivalent to\n        the `range` paraneter of `np.histogram`.\n    shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n        Shape of the histogram. This parameter defines how to convert the data into\n        the line nodes.\n    kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n        Kind of the histogram.\n    \"\"\"\n    self._y_plotters.append(\n        MarginalHistPlotter(\n            Orientation.HORIZONTAL, bins=bins, limits=limits, kind=kind, shape=shape\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_kde","title":"<code>with_kde(*, width=None, band_width='scott', fill_alpha=0.2)</code>","text":"<p>Configure both of the marginal canvases to have KDE plots.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the line. Use theme default if not specified.</p> <code>None</code> <code>band_width</code> <code>('scott', 'silverman' or float)</code> <p>Bandwidth of the kernel.</p> <code>\"scott\"</code> <code>fill_alpha</code> <code>float</code> <p>Alpha value of the fill color.</p> <code>0.2</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_kde(\n    self,\n    *,\n    width: float | None = None,\n    band_width: KdeBandWidthType = \"scott\",\n    fill_alpha: float = 0.2,\n) -&gt; Self:\n    \"\"\"\n    Configure both of the marginal canvases to have KDE plots.\n\n    Parameters\n    ----------\n    width : float, optional\n        Width of the line. Use theme default if not specified.\n    band_width : \"scott\", \"silverman\" or float, default \"scott\"\n        Bandwidth of the kernel.\n    fill_alpha : float, default 0.2\n        Alpha value of the fill color.\n    \"\"\"\n    self.with_kde_x(width=width, band_width=band_width, fill_alpha=fill_alpha)\n    self.with_kde_y(width=width, band_width=band_width, fill_alpha=fill_alpha)\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_kde_x","title":"<code>with_kde_x(*, width=None, band_width='scott', fill_alpha=0.2)</code>","text":"<p>Configure the x-marginal canvas to have a kernel density estimate (KDE) plot.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the line. Use theme default if not specified.</p> <code>None</code> <code>band_width</code> <code>('scott', 'silverman' or float)</code> <p>Bandwidth of the kernel.</p> <code>\"scott\"</code> <code>fill_alpha</code> <code>float</code> <p>Alpha value of the fill color.</p> <code>0.2</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_kde_x(\n    self,\n    *,\n    width: float | None = None,\n    band_width: KdeBandWidthType = \"scott\",\n    fill_alpha: float = 0.2,\n) -&gt; Self:\n    \"\"\"\n    Configure the x-marginal canvas to have a kernel density estimate (KDE) plot.\n\n    Parameters\n    ----------\n    width : float, optional\n        Width of the line. Use theme default if not specified.\n    band_width : \"scott\", \"silverman\" or float, default \"scott\"\n        Bandwidth of the kernel.\n    fill_alpha : float, default 0.2\n        Alpha value of the fill color.\n    \"\"\"\n    width = theme._default(\"line.width\", width)\n    self._x_plotters.append(\n        MarginalKdePlotter(\n            Orientation.VERTICAL,\n            width=width,\n            band_width=band_width,\n            fill_alpha=fill_alpha,\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_kde_y","title":"<code>with_kde_y(*, width=None, band_width='scott', fill_alpha=0.2)</code>","text":"<p>Configure the y-marginal canvas to have a kernel density estimate (KDE) plot.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the line. Use theme default if not specified.</p> <code>None</code> <code>band_width</code> <code>('scott', 'silverman' or float)</code> <p>Bandwidth of the kernel.</p> <code>\"scott\"</code> <code>fill_alpha</code> <code>float</code> <p>Alpha value of the fill color.</p> <code>0.2</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_kde_y(\n    self,\n    *,\n    width: float | None = None,\n    band_width: KdeBandWidthType = \"scott\",\n    fill_alpha: float = 0.2,\n) -&gt; Self:\n    \"\"\"\n    Configure the y-marginal canvas to have a kernel density estimate (KDE) plot.\n\n    Parameters\n    ----------\n    width : float, optional\n        Width of the line. Use theme default if not specified.\n    band_width : \"scott\", \"silverman\" or float, default \"scott\"\n        Bandwidth of the kernel.\n    fill_alpha : float, default 0.2\n        Alpha value of the fill color.\n    \"\"\"\n    width = theme._default(\"line.width\", width)\n    self._y_plotters.append(\n        MarginalKdePlotter(\n            Orientation.HORIZONTAL,\n            width=width,\n            band_width=band_width,\n            fill_alpha=fill_alpha,\n        )\n    )\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_rug","title":"<code>with_rug(*, width=None)</code>","text":"<p>Configure both of the marginal canvases to have rug plots.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the line. Use theme default if not specified.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_rug(self, *, width: float | None = None) -&gt; Self:\n    \"\"\"\n    Configure both of the marginal canvases to have rug plots.\n\n    Parameters\n    ----------\n    width : float, optional\n        Width of the line. Use theme default if not specified.\n    \"\"\"\n    self.with_rug_x(width=width)\n    self.with_rug_y(width=width)\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_rug_x","title":"<code>with_rug_x(*, width=None)</code>","text":"<p>Configure the x-marginal canvas to have a rug plot.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the line. Use theme default if not specified.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_rug_x(self, *, width: float | None = None) -&gt; Self:\n    \"\"\"\n    Configure the x-marginal canvas to have a rug plot.\n\n    Parameters\n    ----------\n    width : float, optional\n        Width of the line. Use theme default if not specified.\n    \"\"\"\n    width = theme._default(\"line.width\", width)\n    self._x_plotters.append(MarginalRugPlotter(Orientation.VERTICAL, width=width))\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.JointGrid.with_rug_y","title":"<code>with_rug_y(*, width=None)</code>","text":"<p>Configure the y-marginal canvas to have a rug plot.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the line. Use theme default if not specified.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_joint.py</code> <pre><code>def with_rug_y(self, *, width: float | None = None) -&gt; Self:\n    \"\"\"\n    Configure the y-marginal canvas to have a rug plot.\n\n    Parameters\n    ----------\n    width : float, optional\n        Width of the line. Use theme default if not specified.\n    \"\"\"\n    width = theme._default(\"line.width\", width)\n    self._y_plotters.append(MarginalRugPlotter(Orientation.HORIZONTAL, width=width))\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas","title":"<code>SingleCanvas</code>","text":"<p>A canvas without other subplots.</p> <p>This class is the simplest form of canvas. In <code>matplotlib</code> terms, it is a figure with a single axes.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>class SingleCanvas(_CanvasWithGrid):\n    \"\"\"\n    A canvas without other subplots.\n\n    This class is the simplest form of canvas. In `matplotlib` terms, it is a figure\n    with a single axes.\n    \"\"\"\n\n    def __init__(self, grid: CanvasGrid):\n        if grid.shape != (1, 1):\n            raise ValueError(f\"Grid shape must be (1, 1), got {grid.shape}\")\n        self._grid = grid\n        _it = grid._iter_canvas()\n        _, canvas = next(_it)\n        if next(_it, None) is not None:\n            raise ValueError(\"Grid must have only one canvas\")\n        self._main_canvas = canvas\n        super().__init__(canvas, grid)\n\n        # NOTE: events, dims etc are not shared between the main canvas and the\n        # SingleCanvas instance. To avoid confusion, the first and the only canvas\n        # should be replaces with the SingleCanvas instance.\n        self.mouse = grid[0, 0].mouse\n        grid._canvas_array[0, 0] = self\n        self.events.drawn.connect(\n            self._main_canvas.events.drawn.emit, unique=True, max_args=None\n        )\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.link_axes","title":"<code>link_axes(*axes)</code>","text":"<p>Link multiple axes.</p> Source code in <code>whitecanvas\\canvas\\_linker.py</code> <pre><code>def link_axes(*axes: AxisNamespace):\n    \"\"\"Link multiple axes.\"\"\"\n    linker = AxisLinker.link_axes(*axes)\n    return AxisLinkerRef(linker)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.AxisNamespace","title":"<code>AxisNamespace</code>","text":"Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>class AxisNamespace(Namespace):\n    events: AxisSignals\n    _attrs = (\"lim\", \"color\", \"flipped\")\n\n    def __init__(self, canvas: CanvasBase | None = None):\n        super().__init__(canvas)\n        self.events = AxisSignals()\n        self._flipped = False\n\n    def _get_object(self) -&gt; protocols.AxisProtocol:\n        raise NotImplementedError\n\n    @property\n    def lim(self) -&gt; tuple[float, float]:\n        \"\"\"Limits of the axis.\"\"\"\n        return self._get_object()._plt_get_limits()\n\n    @lim.setter\n    def lim(self, lim: tuple[float, float]):\n        low, high = lim\n        if low &gt;= high:\n            a = type(self).__name__[0].lower()\n            raise ValueError(\n                f\"low must be less than high, but got {lim!r}. If you \"\n                f\"want to flip the axis, use `canvas.{a}.flipped = True`.\"\n            )\n        # Manually emit signal. This is needed when the plot backend is\n        # implemented in JS (such as bokeh) and the python callback is not\n        # enabled. Otherwise axis linking fails.\n        with self.events.blocked():\n            self._get_object()._plt_set_limits(lim)\n        self.events.lim.emit(lim)\n        return None\n\n    @property\n    def color(self):\n        \"\"\"Color of the axis.\"\"\"\n        return self._get_object()._plt_get_color()\n\n    @color.setter\n    def color(self, color):\n        self._get_object()._plt_set_color(np.array(Color(color)))\n\n    @property\n    def flipped(self) -&gt; bool:\n        \"\"\"Return true if the axis is flipped.\"\"\"\n        return self._flipped\n\n    @flipped.setter\n    def flipped(self, flipped: bool):\n        \"\"\"Set the axis to be flipped.\"\"\"\n        if flipped != self._flipped:\n            self._get_object()._plt_flip()\n            self._flipped = flipped\n\n    def set_gridlines(\n        self,\n        visible: bool = True,\n        color: ColorType = \"gray\",\n        width: float = 1.0,\n        style: str | LineStyle = LineStyle.SOLID,\n    ):\n        color = arr_color(color)\n        style = LineStyle(style)\n        if width &lt; 0:\n            raise ValueError(\"width must be non-negative.\")\n        self._get_object()._plt_set_grid_state(visible, color, width, style)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.AxisNamespace.color","title":"<code>color</code>  <code>property</code> <code>writable</code>","text":"<p>Color of the axis.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.AxisNamespace.flipped","title":"<code>flipped: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return true if the axis is flipped.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.AxisNamespace.lim","title":"<code>lim: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Limits of the axis.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.AxisSignals","title":"<code>AxisSignals</code>","text":"<p>Signals emitted by an axis.</p> Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>class AxisSignals(SignalGroup):\n    \"\"\"Signals emitted by an axis.\"\"\"\n\n    lim = Signal(tuple)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace","title":"<code>MouseNamespace</code>","text":"<p>Namespace that contains the mouse events.</p> Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>class MouseNamespace(AxisNamespace):\n    \"\"\"Namespace that contains the mouse events.\"\"\"\n\n    clicked = MouseSignal(object)\n    \"\"\"Signal emitted when a mouse button is clicked.\"\"\"\n\n    moved = MouseMoveSignal()\n    \"\"\"Signal emitted when the mouse is moved.\"\"\"\n\n    double_clicked = MouseSignal(object)\n    \"\"\"Signal emitted when a mouse button is double-clicked.\"\"\"\n\n    @property\n    def enabled(self) -&gt; bool:\n        \"\"\"Return whether pan/zoom is enabled.\"\"\"\n        return self._get_canvas()._plt_get_mouse_enabled()\n\n    @enabled.setter\n    def enabled(self, enabled: bool):\n        self._get_canvas()._plt_set_mouse_enabled(enabled)\n\n    def emulate_click(\n        self,\n        position: tuple[float, float],\n        *,\n        button: str | MouseButton = MouseButton.LEFT,\n        modifiers: str | Modifier | Sequence[str | Modifier] = (),\n    ) -&gt; None:\n        \"\"\"Emulate a mouse press event.\"\"\"\n        ev = MouseEvent(\n            MouseButton(button),\n            _norm_modifiers(modifiers),\n            Point(*position),\n            MouseEventType.PRESS,\n        )\n        self.clicked.emit(ev)\n        return None\n\n    def emulate_double_click(\n        self,\n        position: tuple[float, float],\n        *,\n        button: str | MouseButton = MouseButton.LEFT,\n        modifiers: str | Modifier | Sequence[str | Modifier] = (),\n    ) -&gt; None:\n        \"\"\"Emulate a mouse double-click event.\"\"\"\n        ev = MouseEvent(\n            MouseButton(button),\n            _norm_modifiers(modifiers),\n            Point(*position),\n            MouseEventType.DOUBLE_CLICK,\n        )\n        self.double_clicked.emit(ev)\n\n    def emulate_hover(\n        self,\n        positions: Sequence[tuple[float, float]],\n        *,\n        modifiers: str | Modifier | Sequence[str | Modifier] = (),\n    ) -&gt; None:\n        \"\"\"Emulate a mouse move event.\"\"\"\n        _modifiers = _norm_modifiers(modifiers)\n\n        for pos in positions:\n            ev = MouseEvent(\n                MouseButton.NONE,\n                _modifiers,\n                Point(*pos),\n                MouseEventType.MOVE,\n            )\n            self.moved.emit(ev)\n        return None\n\n    def emulate_drag(\n        self,\n        positions: Sequence[tuple[float, float]],\n        *,\n        button: str | MouseButton = MouseButton.LEFT,\n        modifiers: str | Modifier | Sequence[str | Modifier] = (),\n    ):\n        \"\"\"Emulate a mouse press-move-release event.\"\"\"\n        _modifiers = _norm_modifiers(modifiers)\n\n        ev = MouseEvent(\n            MouseButton(button),\n            _modifiers,\n            Point(*positions[0]),\n            MouseEventType.PRESS,\n        )\n        self.moved.emit(ev)\n\n        for pos in positions[1:]:\n            ev = MouseEvent(\n                MouseButton(button),\n                _modifiers,\n                Point(*pos),\n                MouseEventType.MOVE,\n            )\n            self.moved.emit(ev)\n\n        ev = MouseEvent(\n            MouseButton(button),\n            _modifiers,\n            Point(*positions[-1]),\n            MouseEventType.RELEASE,\n        )\n        self.moved.emit(ev)\n        return None\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.clicked","title":"<code>clicked = MouseSignal(object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Signal emitted when a mouse button is clicked.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.double_clicked","title":"<code>double_clicked = MouseSignal(object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Signal emitted when a mouse button is double-clicked.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.enabled","title":"<code>enabled: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether pan/zoom is enabled.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.moved","title":"<code>moved = MouseMoveSignal()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Signal emitted when the mouse is moved.</p>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.emulate_click","title":"<code>emulate_click(position, *, button=MouseButton.LEFT, modifiers=())</code>","text":"<p>Emulate a mouse press event.</p> Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>def emulate_click(\n    self,\n    position: tuple[float, float],\n    *,\n    button: str | MouseButton = MouseButton.LEFT,\n    modifiers: str | Modifier | Sequence[str | Modifier] = (),\n) -&gt; None:\n    \"\"\"Emulate a mouse press event.\"\"\"\n    ev = MouseEvent(\n        MouseButton(button),\n        _norm_modifiers(modifiers),\n        Point(*position),\n        MouseEventType.PRESS,\n    )\n    self.clicked.emit(ev)\n    return None\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.emulate_double_click","title":"<code>emulate_double_click(position, *, button=MouseButton.LEFT, modifiers=())</code>","text":"<p>Emulate a mouse double-click event.</p> Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>def emulate_double_click(\n    self,\n    position: tuple[float, float],\n    *,\n    button: str | MouseButton = MouseButton.LEFT,\n    modifiers: str | Modifier | Sequence[str | Modifier] = (),\n) -&gt; None:\n    \"\"\"Emulate a mouse double-click event.\"\"\"\n    ev = MouseEvent(\n        MouseButton(button),\n        _norm_modifiers(modifiers),\n        Point(*position),\n        MouseEventType.DOUBLE_CLICK,\n    )\n    self.double_clicked.emit(ev)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.emulate_drag","title":"<code>emulate_drag(positions, *, button=MouseButton.LEFT, modifiers=())</code>","text":"<p>Emulate a mouse press-move-release event.</p> Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>def emulate_drag(\n    self,\n    positions: Sequence[tuple[float, float]],\n    *,\n    button: str | MouseButton = MouseButton.LEFT,\n    modifiers: str | Modifier | Sequence[str | Modifier] = (),\n):\n    \"\"\"Emulate a mouse press-move-release event.\"\"\"\n    _modifiers = _norm_modifiers(modifiers)\n\n    ev = MouseEvent(\n        MouseButton(button),\n        _modifiers,\n        Point(*positions[0]),\n        MouseEventType.PRESS,\n    )\n    self.moved.emit(ev)\n\n    for pos in positions[1:]:\n        ev = MouseEvent(\n            MouseButton(button),\n            _modifiers,\n            Point(*pos),\n            MouseEventType.MOVE,\n        )\n        self.moved.emit(ev)\n\n    ev = MouseEvent(\n        MouseButton(button),\n        _modifiers,\n        Point(*positions[-1]),\n        MouseEventType.RELEASE,\n    )\n    self.moved.emit(ev)\n    return None\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas._namespaces.MouseNamespace.emulate_hover","title":"<code>emulate_hover(positions, *, modifiers=())</code>","text":"<p>Emulate a mouse move event.</p> Source code in <code>whitecanvas\\canvas\\_namespaces.py</code> <pre><code>def emulate_hover(\n    self,\n    positions: Sequence[tuple[float, float]],\n    *,\n    modifiers: str | Modifier | Sequence[str | Modifier] = (),\n) -&gt; None:\n    \"\"\"Emulate a mouse move event.\"\"\"\n    _modifiers = _norm_modifiers(modifiers)\n\n    for pos in positions:\n        ev = MouseEvent(\n            MouseButton.NONE,\n            _modifiers,\n            Point(*pos),\n            MouseEventType.MOVE,\n        )\n        self.moved.emit(ev)\n    return None\n</code></pre>"},{"location":"api/core/","title":"whitecanvas.core","text":""},{"location":"api/core/#whitecanvas.core.new_canvas","title":"<code>new_canvas(backend=None, *, size=None, palette=None)</code>","text":"<p>Create a new canvas with a single cell.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <code>size</code> <code>(int, int)</code> <p>Displaying size of the canvas (in pixels).</p> <code>None</code> <code>palette</code> <code>str or ColormapType</code> <p>Color palette of the canvas. This color palette will be used to generate colors for the plots.</p> <code>None</code> Source code in <code>whitecanvas\\core.py</code> <pre><code>def new_canvas(\n    backend: Backend | str | None = None,\n    *,\n    size: tuple[int, int] | None = None,\n    palette: str | ColormapType | None = None,\n) -&gt; SingleCanvas:\n    \"\"\"\n    Create a new canvas with a single cell.\n\n    Parameters\n    ----------\n    backend : Backend or str, optional\n        Backend name.\n    size : (int, int), optional\n        Displaying size of the canvas (in pixels).\n    palette : str or ColormapType, optional\n        Color palette of the canvas. This color palette will be used to generate colors\n        for the plots.\n    \"\"\"\n    _grid = CanvasGrid([1], [1], backend=backend)\n    _grid.add_canvas(0, 0, palette=palette)\n    cvs = SingleCanvas(_grid)\n    if size is not None:\n        cvs.size = size\n    return cvs\n</code></pre>"},{"location":"api/core/#whitecanvas.core.new_col","title":"<code>new_col(rows=1, *, size=None, backend=None)</code>","text":"<p>Create a new vertical canvas grid with uniform or non-uniform cell sizes.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def new_col(\n    rows: int | Sequence[int] = 1,\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasVGrid:\n    \"\"\"Create a new vertical canvas grid with uniform or non-uniform cell sizes.\"\"\"\n    heights = _norm_ratio(rows)\n    grid = CanvasVGrid(heights, backend=backend)\n    if size is not None:\n        grid.size = size\n    return grid\n</code></pre>"},{"location":"api/core/#whitecanvas.core.new_grid","title":"<code>new_grid(rows=1, cols=1, *, size=None, backend=None)</code>","text":"<p>Create a new canvas grid with uniform or non-uniform cell sizes.</p> <p>grid = new_grid(2, 3)  # 2x3 grid grid = new_grid(2, 3, size=(800, 600))  # 2x3 grid with size 800x600 grid = new_grid([1, 2], [2, 1])  # 2x2 grid with non-uniform sizes</p> <p>If you want to create a 1D grid, use <code>new_row</code> or <code>new_col</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int or sequence of int</code> <p>Number of rows (if an integer is given) or height ratio of the rows (if a sequence of intergers is given).</p> <code>1</code> <code>cols</code> <code>int or sequence of int</code> <p>Number of columns (if an integer is given) or width ratio of the columns (if a sequence of intergers is given).</p> <code>1</code> <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name, such as \"matplotlib:qt\".</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasGrid</code> <p>Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def new_grid(\n    rows: int | Sequence[int] = 1,\n    cols: int | Sequence[int] = 1,\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasGrid:\n    \"\"\"\n    Create a new canvas grid with uniform or non-uniform cell sizes.\n\n    &gt;&gt;&gt; grid = new_grid(2, 3)  # 2x3 grid\n    &gt;&gt;&gt; grid = new_grid(2, 3, size=(800, 600))  # 2x3 grid with size 800x600\n    &gt;&gt;&gt; grid = new_grid([1, 2], [2, 1])  # 2x2 grid with non-uniform sizes\n\n    If you want to create a 1D grid, use `new_row` or `new_col` instead.\n\n    Parameters\n    ----------\n    rows : int or sequence of int, default 1\n        Number of rows (if an integer is given) or height ratio of the rows (if a\n        sequence of intergers is given).\n    cols : int or sequence of int, default 1\n        Number of columns (if an integer is given) or width ratio of the columns (if a\n        sequence of intergers is given).\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name, such as \"matplotlib:qt\".\n\n    Returns\n    -------\n    CanvasGrid\n        Grid of empty canvases.\n    \"\"\"\n    heights = _norm_ratio(rows)\n    widths = _norm_ratio(cols)\n    grid = CanvasGrid(heights, widths, backend=backend)\n    if size is not None:\n        grid.size = size\n    return grid\n</code></pre>"},{"location":"api/core/#whitecanvas.core.new_jointgrid","title":"<code>new_jointgrid(backend=None, *, loc=(1, 0), size=None, palette=None)</code>","text":"<p>Create a new joint grid.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend or str</code> <p>Backend of the canvas.</p> <code>None</code> <code>loc</code> <code>(int, int)</code> <p>Location of the main canvas. Each integer must be 0 or 1.</p> <code>(1, 0)</code> <code>size</code> <code>(int, int)</code> <p>Size of the canvas in pixel.</p> <code>None</code> <code>palette</code> <code>colormap type</code> <p>Color palette used for the canvases.</p> <code>None</code> <p>Returns:</p> Type Description <code>JointGrid</code> <p>Joint grid object.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def new_jointgrid(\n    backend: Backend | str | None = None,\n    *,\n    loc: tuple[_0_or_1, _0_or_1] = (1, 0),\n    size: tuple[int, int] | None = None,\n    palette: str | ColormapType | None = None,\n) -&gt; JointGrid:\n    \"\"\"\n    Create a new joint grid.\n\n    Parameters\n    ----------\n    backend : Backend or str, optional\n        Backend of the canvas.\n    loc : (int, int), default (1, 0)\n        Location of the main canvas. Each integer must be 0 or 1.\n    size : (int, int), optional\n        Size of the canvas in pixel.\n    palette : colormap type, optional\n        Color palette used for the canvases.\n\n    Returns\n    -------\n    JointGrid\n        Joint grid object.\n    \"\"\"\n    joint = JointGrid(loc, palette=palette, backend=backend)\n    if size is not None:\n        joint.size = size\n    return joint\n</code></pre>"},{"location":"api/core/#whitecanvas.core.new_row","title":"<code>new_row(cols=1, *, size=None, backend=None)</code>","text":"<p>Create a new horizontal canvas grid with uniform or non-uniform cell sizes.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def new_row(\n    cols: int | Sequence[int] = 1,\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasHGrid:\n    \"\"\"Create a new horizontal canvas grid with uniform or non-uniform cell sizes.\"\"\"\n    widths = _norm_ratio(cols)\n    grid = CanvasHGrid(widths, backend=backend)\n    if size is not None:\n        grid.size = size\n    return grid\n</code></pre>"},{"location":"api/core/#whitecanvas.core.wrap_canvas","title":"<code>wrap_canvas(obj, palette=None)</code>","text":"<p>Wrap a backend object into a whitecanvas Canvas.</p> <p>import matplotlib.pyplot as plt canvas = wrap_canvas(plt.gca())</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def wrap_canvas(obj: Any, palette=None) -&gt; Canvas:\n    \"\"\"\n    Wrap a backend object into a whitecanvas Canvas.\n\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; canvas = wrap_canvas(plt.gca())\n    \"\"\"\n    typ = type(obj).__name__\n\n    if _is_in_module(typ, \"matplotlib\", \"Axes\"):\n        from matplotlib.axes import Axes\n\n        from whitecanvas.backend.matplotlib import Canvas as BackendCanvas\n\n        if not isinstance(obj, Axes):\n            raise TypeError(f\"Expected matplotlib Axes, got {typ}\")\n        backend = \"matplotlib\"\n\n    elif _is_in_module(typ, \"plotly\", \"Figure\"):\n        from plotly.graph_objs import Figure\n\n        from whitecanvas.backend.plotly import Canvas as BackendCanvas\n\n        if not isinstance(obj, Figure):\n            raise TypeError(f\"Expected plotly Figure, got {typ}\")\n        backend = \"plotly\"\n    elif _is_in_module(typ, \"bokeh\", \"figure\"):\n        from bokeh.plotting import figure\n\n        from whitecanvas.backend.bokeh import Canvas as BackendCanvas\n\n        if not isinstance(obj, figure):\n            raise TypeError(f\"Expected bokeh figure, got {typ}\")\n        backend = \"bokeh\"\n    elif _is_in_module(typ, \"vispy\", \"ViewBox\"):\n        from vispy.scene import ViewBox\n\n        from whitecanvas.backend.vispy import Canvas as BackendCanvas\n\n        if not isinstance(obj, ViewBox):\n            raise TypeError(f\"Expected vispy ViewBox, got {typ}\")\n        backend = \"vispy\"\n    elif _is_in_module(typ, \"pyqtgraph\", \"PlotItem\"):\n        from pyqtgraph import PlotItem\n\n        from whitecanvas.backend.pyqtgraph import Canvas as BackendCanvas\n\n        if not isinstance(obj, PlotItem):\n            raise TypeError(f\"Expected pyqtgraph PlotItem, got {typ}\")\n        backend = \"pyqtgraph\"\n    else:\n        raise TypeError(f\"Cannot convert {typ} to Canvas\")\n    return Canvas.from_backend(BackendCanvas(obj), palette=palette, backend=backend)\n</code></pre>"},{"location":"api/tools/","title":"whitecanvas.tools","text":"<p>Built-in tools.</p>"},{"location":"api/tools/#whitecanvas.tools.lasso_selector","title":"<code>lasso_selector(canvas, buttons='left', modifiers=None, *, tracking=False)</code>","text":"<p>Create a Lasso selector tool with given settings.</p> <p>A Lasso selector emits a XYData object by freehand drawing. A selection tool is constructed by specifying the canvas to attach the tool.</p> <p>canvas = new_canvas(\"matplotlib:qt\") tool = lasso_selector(canvas)</p> <p>Use <code>buttons</code> and <code>modifiers</code> to specify how to trigger the tool.</p> <p>tool = lasso_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>CanvasBase</code> <p>The canvas to which the tool is attached.</p> required <code>buttons</code> <code>MouseButton or Sequence[MouseButton]</code> <p>The mouse buttons that can trigger the tool.</p> <code>\"left\"</code> <code>modifiers</code> <code>Modifier or Sequence[Modifier]</code> <p>The modifier keys that must be pressed to trigger the tool.</p> <code>None</code> <code>tracking</code> <code>bool</code> <p>If True, the tool emits the changed signal while dragging. Otherwise, it emits the signal only when dragging is finished.</p> <code>False</code> Source code in <code>whitecanvas\\tools\\_selection.py</code> <pre><code>def lasso_selector(\n    canvas: CanvasBase,\n    buttons: _MouseButton | Sequence[_MouseButton] = \"left\",\n    modifiers: _Modifier | Sequence[_Modifier] | None = None,\n    *,\n    tracking: bool = False,\n) -&gt; LassoSelectionTool:\n    \"\"\"\n    Create a Lasso selector tool with given settings.\n\n    A Lasso selector emits a XYData object by freehand drawing.\n    A selection tool is constructed by specifying the canvas to attach the tool.\n\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib:qt\")\n    &gt;&gt;&gt; tool = lasso_selector(canvas)\n\n    Use `buttons` and `modifiers` to specify how to trigger the tool.\n\n    &gt;&gt;&gt; tool = lasso_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")\n\n    Parameters\n    ----------\n    canvas : CanvasBase\n        The canvas to which the tool is attached.\n    buttons : MouseButton or Sequence[MouseButton], default \"left\"\n        The mouse buttons that can trigger the tool.\n    modifiers : Modifier or Sequence[Modifier], optional\n        The modifier keys that must be pressed to trigger the tool.\n    tracking : bool, default False\n        If True, the tool emits the changed signal while dragging. Otherwise, it emits\n        the signal only when dragging is finished.\n    \"\"\"\n    _buttons, _modifiers = _norm_input(buttons, modifiers)\n    return LassoSelectionTool(canvas, _buttons, _modifiers, tracking=tracking)\n</code></pre>"},{"location":"api/tools/#whitecanvas.tools.line_selector","title":"<code>line_selector(canvas, buttons='left', modifiers=None, *, tracking=False)</code>","text":"<p>Create a line selector tool with given settings.</p> <p>A line selector emits a LineSelection object when a line is drawn. A selection tool is constructed by specifying the canvas to attach the tool.</p> <p>canvas = new_canvas(\"matplotlib:qt\") tool = line_selector(canvas)</p> <p>Use <code>buttons</code> and <code>modifiers</code> to specify how to trigger the tool.</p> <p>tool = line_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>CanvasBase</code> <p>The canvas to which the tool is attached.</p> required <code>buttons</code> <code>MouseButton or Sequence[MouseButton]</code> <p>The mouse buttons that can trigger the tool.</p> <code>\"left\"</code> <code>modifiers</code> <code>Modifier or Sequence[Modifier]</code> <p>The modifier keys that must be pressed to trigger the tool.</p> <code>None</code> <code>tracking</code> <code>bool</code> <p>If True, the tool emits the changed signal while dragging. Otherwise, it emits the signal only when dragging is finished.</p> <code>False</code> Source code in <code>whitecanvas\\tools\\_selection.py</code> <pre><code>def line_selector(\n    canvas: CanvasBase,\n    buttons: _MouseButton | Sequence[_MouseButton] = \"left\",\n    modifiers: _Modifier | Sequence[_Modifier] | None = None,\n    *,\n    tracking: bool = False,\n) -&gt; LineSelectionTool:\n    \"\"\"\n    Create a line selector tool with given settings.\n\n    A line selector emits a LineSelection object when a line is drawn.\n    A selection tool is constructed by specifying the canvas to attach the tool.\n\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib:qt\")\n    &gt;&gt;&gt; tool = line_selector(canvas)\n\n    Use `buttons` and `modifiers` to specify how to trigger the tool.\n\n    &gt;&gt;&gt; tool = line_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")\n\n    Parameters\n    ----------\n    canvas : CanvasBase\n        The canvas to which the tool is attached.\n    buttons : MouseButton or Sequence[MouseButton], default \"left\"\n        The mouse buttons that can trigger the tool.\n    modifiers : Modifier or Sequence[Modifier], optional\n        The modifier keys that must be pressed to trigger the tool.\n    tracking : bool, default False\n        If True, the tool emits the changed signal while dragging. Otherwise, it emits\n        the signal only when dragging is finished.\n    \"\"\"\n    _buttons, _modifiers = _norm_input(buttons, modifiers)\n    return LineSelectionTool(canvas, _buttons, _modifiers, tracking=tracking)\n</code></pre>"},{"location":"api/tools/#whitecanvas.tools.polygon_selector","title":"<code>polygon_selector(canvas, buttons='left', modifiers=None, *, tracking=False)</code>","text":"<p>Create a polygon selector tool with given settings.</p> <p>A polygon selector emits a XYData object by freehand drawing. A selection tool is constructed by specifying the canvas to attach the tool.</p> <p>canvas = new_canvas(\"matplotlib:qt\") tool = polygon_selector(canvas)</p> <p>Use <code>buttons</code> and <code>modifiers</code> to specify how to trigger the tool.</p> <p>tool = polygon_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>CanvasBase</code> <p>The canvas to which the tool is attached.</p> required <code>buttons</code> <code>MouseButton or Sequence[MouseButton]</code> <p>The mouse buttons that can trigger the tool.</p> <code>\"left\"</code> <code>modifiers</code> <code>Modifier or Sequence[Modifier]</code> <p>The modifier keys that must be pressed to trigger the tool.</p> <code>None</code> <code>tracking</code> <code>bool</code> <p>If True, the tool emits the changed signal while dragging. Otherwise, it emits the signal only when dragging is finished.</p> <code>False</code> Source code in <code>whitecanvas\\tools\\_selection.py</code> <pre><code>def polygon_selector(\n    canvas: CanvasBase,\n    buttons: _MouseButton | Sequence[_MouseButton] = \"left\",\n    modifiers: _Modifier | Sequence[_Modifier] | None = None,\n    *,\n    tracking: bool = False,\n) -&gt; LassoSelectionTool:\n    \"\"\"\n    Create a polygon selector tool with given settings.\n\n    A polygon selector emits a XYData object by freehand drawing.\n    A selection tool is constructed by specifying the canvas to attach the tool.\n\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib:qt\")\n    &gt;&gt;&gt; tool = polygon_selector(canvas)\n\n    Use `buttons` and `modifiers` to specify how to trigger the tool.\n\n    &gt;&gt;&gt; tool = polygon_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")\n\n    Parameters\n    ----------\n    canvas : CanvasBase\n        The canvas to which the tool is attached.\n    buttons : MouseButton or Sequence[MouseButton], default \"left\"\n        The mouse buttons that can trigger the tool.\n    modifiers : Modifier or Sequence[Modifier], optional\n        The modifier keys that must be pressed to trigger the tool.\n    tracking : bool, default False\n        If True, the tool emits the changed signal while dragging. Otherwise, it emits\n        the signal only when dragging is finished.\n    \"\"\"\n    _buttons, _modifiers = _norm_input(buttons, modifiers)\n    return PolygonSelectionTool(canvas, _buttons, _modifiers, tracking=tracking)\n</code></pre>"},{"location":"api/tools/#whitecanvas.tools.rect_selector","title":"<code>rect_selector(canvas, buttons='left', modifiers=None, *, tracking=False)</code>","text":"<p>Create a rectangle selector tool with given settings.</p> <p>A rectangle selector emits a Rect object when a rectangle is drawn. A selection tool is constructed by specifying the canvas to attach the tool.</p> <p>canvas = new_canvas(\"matplotlib:qt\") tool = rect_selector(canvas)</p> <p>Use <code>buttons</code> and <code>modifiers</code> to specify how to trigger the tool.</p> <p>tool = rect_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>CanvasBase</code> <p>The canvas to which the tool is attached.</p> required <code>buttons</code> <code>MouseButton or Sequence[MouseButton]</code> <p>The mouse buttons that can trigger the tool.</p> <code>\"left\"</code> <code>modifiers</code> <code>Modifier or Sequence[Modifier]</code> <p>The modifier keys that must be pressed to trigger the tool.</p> <code>None</code> <code>tracking</code> <code>bool</code> <p>If True, the tool emits the changed signal while dragging. Otherwise, it emits the signal only when dragging is finished.</p> <code>False</code> Source code in <code>whitecanvas\\tools\\_selection.py</code> <pre><code>def rect_selector(\n    canvas: CanvasBase,\n    buttons: _MouseButton | Sequence[_MouseButton] = \"left\",\n    modifiers: _Modifier | Sequence[_Modifier] | None = None,\n    *,\n    tracking: bool = False,\n) -&gt; RectSelectionTool:\n    \"\"\"\n    Create a rectangle selector tool with given settings.\n\n    A rectangle selector emits a Rect object when a rectangle is drawn.\n    A selection tool is constructed by specifying the canvas to attach the tool.\n\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib:qt\")\n    &gt;&gt;&gt; tool = rect_selector(canvas)\n\n    Use `buttons` and `modifiers` to specify how to trigger the tool.\n\n    &gt;&gt;&gt; tool = rect_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")\n\n    Parameters\n    ----------\n    canvas : CanvasBase\n        The canvas to which the tool is attached.\n    buttons : MouseButton or Sequence[MouseButton], default \"left\"\n        The mouse buttons that can trigger the tool.\n    modifiers : Modifier or Sequence[Modifier], optional\n        The modifier keys that must be pressed to trigger the tool.\n    tracking : bool, default False\n        If True, the tool emits the changed signal while dragging. Otherwise, it emits\n        the signal only when dragging is finished.\n    \"\"\"\n    _buttons, _modifiers = _norm_input(buttons, modifiers)\n    return RectSelectionTool(canvas, _buttons, _modifiers, tracking=tracking)\n</code></pre>"},{"location":"api/tools/#whitecanvas.tools.xspan_selector","title":"<code>xspan_selector(canvas, buttons='left', modifiers=None, *, tracking=False)</code>","text":"<p>Create a x-span selector tool with given settings.</p> <p>A x-span selector emits a SpanSelection object (tuple of start and end) when a span is drawn. A selection tool is constructed by specifying the canvas to attach the tool.</p> <p>canvas = new_canvas(\"matplotlib:qt\") tool = xspan_selector(canvas)</p> <p>Use <code>buttons</code> and <code>modifiers</code> to specify how to trigger the tool.</p> <p>tool = line_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>CanvasBase</code> <p>The canvas to which the tool is attached.</p> required <code>buttons</code> <code>MouseButton or Sequence[MouseButton]</code> <p>The mouse buttons that can trigger the tool.</p> <code>\"left\"</code> <code>modifiers</code> <code>Modifier or Sequence[Modifier]</code> <p>The modifier keys that must be pressed to trigger the tool.</p> <code>None</code> <code>tracking</code> <code>bool</code> <p>If True, the tool emits the changed signal while dragging. Otherwise, it emits the signal only when dragging is finished.</p> <code>False</code> Source code in <code>whitecanvas\\tools\\_selection.py</code> <pre><code>def xspan_selector(\n    canvas: CanvasBase,\n    buttons: _MouseButton | Sequence[_MouseButton] = \"left\",\n    modifiers: _Modifier | Sequence[_Modifier] | None = None,\n    *,\n    tracking: bool = False,\n) -&gt; XSpanSelectionTool:\n    \"\"\"\n    Create a x-span selector tool with given settings.\n\n    A x-span selector emits a SpanSelection object (tuple of start and end) when a span\n    is drawn.\n    A selection tool is constructed by specifying the canvas to attach the tool.\n\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib:qt\")\n    &gt;&gt;&gt; tool = xspan_selector(canvas)\n\n    Use `buttons` and `modifiers` to specify how to trigger the tool.\n\n    &gt;&gt;&gt; tool = line_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")\n\n    Parameters\n    ----------\n    canvas : CanvasBase\n        The canvas to which the tool is attached.\n    buttons : MouseButton or Sequence[MouseButton], default \"left\"\n        The mouse buttons that can trigger the tool.\n    modifiers : Modifier or Sequence[Modifier], optional\n        The modifier keys that must be pressed to trigger the tool.\n    tracking : bool, default False\n        If True, the tool emits the changed signal while dragging. Otherwise, it emits\n        the signal only when dragging is finished.\n    \"\"\"\n    _buttons, _modifiers = _norm_input(buttons, modifiers)\n    return XSpanSelectionTool(canvas, _buttons, _modifiers, tracking=tracking)\n</code></pre>"},{"location":"api/tools/#whitecanvas.tools.yspan_selector","title":"<code>yspan_selector(canvas, buttons='left', modifiers=None, *, tracking=False)</code>","text":"<p>Create a line selector tool with given settings.</p> <p>A y-span selector emits a SpanSelection object (tuple of start and end) when a span is drawn. A selection tool is constructed by specifying the canvas to attach the tool.</p> <p>canvas = new_canvas(\"matplotlib:qt\") tool = yspan_selector(canvas)</p> <p>Use <code>buttons</code> and <code>modifiers</code> to specify how to trigger the tool.</p> <p>tool = line_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>CanvasBase</code> <p>The canvas to which the tool is attached.</p> required <code>buttons</code> <code>MouseButton or Sequence[MouseButton]</code> <p>The mouse buttons that can trigger the tool.</p> <code>\"left\"</code> <code>modifiers</code> <code>Modifier or Sequence[Modifier]</code> <p>The modifier keys that must be pressed to trigger the tool.</p> <code>None</code> <code>tracking</code> <code>bool</code> <p>If True, the tool emits the changed signal while dragging. Otherwise, it emits the signal only when dragging is finished.</p> <code>False</code> Source code in <code>whitecanvas\\tools\\_selection.py</code> <pre><code>def yspan_selector(\n    canvas: CanvasBase,\n    buttons: _MouseButton | Sequence[_MouseButton] = \"left\",\n    modifiers: _Modifier | Sequence[_Modifier] | None = None,\n    *,\n    tracking: bool = False,\n) -&gt; YSpanSelectionTool:\n    \"\"\"\n    Create a line selector tool with given settings.\n\n    A y-span selector emits a SpanSelection object (tuple of start and end) when a span\n    is drawn.\n    A selection tool is constructed by specifying the canvas to attach the tool.\n\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib:qt\")\n    &gt;&gt;&gt; tool = yspan_selector(canvas)\n\n    Use `buttons` and `modifiers` to specify how to trigger the tool.\n\n    &gt;&gt;&gt; tool = line_selector(canvas, buttons=\"right\", modifiers=\"ctrl\")\n\n    Parameters\n    ----------\n    canvas : CanvasBase\n        The canvas to which the tool is attached.\n    buttons : MouseButton or Sequence[MouseButton], default \"left\"\n        The mouse buttons that can trigger the tool.\n    modifiers : Modifier or Sequence[Modifier], optional\n        The modifier keys that must be pressed to trigger the tool.\n    tracking : bool, default False\n        If True, the tool emits the changed signal while dragging. Otherwise, it emits\n        the signal only when dragging is finished.\n    \"\"\"\n    _buttons, _modifiers = _norm_input(buttons, modifiers)\n    return YSpanSelectionTool(canvas, _buttons, _modifiers, tracking=tracking)\n</code></pre>"},{"location":"api/types/","title":"whitecanvas.types","text":""},{"location":"api/types/#whitecanvas.types.Alignment","title":"<code>Alignment</code>","text":"Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class Alignment(_StrEnum):\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    CENTER = \"center\"\n    TOP_LEFT = \"top_left\"\n    TOP_RIGHT = \"top_right\"\n    BOTTOM_LEFT = \"bottom_left\"\n    BOTTOM_RIGHT = \"bottom_right\"\n\n    @classmethod\n    def merge(cls, vertical, horizontal: Alignment) -&gt; Alignment:\n        if vertical not in (Alignment.TOP, Alignment.BOTTOM, Alignment.CENTER):\n            raise ValueError(f\"{vertical} is not a vertical alignment\")\n        if horizontal not in (Alignment.LEFT, Alignment.RIGHT, Alignment.CENTER):\n            raise ValueError(f\"{horizontal} is not a horizontal alignment\")\n        if vertical is Alignment.TOP:\n            if horizontal is Alignment.LEFT:\n                return Alignment.TOP_LEFT\n            elif horizontal is Alignment.RIGHT:\n                return Alignment.TOP_RIGHT\n            elif horizontal is Alignment.CENTER:\n                return Alignment.TOP\n            else:\n                raise RuntimeError  # unreachable\n        elif vertical is Alignment.BOTTOM:\n            if horizontal is Alignment.LEFT:\n                return Alignment.BOTTOM_LEFT\n            elif horizontal is Alignment.RIGHT:\n                return Alignment.BOTTOM_RIGHT\n            elif horizontal is Alignment.CENTER:\n                return Alignment.BOTTOM\n            else:\n                raise RuntimeError  # unreachable\n        elif vertical is Alignment.CENTER:\n            return horizontal\n        else:\n            raise RuntimeError  # unreachable\n\n    def split(self) -&gt; tuple[Alignment, Alignment]:\n        \"\"\"Split the alignment into vertical and horizontal components.\"\"\"\n        name = self.name\n        if \"TOP\" in name:\n            vertical = Alignment.TOP\n        elif \"BOTTOM\" in name:\n            vertical = Alignment.BOTTOM\n        else:\n            vertical = Alignment.CENTER\n        if \"LEFT\" in name:\n            horizontal = Alignment.LEFT\n        elif \"RIGHT\" in name:\n            horizontal = Alignment.RIGHT\n        else:\n            horizontal = Alignment.CENTER\n        return vertical, horizontal\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Alignment.split","title":"<code>split()</code>","text":"<p>Split the alignment into vertical and horizontal components.</p> Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>def split(self) -&gt; tuple[Alignment, Alignment]:\n    \"\"\"Split the alignment into vertical and horizontal components.\"\"\"\n    name = self.name\n    if \"TOP\" in name:\n        vertical = Alignment.TOP\n    elif \"BOTTOM\" in name:\n        vertical = Alignment.BOTTOM\n    else:\n        vertical = Alignment.CENTER\n    if \"LEFT\" in name:\n        horizontal = Alignment.LEFT\n    elif \"RIGHT\" in name:\n        horizontal = Alignment.RIGHT\n    else:\n        horizontal = Alignment.CENTER\n    return vertical, horizontal\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Location","title":"<code>Location</code>","text":"Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class Location(_StrEnum):\n    TOP_CENTER = \"top_center\"\n    BOTTOM_CENTER = \"bottom_center\"\n    CENTER_LEFT = \"center_left\"\n    CENTER_RIGHT = \"center_right\"\n    CENTER = \"center\"\n    TOP_LEFT = \"top_left\"\n    TOP_RIGHT = \"top_right\"\n    BOTTOM_LEFT = \"bottom_left\"\n    BOTTOM_RIGHT = \"bottom_right\"\n    LEFT_SIDE_TOP = \"left_side_top\"\n    LEFT_SIDE_CENTER = \"left_side_center\"\n    LEFT_SIDE_BOTTOM = \"left_side_bottom\"\n    RIGHT_SIDE_TOP = \"right_side_top\"\n    RIGHT_SIDE_CENTER = \"right_side_center\"\n    RIGHT_SIDE_BOTTOM = \"right_side_bottom\"\n    TOP_SIDE_LEFT = \"top_side_left\"\n    TOP_SIDE_CENTER = \"top_side_center\"\n    TOP_SIDE_RIGHT = \"top_side_right\"\n    BOTTOM_SIDE_LEFT = \"bottom_side_left\"\n    BOTTOM_SIDE_CENTER = \"bottom_side_center\"\n    BOTTOM_SIDE_RIGHT = \"bottom_side_right\"\n\n    @property\n    def is_side(self) -&gt; bool:\n        \"\"\"True if the location is in any of the side locations.\"\"\"\n        return \"SIDE\" in self.name\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Location.is_side","title":"<code>is_side: bool</code>  <code>property</code>","text":"<p>True if the location is in any of the side locations.</p>"},{"location":"api/types/#whitecanvas.types.Modifier","title":"<code>Modifier</code>","text":"<p>Enum that represents the keyboard modifiers.</p> Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class Modifier(_StrEnum):\n    \"\"\"Enum that represents the keyboard modifiers.\"\"\"\n\n    SHIFT = \"shift\"\n    CTRL = \"ctrl\"\n    ALT = \"alt\"\n    META = \"meta\"\n</code></pre>"},{"location":"api/types/#whitecanvas.types.MouseButton","title":"<code>MouseButton</code>","text":"<p>Enum that represents the mouse buttons.</p> Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class MouseButton(_StrEnum):\n    \"\"\"Enum that represents the mouse buttons.\"\"\"\n\n    NONE = \"none\"\n    LEFT = \"left\"\n    MIDDLE = \"middle\"\n    RIGHT = \"right\"\n    BACK = \"back\"\n    FORWARD = \"forward\"\n</code></pre>"},{"location":"api/types/#whitecanvas.types.MouseEventType","title":"<code>MouseEventType</code>","text":"<p>Enum that represents the mouse event type.</p> Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class MouseEventType(_StrEnum):\n    \"\"\"Enum that represents the mouse event type.\"\"\"\n\n    MOVE = \"move\"\n    PRESS = \"press\"\n    RELEASE = \"release\"\n    DOUBLE_CLICK = \"double_click\"\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Orientation","title":"<code>Orientation</code>","text":"Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class Orientation(_StrEnum):\n    VERTICAL = \"vertical\"\n    HORIZONTAL = \"horizontal\"\n\n    @classmethod\n    def parse(cls, value):\n        if isinstance(value, str):\n            if value == \"v\":\n                return cls.VERTICAL\n            elif value == \"h\":\n                return cls.HORIZONTAL\n        return cls(value)\n\n    def transpose(self) -&gt; Orientation:\n        \"\"\"Transpose the orientation.\"\"\"\n        if self is self.VERTICAL:\n            return self.HORIZONTAL\n        else:\n            return self.VERTICAL\n\n    @property\n    def is_vertical(self):\n        return self is Orientation.VERTICAL\n\n    @property\n    def is_horizontal(self):\n        return self is Orientation.HORIZONTAL\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Orientation.transpose","title":"<code>transpose()</code>","text":"<p>Transpose the orientation.</p> Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>def transpose(self) -&gt; Orientation:\n    \"\"\"Transpose the orientation.\"\"\"\n    if self is self.VERTICAL:\n        return self.HORIZONTAL\n    else:\n        return self.VERTICAL\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Origin","title":"<code>Origin</code>","text":"<p>Enum that define the center of image.</p> <p>1-----+  0: corner |     |  1: edge |  0  |  2: center (center of image) |     | +-----+</p> Source code in <code>whitecanvas\\types\\_enums.py</code> <pre><code>class Origin(_StrEnum):\n    \"\"\"\n    Enum that define the center of image.\n\n    1-----+  0: corner\n    |     |  1: edge\n    |  0  |  2: center (center of image)\n    |     |\n    +-----+\n    \"\"\"\n\n    CORNER = \"corner\"\n    EDGE = \"edge\"\n    CENTER = \"center\"\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Rect","title":"<code>Rect</code>","text":"<p>Rectangular range in left, right, bottom, top order.</p> Source code in <code>whitecanvas\\types\\_tuples.py</code> <pre><code>class Rect(NamedTuple):\n    \"\"\"Rectangular range in left, right, bottom, top order.\"\"\"\n\n    left: float\n    right: float\n    bottom: float\n    top: float\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"Rect(left={self.left:.6g}, right={self.right:.6g}, \"\n            f\"bottom={self.bottom:.6g}, top={self.top:.6g})\"\n        )\n\n    @classmethod\n    def with_check(cls, left: float, right: float, bottom: float, top: float):\n        if left &gt; right:\n            raise ValueError(\"left must be less than or equal to right\")\n        if bottom &gt; top:\n            raise ValueError(\"bottom must be less than or equal to top\")\n        return cls(float(left), float(right), float(bottom), float(top))\n\n    @classmethod\n    def with_sort(cls, left: float, right: float, bottom: float, top: float):\n        left, right = sorted([left, right])\n        bottom, top = sorted([bottom, top])\n        return cls(float(left), float(right), float(bottom), float(top))\n\n    @property\n    def width(self) -&gt; float:\n        \"\"\"Width of the range.\"\"\"\n        return self.right - self.left\n\n    @property\n    def height(self) -&gt; float:\n        \"\"\"Height of the range.\"\"\"\n        return self.top - self.bottom\n\n    @property\n    def size(self) -&gt; tuple[float, float]:\n        \"\"\"Size (width, height) of the range.\"\"\"\n        return self.width, self.height\n\n    @property\n    def center(self) -&gt; tuple[float, float]:\n        \"\"\"Center of the range.\"\"\"\n        return (self.left + self.right) / 2, (self.top + self.bottom) / 2\n</code></pre>"},{"location":"api/types/#whitecanvas.types.Rect.center","title":"<code>center: tuple[float, float]</code>  <code>property</code>","text":"<p>Center of the range.</p>"},{"location":"api/types/#whitecanvas.types.Rect.height","title":"<code>height: float</code>  <code>property</code>","text":"<p>Height of the range.</p>"},{"location":"api/types/#whitecanvas.types.Rect.size","title":"<code>size: tuple[float, float]</code>  <code>property</code>","text":"<p>Size (width, height) of the range.</p>"},{"location":"api/types/#whitecanvas.types.Rect.width","title":"<code>width: float</code>  <code>property</code>","text":"<p>Width of the range.</p>"},{"location":"api/types/#whitecanvas.types.XYData","title":"<code>XYData</code>","text":"<p>Tuple of x and y array.</p> <p>Used for data of Line, Markers etc.</p> Source code in <code>whitecanvas\\types\\_tuples.py</code> <pre><code>class XYData(NamedTuple):\n    \"\"\"\n    Tuple of x and y array.\n\n    Used for data of Line, Markers etc.\n    \"\"\"\n\n    x: NDArray[np.floating]\n    y: NDArray[np.floating]\n\n    def stack(self) -&gt; NDArray[np.floating]:\n        \"\"\"Data as a stacked (N, 2) array.\"\"\"\n        return np.stack([self.x, self.y], axis=1)\n</code></pre>"},{"location":"api/types/#whitecanvas.types.XYData.stack","title":"<code>stack()</code>","text":"<p>Data as a stacked (N, 2) array.</p> Source code in <code>whitecanvas\\types\\_tuples.py</code> <pre><code>def stack(self) -&gt; NDArray[np.floating]:\n    \"\"\"Data as a stacked (N, 2) array.\"\"\"\n    return np.stack([self.x, self.y], axis=1)\n</code></pre>"},{"location":"api/types/#whitecanvas.types.XYYData","title":"<code>XYYData</code>","text":"<p>Tuple of x, y0, and y1 array.</p> <p>Used for data of Bars, Errorbars etc.</p> Source code in <code>whitecanvas\\types\\_tuples.py</code> <pre><code>class XYYData(NamedTuple):\n    \"\"\"\n    Tuple of x, y0, and y1 array.\n\n    Used for data of Bars, Errorbars etc.\n    \"\"\"\n\n    x: NDArray[np.floating]\n    y0: NDArray[np.floating]\n    y1: NDArray[np.floating]\n\n    @property\n    def ycenter(self) -&gt; NDArray[np.floating]:\n        return (self.y0 + self.y1) / 2\n\n    @property\n    def ydiff(self) -&gt; NDArray[np.floating]:\n        return self.y1 - self.y0\n</code></pre>"},{"location":"canvas/","title":"Canvas","text":"<ul> <li>Basics</li> <li>Namespaces</li> <li>Canvas Grid</li> <li>Legend</li> <li>Inset and Secondary Axis</li> <li>Working with the Backend Objects</li> </ul>"},{"location":"canvas/basics/","title":"Basics","text":"<p>In <code>whitecanvas</code>, a \"canvas\" is an object with a layer list, axes elements, labels and methods to handle them. A \"grid\" is a collection of canvases and is implemented with rendering backends.</p>"},{"location":"canvas/basics/#create-canvases","title":"Create Canvases","text":"<p>Canvas is created by <code>new_canvas</code> method.</p> <ul> <li><code>backend</code>: the name of the backend to use.</li> <li><code>size</code>: the size of the canvas (width \u00d7 height in pixels).</li> <li><code>palette</code>: the name of the color palette to use. Any input that is accepted by the   cmap.Colormap can be used,   which includes:</li> <li>The name of the built-in colormaps, such as \"viridis\", \"plasma\", etc.</li> <li>Sequence of colors, such as <code>[\"red\", \"green\", \"blue\"]</code>.</li> <li>A <code>cmap.Colormap</code> object.</li> </ul> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\", size=(400, 300), palette=\"tab10\")\n</code></pre> <p>A <code>SingleCanvas</code> object is returned. It can be considered as a mixture of a canvas and a grid. All of the functions mentioned above are implemented in this object. Therefore, you can show the canvas by calling the <code>show</code> method.</p> <pre><code>canvas.show()  # show the canvas, depending on the backend\n</code></pre>"},{"location":"canvas/basics/#namespaces","title":"Namespaces","text":"<p>To make the API tidy, each element of a canvas is organized in namespaces. By using namespaces, we can avoid the long list of arguments and make the code more readable. For example, the x-limit of the canvas is controlled by the property <code>canvas.x.lim</code>.</p> <p>Following list shows the namespaces and the properties associated with them.</p> <ul> <li> <p><code>canvas.{x, y}</code>: the x/y-axis.</p> <ul> <li>(property) <code>canvas.{x, y}.lim</code>: the x/y-limit as a tuple of floats.</li> <li>(property) <code>canvas.{x, y}.color</code>: the color of the x/y-axis.</li> <li>(property) <code>canvas.{x, y}.flipped</code>: whether the x/y-axis is flipped.</li> <li><code>canvas.{x, y}.label</code>: the x/y-axis label.<ul> <li>(property) <code>canvas.{x, y}.label.text</code>: the text of the label.</li> <li>(property) <code>canvas.{x, y}.label.color</code>: the color of the label as <code>ndarray</code>.</li> <li>(property) <code>canvas.{x, y}.label.size</code>: the font size of the label.</li> <li>(property) <code>canvas.{x, y}.label.family</code>: the font family of the label.</li> <li>(property) <code>canvas.{x, y}.label.visible</code>: the visibility of the label.</li> </ul> </li> <li><code>canvas.{x, y}.ticks</code>: the x/y-axis ticks.<ul> <li>(property) <code>canvas.{x, y}.ticks.pos</code>: the position of the ticks (read-only).</li> <li>(property) <code>canvas.{x, y}.ticks.labels</code>: the labels of the ticks (read-only).</li> <li>(property) <code>canvas.{x, y}.ticks.color</code>: the color of the ticks.</li> <li>(property) <code>canvas.{x, y}.ticks.size</code>: the size of the ticks.</li> <li>(property) <code>canvas.{x, y}.ticks.rotation</code>: the color of the tick labels.</li> <li>(property) <code>canvas.{x, y}.ticks.visible</code>: the visibility of the ticks.</li> </ul> </li> </ul> </li> <li> <p><code>canvas.title</code>: the title object of the canvas.</p> <ul> <li>(property) <code>canvas.title.text</code>: the text of the title.</li> <li>(property) <code>canvas.title.color</code>: the color of the title as <code>ndarray</code>.</li> <li>(property) <code>canvas.title.size</code>: the font size of the title.</li> <li>(property) <code>canvas.title.family</code>: the font family of the title.</li> <li>(property) <code>canvas.title.visible</code>: the visibility of the title.</li> </ul> </li> </ul> <p>Note</p> <p><code>canvas.title</code>, <code>canvas.{x, y}.label</code> and <code>canvas.{x, y}.ticks</code> share the same properties (<code>color</code>, <code>size</code>, <code>family</code> and <code>visible</code>) related to the text design.</p> <p>Event handlers are also organized in namespaces. At any level, the value-changed event for the parameter <code>X</code> is in <code>events.X</code>. For example, when the x-limit is changed, signal will be emitted from <code>canvas.x.events.lim</code>. See Event Handling for more details.</p>"},{"location":"canvas/basics/#update-canvas-appearance","title":"Update Canvas Appearance","text":"<p>Canvases have helper functions of name <code>update_*</code> to update the appearance. They return the canvas itself, so that you can chain the methods after the constructor.</p> <pre><code># update the color of x/y-axis\ncanvas = new_canvas().update_axes(color=\"gray\")\n\n# update the text labels\ncanvas = new_canvas().update_labels(x=\"time\", y=\"value\", title=\"My Plot\")\n</code></pre>"},{"location":"canvas/basics/#add-layers","title":"Add Layers","text":"<p>All the plotting elements are added to the canvas as a \"layer\". In <code>whitecanvas</code>, a layer is rarely constructed directly, but is returned by the <code>add_*</code> methods. Same method always returns the same type of layer.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nline = canvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\nmarkers = canvas.add_markers([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.show()\n</code></pre> </p> <p>See Layers for more details.</p>"},{"location":"canvas/grid/","title":"Canvas Grid","text":"<p>A \"canvas grid\" is a grid of canvases (which is called \"figure\" in <code>matplotlib</code>). A grid is composed of multiple canvas objects, so that grid itself does not have either layers or the <code>add_*</code> methods.</p> <p>Once a grid is created, you can add chid canvases using the <code>add_canvas</code> method, or fill the grid with canvases using the <code>fill</code> method. The signature of the method differs between 1D and 2D grid.</p>"},{"location":"canvas/grid/#verticalhorizontal-grid","title":"Vertical/Horizontal Grid","text":"<p>This is an example of a grid with a single column, and the canvases are added one by one.</p> <p><pre><code>from whitecanvas import new_col\n\ngrid = new_col(3, backend=\"matplotlib\")\n\nc0 = grid.add_canvas(0)\nc0.add_text(0, 0, \"Canvas 0\")\nc1 = grid.add_canvas(1)\nc1.add_text(0, 0, \"Canvas 1\")\nc2 = grid.add_canvas(2)\nc2.add_text(0, 0, \"Canvas 2\")\ngrid.show()\n</code></pre> </p> <p>This is an example of a grid with a single row, and the canvases are added at once.</p> <p><pre><code>from whitecanvas import new_row\n\ngrid = new_row(3, backend=\"matplotlib\").fill()\n\ngrid[0].add_text(0, 0, \"Canvas 0\")\ngrid[1].add_text(0, 0, \"Canvas 1\")\ngrid[2].add_text(0, 0, \"Canvas 2\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/grid/#2d-grid","title":"2D Grid","text":"<p>The <code>new_grid</code> function creates a 2D grid. Since it is a 2D grid, you need to specify two integers for the number of rows and columns.</p> <p><pre><code>from whitecanvas import new_grid\n\ngrid = new_grid(2, 2, backend=\"matplotlib\")\n\nfor i, j in [(0, 0), (0, 1), (1, 0), (1, 1)]:\n    c = grid.add_canvas(i, j)\n    c.add_text(0, 0, f\"Canvas ({i}, {j})\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/grid/#non-uniform-grid","title":"Non-uniform Grid","text":"<p>If a sequence of integers are given, the grid will be non-uniform.</p> <p>Note</p> <p>This feature is work in progress. Some backends does not support it yet.</p> <p><pre><code>from whitecanvas import new_grid\n\ngrid = new_grid([1, 2], [2, 1], backend=\"matplotlib\")\n\nfor i, j in [(0, 0), (0, 1), (1, 0), (1, 1)]:\n    c = grid.add_canvas(i, j)\n    c.add_text(0, 0, f\"Canvas ({i}, {j})\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/inset_second/","title":"Inset and Secondary Axis","text":"<p>Adding inset plot and/or secondary axis to the main plot are useful ways to display different types of data in the same context. <code>whitecanvas</code> provides a very simple way to add these types of plot elements.</p> <p>Currently, this feature is implemented as follows:</p> Feature <code>matplotlib</code> <code>plotly</code> <code>bokeh</code> <code>pyqtgraph</code> <code>vispy</code> Inset \u2713 \u2717 \u2717 \u2713 \u2717 Secondary X \u2713 \u2717 \u2713 \u2713 \u2717 Secondary Y \u2713 \u2713 \u2713 \u2713 \u2717"},{"location":"canvas/inset_second/#inset-plot","title":"Inset Plot","text":"<p>Inset plot is a smaller plot that is embedded within the main plot. <code>install_inset</code> method installs an inset plot to the main plot. A new canvas pointing at the inset plot is returned.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ninset = canvas.install_inset(left=0.5, right=0.9, bottom=0.5, top=0.9)\n\n# data with small bump\nx = np.linspace(0, 1, 100)\ny = np.exp(-x * 3)\ny[64] += 0.01\n\ncanvas.add_line(x, y, color=\"red\")\ncanvas.title.text = \"All Data\"\n\ninset.add_line(x[60:70], y[60:70], color=\"red\")\ninset.title.text = \"Zoomed-in View\"\n\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/inset_second/#secondary-axis","title":"Secondary Axis","text":"<p>Secondary axis is another axis that is added to the main plot. <code>install_second_x</code> and <code>install_second_y</code> methods install secondary x/y-axis, respectively.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nother = canvas.install_second_y()\n\ntemperature = [26, 26, 27, 28, 29, 28, 26, 24, 25]\nrainfall = [10, 12, 15, 20, 25, 20, 15, 10, 5]\n\ncanvas.add_line(temperature, color=\"red\").with_markers(symbol=\"D\")\ncanvas.y.lim = (10, 32)\ncanvas.y.label.text = \"Temperature ($^\\circ$C)\"\n\nother.add_bars(rainfall, color=\"skyblue\")\nother.y.lim = (0, 40)\nother.y.label.text = \"Rainfall (mm)\"\n\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/joint_grid/","title":"Joint Plot","text":"<p>A joint plot is a plot that combines a main plot and two marginal plots. The main plot is usually a scatter plot, and the marginal plots are layers of histograms, KDE or rug plot.</p> <p><code>whitecanvas</code> provides a canvas grid class that is specifically designed for creating joint plots. It can be constructed using the <code>new_jointgrid</code> function.</p> <p><pre><code>from whitecanvas import new_jointgrid\n\ngrid = new_jointgrid(backend=\"matplotlib\")\ngrid.show()\n</code></pre> </p> <p>The layout of the joint grid can be customized using the <code>loc</code> argument. It indicates the indices of the main canvas. The default value is <code>(1, 0)</code>.</p> <p><pre><code>from whitecanvas import new_jointgrid\n\ngrid = new_jointgrid(backend=\"matplotlib\", loc=(0, 0))\ngrid.show()\n</code></pre> </p> <p>A good thing is that three canvases can be accessed using <code>main_canvas</code>, <code>x_canvas</code> and <code>y_canvas</code> no matter what the layout is.</p> <p><pre><code>grid.main_canvas.add_text(0, 0, \"this is the\\nmain canvas\", anchor=\"center\")\ngrid.x_canvas.add_text(0, 0, \"this is\\nthe x\\nmarginal\\ncanvas\", anchor=\"center\")\ngrid.y_canvas.add_text(0, 0, \"this is\\nthe y\\nmarginal\\ncanvas\", anchor=\"center\")\n</code></pre> </p>"},{"location":"canvas/joint_grid/#plotting-data-on-the-joint-grid","title":"Plotting Data on the Joint Grid","text":"<p>Joint grid provides methods to plot the 2D distribution on the main canvas and the marginal distributions on the marginal canvases.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_jointgrid\n\n# sample data\nnp.random.seed(123456)\ndata = np.concatenate([\n    np.random.normal(loc=(0, 0), scale=(1, 1), size=(30, 2)),\n    np.random.normal(loc=(8, 7), scale=(1, 1), size=(60, 2)),\n    np.random.normal(loc=(6, 1), scale=(1, 1), size=(40, 2)),\n], axis=0)\n\ngrid = new_jointgrid(backend=\"matplotlib\")\ngrid.add_markers(data[:, 0], data[:, 1])\ngrid.show()\n</code></pre> </p> <p>Joint grid uses histograms to visualize the marginal distributions by default. You can change the type of the marginal plots using <code>with_*</code> methods on construction.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_jointgrid\n\n# sample data\nnp.random.seed(123456)\ndata = np.concatenate([\n    np.random.normal(loc=(0, 0), scale=(1, 1), size=(30, 2)),\n    np.random.normal(loc=(8, 7), scale=(1, 1), size=(60, 2)),\n    np.random.normal(loc=(6, 1), scale=(1, 1), size=(40, 2)),\n], axis=0)\n\n# create a joint grid with customized marginal plots\ngrid = (\n    new_jointgrid(backend=\"matplotlib\")\n    .with_hist_x(shape=\"step\")  # show histogram as the x-marginal distribution\n    .with_kde_y(width=2)  # show kde as the y-marginal distribution\n    .with_rug(width=1)  # show rug plot for both marginal distributions\n)\n\ngrid.add_markers(data[:, 0], data[:, 1])\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/joint_grid/#categorical-plots-on-joint-grid","title":"Categorical Plots on Joint Grid","text":"<p><code>whitecanvas</code> has a flexible API for creating categorical plots. With the similar API, you can create a joint grid similarly. Here, we use the same data as here.</p> <p><pre><code>from whitecanvas import new_canvas\n\n# sample data\ndata = np.concatenate([\n    np.random.normal(loc=(0, 0), scale=(1, 1), size=(30, 2)),\n    np.random.normal(loc=(3, 3), scale=(1, 1), size=(60, 2)),\n    np.random.normal(loc=(2, 1), scale=(1, 1), size=(40, 2)),\n], axis=0)\ndf = {\n    \"x\": data[:, 0],\n    \"y\": data[:, 1],\n    \"label\": np.repeat([\"A\", \"B\", \"C\"], [30, 60, 40]),\n}\n\ngrid = (\n    new_jointgrid(backend=\"matplotlib\")\n    .with_kde()\n    .with_rug()\n)\ngrid.cat(df, \"x\", \"y\").add_markers(color=\"label\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/legend/","title":"Legend for the Layers","text":"<p>Legend is an important component for data visualization. In <code>whitecanvas</code>, you can automatically or manually create legends independent of the backend you are using.</p> <p>Note</p> <p>The legend is not supported in the <code>vispy</code> backend.</p> <p>To create a legend, you can use the <code>add_legend</code> method. The layer names are used as the labels of the legend.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nx = np.linspace(-1, 1, 100)\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line(x, x, name=\"y=x\", color=\"gray\")\ncanvas.add_line(x, x**2, name=\"y=x^2\", color=\"blue\")\ncanvas.add_line(x, x**3, name=\"y=x^3\", color=\"red\", style=\"--\")\n\ncanvas.add_legend()\ncanvas.show()\n</code></pre> </p> <p>You can explicitly specify the layers to be included in the legend. If a <code>str</code> is given, it is interpreted as the title.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nx = np.linspace(-1, 1, 100)\ncanvas = new_canvas(backend=\"matplotlib\")\nx1 = canvas.add_line(x, x, name=\"y=x\", color=\"gray\")\nx2 = canvas.add_line(x, x**2, name=\"y=x^2\", color=\"blue\")\nx3 = canvas.add_line(x, x**3, name=\"y=x^3\", color=\"red\", style=\"--\")\n\ncanvas.add_legend([\"odd functions\", x1, x3])\ncanvas.show()\n</code></pre> </p> <p>Legend location can be specified by the <code>location</code> argument.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nx = np.linspace(-1, 1, 100)\ncanvas = new_canvas(backend=\"matplotlib\")\nx1 = canvas.add_line(x, x, name=\"y=x\", color=\"gray\")\nx2 = canvas.add_line(x, x**2, name=\"y=x^2\", color=\"blue\")\nx3 = canvas.add_line(x, x**3, name=\"y=x^3\", color=\"red\", style=\"--\")\n\ncanvas.add_legend(location=\"right_side_top\")\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/","title":"Namespaces","text":"<p>Each canvas has several namespaces to control the appearance of the canvas. First of all, the x/y-axis properties are controlled by the <code>x</code> and <code>y</code> namespaces.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\n\ncanvas.x.lim = (0, 10)\ncanvas.x.color = \"red\"\ncanvas.x.flipped = True\ncanvas.x.set_gridlines(color=\"gray\", width=1, style=\":\")\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/#labels","title":"Labels","text":"<p>You can set x/y labels using the <code>label</code> property.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.label = \"X axis\"\ncanvas.y.label = \"Y axis\"\ncanvas.show()\n</code></pre> </p> <p>The <code>label</code> property is actually another namespace. You can specify the text, font size, etc. separately.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\ncanvas.x.label.text = \"X axis\"\ncanvas.x.label.size = 20\ncanvas.x.label.family = \"Arial\"\ncanvas.x.label.color = \"red\"\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/#ticks","title":"Ticks","text":"<p>The tick properties can be set via <code>ticks</code> property.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.ticks.color = \"red\"\ncanvas.x.ticks.size = 12\ncanvas.x.ticks.family = \"Arial\"\ncanvas.x.ticks.rotation = 45\ncanvas.show()\n</code></pre> </p> <p>You can also override or reset the tick labels.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.ticks.set_labels([0, 1, 2], [\"zero\", \"one\", \"two\"])\ncanvas.x.ticks.reset_labels()\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/#title","title":"Title","text":"<p>Canvas title can be set via the <code>title</code> namespace.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.title.color = \"teal\"\ncanvas.title.size = 16\ncanvas.title.family = \"Times New Roman\"\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/native_objects/","title":"Working with the Backend Objects","text":""},{"location":"canvas/native_objects/#convert-a-backend-object-to-whitecanvas-canvas","title":"Convert a backend object to <code>whitecanvas</code> canvas","text":"<p>The <code>wrap_canvas</code> converts a backend object to a <code>whitecanvas</code> canvas.</p> <pre><code>from whitecanvas import wrap_canvas\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots()\naxes.set_title(\"Title\")  # operations in the backend side\n\ncanvas = wrap_canvas(axes)  # axes --&gt; canvas\ncanvas.add_line([0, 1, 2, 3, 4])\n\nplt.show()  # backend methods still work\n</code></pre>"},{"location":"canvas/native_objects/#retrieve-the-backend-object-from-a-whitecanvas-canvas","title":"Retrieve the backend object from a <code>whitecanvas</code> canvas","text":"<p>The backend object is available at the <code>native</code> property.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.native\n</code></pre> Output<pre><code>&lt;Axes: &gt;\n</code></pre>"},{"location":"canvas/native_objects/#combine-whitecanvas-with-applications","title":"Combine <code>whitecanvas</code> with Applications","text":""},{"location":"canvas/native_objects/#1-control-matplotlib-qt-application-with-whitecanvas","title":"1. Control <code>matplotlib</code> Qt application with <code>whitecanvas</code>","text":"<pre><code>#!skip\n# use `%gui qt` in IPython\nfrom whitecanvas import new_canvas\nimport matplotlib.pyplot as plt\nfrom qtpy import QtWidgets as QtW\n\ncanvas = new_canvas(\"matplotlib:qt\")\nqt_canvas = canvas.native.get_figure().canvas\n\nmain = QtW.QMainWindow()\nmain.setWindowTitle(\"myapp\")\nmain.setCentralWidget(qt_canvas)\nmain.show()\n</code></pre> <p>Since the <code>canvas</code> points to the same canvas as in the Qt application, you can control the application with <code>whitecanvas</code> API.</p> <pre><code>canvas.add_line([0, 1, 2, 3, 4])\n</code></pre>"},{"location":"categorical/","title":"Categorical Plot","text":"<p>Existing Python plotting libraries such as <code>seaborn</code> and <code>plotly</code> have an excellent support for high-level categorical plotting methods that use DataFrame objects as input.</p> <p>In <code>whitecanvas</code>, similar functions are provided, but these methods do not depend on any external plotting libraries or DataFrames, and are more flexible in some cases.</p>"},{"location":"categorical/#the-categorical-plotters","title":"The Categorical Plotters","text":"<p>Methods starting with \"cat\" return categorical plotters. Methods include:</p> <ul> <li><code>cat</code> ... plotter for numerical data in x/y-axis categorized by such as color \u2192   Numerical \u00d7 Numerical Data.</li> <li><code>cat_x</code> ... plotter for categorical data in x-axis \u2192   Categorical \u00d7 Numerical Data.</li> <li><code>cat_y</code> ... plotter for categorical data in y-axis \u2192   Categorical \u00d7 Numerical Data.</li> <li><code>cat_xy</code> ... plotter for categorical data in both x- and y-axis \u2192   Categorical \u00d7 Categorical Data.</li> </ul> <p>These methods need a tabular data and the names of the columns that will be used as the x and y values. Currently, following objects are allowed as the tabular data input:</p> <ul> <li><code>dict</code> of array-like objects</li> <li><code>pandas.DataFrame</code></li> <li><code>polars.DataFrame</code></li> </ul> <p>Following example shows how to make a strip plot.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nrng = np.random.default_rng(12345)\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"value\": rng.normal(size=130),\n}\n\ncanvas.cat_x(df, x=\"label\", y=\"value\").add_stripplot().with_edge(color=\"black\")\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/aggregation/","title":"Aggregation","text":"<p>Showing the aggregated data is a common way to efficiently visualize a lot of data. This task is usually done by the module specific group-by methods, but <code>whitecanvas</code> provides a built-in method to simplify the process.</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nrng = np.random.default_rng(12345)\ndf = {\n    \"category\": [\"A\"] * 40 + [\"B\"] * 50,\n    \"observation\": np.concatenate([rng.random(40), rng.random(50) + 1.3]),\n    \"replicate\": [0] * 23 + [1] * 17 + [0] * 22 + [1] * 28,\n    \"temperature\": rng.normal(scale=2.8, size=90) + 22.0,\n}\n</code></pre> <p>In following example, <code>mean()</code> is used to prepare a mean-aggregated plotter, which has <code>add_markers</code> method to add the mean markers to the plotter.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create a categorical plotter\ncat_plt = canvas.cat_x(df, x=\"category\", y=\"observation\")\n\n# plot all the data\ncat_plt.add_stripplot(color=\"category\")\n# plot the mean\ncat_plt.mean().add_markers(color=\"category\", size=20)\n\ncanvas.show()\n</code></pre> </p> <p>Similar <code>add_*</code> methods include <code>add_line()</code> and <code>add_bars()</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create a categorical plotter\ncat_plt = canvas.cat_x(df, x=\"category\", y=\"observation\")\n\n# plot all the data\ncat_plt.add_stripplot(color=\"category\")\n# plot the mean\ncat_plt.mean().add_line(width=3, color=\"black\")\n\ncanvas.show()\n</code></pre> </p> <p>Count plot is a special case of the aggregation. Use <code>count()</code> to make the plotter.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\")\n    .count()\n    .add_bars(color=\"replicate\", dodge=True)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_cat/","title":"Categorical \u00d7 Categorical Data","text":"<p>Here is an example of a data frame with two categorical columns.</p> <pre><code>import numpy as np\n\n# sample data\nrng = np.random.default_rng(12345)\n\ndf = {\n    \"x\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"y\": [\"X\"] * 70 + [\"Y\"] * 60,\n    \"value\": rng.normal(size=130),\n}\n</code></pre> <p>To use categorical columns for both x- and y-axis, aggregation is required. The most basic way to visualize the data is to use a heatmap.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.cat_xy(df, x=\"x\", y=\"y\").mean().add_heatmap(\"value\")\n</code></pre> </p> <p>You can also visualize the data using marker sizes.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.cat_xy(df, x=\"x\", y=\"y\").mean().add_markers(\"value\")\n</code></pre> </p>"},{"location":"categorical/cat_num/","title":"Categorical \u00d7 Numerical Data","text":"<p>In this section, following data will be used as an example:</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nrng = np.random.default_rng(3)\ndf = {\n    \"category\": [\"A\"] * 40 + [\"B\"] * 50,\n    \"observation\": np.concatenate([rng.normal(2.0, size=40), rng.normal(3.3, size=50)]),\n    \"replicate\": [0] * 23 + [1] * 17 + [0] * 22 + [1] * 28,\n    \"temperature\": rng.normal(scale=2.8, size=90) + 22.0,\n}\n</code></pre> <p>How can we visualize the distributions for each category? There are several plots that use categorical axis as either the x- or y-axis, and numerical axis as the other. Examples are:</p> <ul> <li>Strip plot</li> <li>Swarm plot</li> <li>Violin plot</li> <li>Box plot</li> </ul> <p>Aside from the categorical axis, data points may further be grouped by other features, such as the marker symbol and the marker size. Things are even more complicated when the markers represent numerical values, such as their size being proportional to the value, or colored by a colormap.</p> <p><code>whitecanvas</code> provides a consistent and simple interface to handle all these cases. Methods used for this purpose are <code>cat_x</code> and <code>cat_y</code>, where <code>cat_x</code> will deem the x-axis as categorical, and <code>cat_y</code> will do the same for the y-axis.</p> <pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create the categorical plotter.\ncat_plt_x = canvas.cat_x(df, x=\"category\", y=\"observation\")\ncat_plt_y = canvas.cat_y(df, x=\"observation\", y=\"category\")\n</code></pre> <p><code>cat_x</code> and <code>cat_y</code> use the argument <code>x=</code> and <code>y=</code> to specify the columns that are used for the plot, where <code>x=</code> is the categorical axis for <code>cat_x</code> and <code>y=</code> for <code>cat_y</code>.</p> <pre><code>This is one of the important difference between `seaborn`. In `seaborn`, `orient` are\nused to specify the orientation of the plots. This design forces the user to add the\nargument `orient=` to every plot even though the orientation rarely changes during the\nuse of the same figure. In `whitecanvas`, you don't have to specify the orientation\nonce a categorical plotter is created by either `cat_x` or `cat_y`.\n</code></pre> <p>Multiplt columns can be used for the categorical axis, but only one column can be used for the numerical axis.</p> <pre><code># OK\ncanvas.cat_x(df, x=[\"category\", \"replicate\"], y=\"observation\")\n# OK\ncanvas.cat_y(df, x=\"observation\", y=[\"category\", \"replicate\"])\n# NG\ncanvas.cat_x(df, x=\"category\", y=[\"observation\", \"temperature\"])\n</code></pre>"},{"location":"categorical/cat_num/#non-marker-type-plots","title":"Non-marker-type Plots","text":"<p>Since plots without data point markers are more straightforward, we will start with them. It includes <code>add_violinplot</code>, <code>add_boxplot</code>, <code>add_pointplot</code> and <code>add_barplot</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat_x(df, x=\"category\", y=\"observation\").add_violinplot()\ncanvas.show()\n</code></pre> </p> <p>Violins can also be shown in different color. Specify the <code>color=</code> argument to do that.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p>By default, groups with different colors do not overlap. This is controlled by the <code>dodge=</code> argument. Set <code>dodge=False</code> to make them overlap (although it is not the way we usually do).</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\", dodge=False)\n)\ncanvas.show()\n</code></pre> </p> <p><code>hatch=</code> can also be specified in a similar way. It will change the hatch pattern of the violins.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(hatch=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p><code>color</code> and <code>hatch</code> can overlap with each other or the <code>x=</code> or <code>y=</code> argument.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"category\")\n)\ncanvas.show()\n</code></pre> </p> <p>The color palette of the canvas is used to paint categories. If you want to change it after the layer is added, use <code>update_color_palette</code> method.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .update_color_palette([\"pink\", \"teal\"])\n)\ncanvas.show()\n</code></pre> </p> <p><code>add_boxplot</code>, <code>add_pointplot</code> and <code>add_barplot</code> is very similar to <code>add_violinplot</code>.</p> <p><pre><code>from whitecanvas import new_row\n\ncanvas = new_row(3, size=(1600, 600), backend=\"matplotlib\")\n\nc0 = canvas.add_canvas(0)\nc0.cat_x(df, x=\"category\", y=\"observation\").add_boxplot()\nc0.title = \"boxplot\"\n\nc1 = canvas.add_canvas(1)\nc1.cat_x(df, x=\"category\", y=\"observation\").add_pointplot()\nc1.title = \"pointplot\"\n\nc2 = canvas.add_canvas(2)\nc2.cat_x(df, x=\"category\", y=\"observation\").add_barplot()\nc2.title = \"barplot\"\n\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#marker-type-plots","title":"Marker-type Plots","text":"<p>Marker-type plots use a marker to represent each data point.</p>"},{"location":"categorical/cat_num/#strip-plot","title":"Strip plot","text":"<p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n)\ncanvas.show()\n</code></pre> </p> <p>As for the <code>Markers</code> layer, <code>as_edge_only</code> will convert the face features to the edge features.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n    .as_edge_only(width=2)\n)\ncanvas.show()\n</code></pre> </p> <p><code>with_hover_template</code> is also defined. All the column names can be used in the template format string.</p> <pre><code>canvas = new_canvas(\"plotly\", size=(400, 300))\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n    .with_hover_template(\"{category} (rep={replicate})\")\n)\ncanvas.show()\n</code></pre> <p>Each marker size can represent a numerical value. <code>update_size</code> will map the numerical values of a column to the size of the markers.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot()\n    .update_size(\"temperature\")\n)\ncanvas.show()\n</code></pre> </p> <p>Similarly, each marker color can represent a numerical value. <code>update_colormap</code> will map the value with an arbitrary colormap.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot()\n    .update_colormap(\"temperature\", cmap=\"coolwarm\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#swarm-plot","title":"Swarm plot","text":"<p>Swarm plot (or beeswarm plot) is another way to visualize all the data points with markers. In swarm plot, the outline of the markers represents the distribution of the data.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_swarmplot(sort=True)\n    .update_colormap(\"temperature\", cmap=\"coolwarm\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#rug-plot","title":"Rug plot","text":"<p>Although rug plot does not directly use markers, it also use a line to represent each data point.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_rugplot(color=\"replicate\", dodge=True)\n)\ncanvas.show()\n</code></pre> </p> <p>Some methods defined for marker-type plots can also be used for rug plot. For example, <code>update_colormap</code> will change the color of the rug lines based on the values of the specified column.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_rugplot()\n    .update_colormap(\"temperature\", cmap=\"coolwarm\")\n)\ncanvas.show()\n</code></pre> </p> <p><code>scale_by_density</code> will change the length of the rugs to represent the density of the data points.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_rugplot(color=\"replicate\", dodge=True)\n    .scale_by_density()\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#overlaying-plots","title":"Overlaying Plots","text":"<p>Different types of plots have their own strengths and weaknesses. To make the plot more informative, it is often necessary to overlay different types of plots.</p> <p>You can simply call different methds to overlay different types of plots, but in some cases it is not that easy. For example, to add rug plot to violin plot, you have to correctly set the lengths of the rug lines so that their edges exactly match the edges of the violins.</p> <p>Some types of plots are implemented with methods to efficiently overlay them with other plots. All of them use method chaining so that the API is very clean.</p>"},{"location":"categorical/cat_num/#rug-plot-over-violin-plot","title":"Rug plot over violin plot","text":"<p>Violin plot can be overlaid with rug plot using <code>with_rug</code> method. Edges of the rug lines match exactly with the edges of the violins. Of cource, you can hover over the rug lines to see the details.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .with_rug(color=\"purple\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#box-plot-over-violin-plot","title":"Box plot over violin plot","text":"<p>Violin plot can be overlaid with box plot using <code>with_box</code> method. Color of the box plot follows the convention of other plotting softwares by default.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .with_box(width=2.0, extent=0.05)\n)\ncanvas.show()\n</code></pre> </p> <p>If the violins are edge only, the box plot will be filled with the same color.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .as_edge_only()\n    .with_box(width=2.0, extent=0.05)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#markers-over-violin-plot","title":"Markers over violin plot","text":"<p>Violin plot has <code>with_strip</code> and <code>with_swarm</code> methods to overlay markers.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .with_strip(symbol=\"D\", size=8, color=\"black\")\n)\n</code></pre> </p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .with_swarm(size=8, color=\"black\")\n)\n</code></pre> </p>"},{"location":"categorical/cat_num/#add-outliers","title":"Add outliers","text":"<p>Box plot and violin plot are usually combined with outlier markers, as these plots are not good at showing the details of the sparse data points. For these plots, <code>with_outliers</code> method will add outliers, and optionally change the whisker lengths for the box plot.</p> <p>This is the example of adding outliers to the box plot. Because outliers are shown as a strip plot, arguments specific to strip plot (<code>symbol</code>, <code>size</code>, <code>extent</code> and <code>seed</code>) can be used.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_boxplot(color=\"replicate\")\n    .with_outliers(size=8)\n)\n</code></pre> </p> <p>If the box plot is edge only, the outliers will be the same.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_boxplot(color=\"replicate\")\n    .as_edge_only()\n    .with_outliers()\n)\n</code></pre> </p> <p>Setting <code>update_whiskers</code> to <code>False</code> will not change the whisker lengths.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_boxplot(color=\"replicate\")\n    .with_outliers(update_whiskers=False)\n)\n</code></pre> </p> <p>Violin plot also supports <code>with_outliers</code> method.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n    .with_outliers(size=8)\n)\n</code></pre> </p>"},{"location":"categorical/num_num/","title":"Numerical \u00d7 Numerical Data","text":""},{"location":"categorical/num_num/#categorical-lines-and-markers","title":"Categorical Lines and Markers","text":"<p>Line plot and scatter plot use numerical values for both x and y axes. In this case, the plot is categorized by such as color, marker symbol, etc.</p> <pre><code>from whitecanvas import new_canvas\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 5 + [\"B\"] * 5,\n    \"x\": [0, 1, 2, 3, 4, 0, 1, 2, 3, 4],\n    \"y\": [3, 1, 2, 4, 3, 5, 3, 3, 1, 2],\n    \"some-info\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"],\n}\n</code></pre> <p>By setting <code>color=</code> to one of the column name, lines are split by the column and different colors are used for each group.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>By setting <code>style=</code>, different line styles are used instead. In the following example, <code>color=\"black\"</code> means that all the lines should be the same color (black).</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"black\", style=\"label\")\ncanvas.show()\n</code></pre> </p> <p>In the case of markers, you can use symbols to distinguish groups.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_markers(symbol=\"label\")\ncanvas.show()\n</code></pre> </p> <p>The layers implement hover texts by default, based on the input data frame.</p> <pre><code>canvas = new_canvas(\"plotly\", size=(400, 300))\ncanvas.cat(df, \"x\", \"y\").add_markers(color=\"label\")\ncanvas.show()\n</code></pre>"},{"location":"categorical/num_num/#automatic-creation-of-legends","title":"Automatic Creation of Legends","text":"<p>As mentioned in Legend for the Layers, legends can be automatically created by <code>add_legend</code> function. In the case of the categorical plot, the legend is created based on the categories.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"label\")\ncanvas.add_legend()\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/num_num/#distribution-of-numerical-data","title":"Distribution of Numerical Data","text":"<p>There are several ways to visualize the distribution of numerical data.</p> <ul> <li>Histogram</li> <li>Kernel Density Estimation (KDE)</li> </ul> <p>These representations only use one array of numerical data. Therefore, either <code>x</code> or <code>y</code> should be empty in the <code>cat</code> method.</p> <pre><code>import numpy as np\n\nrng = np.random.default_rng(12345)\n\n# sample data\nsteps = np.array([0] * 60 + [3] * 30 + [6] * 40)\ndf = {\n    \"label\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"X\": rng.normal(loc=0.0, size=130) + steps,\n    \"Y\": rng.normal(loc=1.0, size=130) + steps / 2,\n}\n</code></pre> <p><code>x=\"X\"</code> means that the x-axis being \"X\" and the y-axis being the count. Arguments forwards to the <code>histogram</code> method of <code>numpy</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>To transpose the histogram, use <code>y=\"X\"</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, y=\"X\").add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>Histograms can be grouped by color.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_hist(bins=10, color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>If both <code>x</code> and <code>y</code> are set, the plotter cannot determine which axis to use. To tell the plotter which axis to use, call <code>along_x()</code> or <code>along_y()</code> to restrict the dimension.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n# canvas.cat(df, x=\"label\", y=\"X\").add_hist(bins=10)  # This will raise an error\ncanvas.cat(df, x=\"label\", y=\"X\").along_y().add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>KDE can be similarly added.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_kde(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>2-dimensional histogram can be added by <code>add_hist2d</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\", y=\"Y\").add_hist2d(bins=(8, 10), color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>and similarly, 2-dimensional KDE can be added by <code>add_kde2d</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\", y=\"Y\").add_kde2d(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>Note</p> <p><code>add_hist</code> and <code>add_hist2d</code> returns completely different objects (histogram and heatmap) and they are configured by different arguments. That's why <code>whitecanvas</code> split them into two different methods.</p>"},{"location":"categorical/stacking/","title":"Stacking Layers","text":"<p>If a quantity can be cumulatively added, stacking is a great way to visualize the total amount of each data point. In this section, we will use the following data.</p> <pre><code>df = {\n    \"day\": [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3],\n    \"value\": [1, 5, 10, 20, 2, 6, 8, 15, 3, 6, 9, 12],\n    \"person\": [\"A\"] * 4 + [\"B\"] * 4 + [\"C\"] * 4,\n}\n</code></pre> <p>There are only limited number of plot types that can be stacked. Currently, area plot and bar plot are supported. Methods to add these plots are in the \"stacked categorical plotter\" object that can be created by the <code>stack</code> method of the categorical plotters.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"day\", y=\"value\")\n    .stack(by=\"person\")\n    .add_area()\n)\ncanvas\n</code></pre> </p> <p>Here, the column \"person\" is used to stack the area plot, which means that the input data is split by the values in the \"person\" column, and the area plot is drawn for each category. These plots are stacked on top of each other.</p> <p>Each stack is usually drawn with a different color. You can give the same column name as the <code>color</code> argument to the <code>add_area</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"day\", y=\"value\")\n    .stack(by=\"person\")\n    .add_area(color=\"person\")\n)\ncanvas\n</code></pre> </p> <p>or, of course, drawn with different hatch patterns.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"day\", y=\"value\")\n    .stack(by=\"person\")\n    .add_area(hatch=\"person\")\n)\ncanvas\n</code></pre> </p> <p>The \"person\" column is given to both the <code>stack</code> and the <code>add_area</code> method. In these cases, the argument of <code>stack</code> can be omitted.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"day\", y=\"value\")\n    .stack()\n    .add_area(color=\"person\")\n)\ncanvas\n</code></pre> </p> <p>Another way to show the data is to use bar plots.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"day\", y=\"value\")\n    .stack()\n    .add_bars(color=\"person\", extent=0.5)\n)\ncanvas\n</code></pre> </p>"},{"location":"events/","title":"Event Handling","text":"<p>Listening to the changes in the canvas or layer states is a common task in interactive plotting. Although different backend plotting libraries implement their own event handling systems, <code>whitecanvas</code> provides a unified system using the psygnal library.</p> <p>The common syntax is to use <code>connect</code> function to connect callback function to the event handler.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas()\n\n# connect callback function\n@canvas.x.events.lim.connect\ndef _xlim_changed(lim):\n    print(f\"canvas.x.lim changed to {lim}\")\n</code></pre> <ul> <li>Canvas Events</li> <li>Layer Events</li> <li>Mouse Events</li> </ul>"},{"location":"events/canvas_events/","title":"Canvas Events","text":""},{"location":"events/layer_events/","title":"Layer Events","text":""},{"location":"events/mouse_events/","title":"Mouse Events","text":"<p>Interactive visualization is one of the most powerful aspect of Python.</p>"},{"location":"events/mouse_events/#click-events","title":"Click Events","text":"<p>The click events can be captured by <code>clicked</code>. Use <code>connect()</code> method to connect a callback function to the event. The callback function must accept a single argument of type <code>MouseEvent</code>.</p> <pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.types import MouseEvent\n\ncanvas = new_canvas(\"matplotlib:qt\")\n\n@canvas.mouse.clicked.connect\ndef _on_click(ev: MouseEvent):\n    print(\"pos:\", ev.pos)  # the (x, y) coordinate\n    print(\"button\", ev.button)  # mouse button enum\n    print(\"modifiers\", ev.modifiers)  # mouse modifier enums\n</code></pre> <p>Double-click events are very similar. They can be captured by <code>double_clicked</code>.</p> <pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.types import MouseEvent\n\ncanvas = new_canvas(\"matplotlib:qt\")\n\n@canvas.mouse.double_clicked.connect\ndef _on_click(ev: MouseEvent):\n    print(\"pos:\", ev.pos)  # the (x, y) coordinate\n    print(\"button\", ev.button)  # mouse button enum\n    print(\"modifiers\", ev.modifiers)  # mouse modifier enums\n</code></pre> <p>It is useful to filter the mouse button and modifier inside the callback function.</p> <pre><code>@canvas.mouse.clicked.connect\ndef _on_click(ev: MouseEvent):\n    if ev.button == \"left\":\n        print(\"left button clicked\")\n    if ev.modifiers == \"ctrl\":\n        print(\"ctrl key is pressed\")\n</code></pre>"},{"location":"events/mouse_events/#move-events","title":"Move Events","text":"<p>Mouse move events need a different architecture. Unlike other events, the callback function must be a generator function. every time the mouse moves, the generator proceeds.</p> <pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.types import MouseEvent\n\ncanvas = new_canvas(\"matplotlib:qt\")\n\n@canvas.mouse.moved.connect\ndef _on_move(ev: MouseEvent):\n    if ev.type != \"press\":\n        return\n    print(\"pressed\")\n    yield\n    while ev.type == \"move\":\n        print(\"moved to:\", ev.pos)\n        yield\n    print(\"released\")\n</code></pre>"},{"location":"events/mouse_events/#emulating-mouse-events","title":"Emulating Mouse Events","text":"<p>Mouse events can be emulated by the <code>emulate_*</code> methods.</p> <ul> <li>emulate_click()</li> <li>emulate_double_click()</li> <li>emulate_hover()</li> <li>emulate_drag()</li> </ul> <pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.types import MouseEvent\n\ncanvas = new_canvas(\"matplotlib:qt\")\ncanvas.mouse.emulate_click((100, 100), button=\"left\")\ncanvas.mouse.emulate_double_click((100, 100), button=\"left\", modifiers=\"ctrl\")\ncanvas.mouse.emulate_hover([(100, 100), (100, 101), (100, 102)])\ncanvas.mouse.emulate_drag([(100, 100), (100, 101), (100, 102)], button=\"left\")\n</code></pre>"},{"location":"layers/","title":"Layers","text":"<ul> <li>Lines</li> <li> </li> <li>Distribution</li> <li>Layer Groups</li> <li>Mouse Interactivity</li> </ul>"},{"location":"layers/#markers","title":"Markers","text":""},{"location":"layers/distribution/","title":"Visualizing Distributions","text":"<p>There are several conventional ways to visualize distributions.</p>"},{"location":"layers/distribution/#histogram","title":"Histogram","text":"<p><code>Histogram</code> is a layer that represents a histogram. It can be created by the <code>add_hist</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nnp.random.seed(0)\ndata = np.random.normal(size=100)  # sample data\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_hist(data, color=\"red\")\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/distribution/#kde","title":"KDE","text":"<p><code>Kde</code> is a layer that represents a kernel density estimation. It can be created by the <code>add_kde</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nnp.random.seed(0)\ndata = np.random.normal(size=100)  # sample data\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_kde(data, color=\"red\")\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/distribution/#rug","title":"Rug","text":"<p><code>Rug</code> is a layer that represents rug plot (or event plot). It can be created by the <code>add_rug</code> method. Rug plots tend to overlap with each other, so it is better at visualizing the individual data points rather than the distribution. Therefore, it is usually useful to overlay the rug plot on the histogram or the KDE.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nnp.random.seed(0)\ndata = np.random.exponential(size=100)  # sample data\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_hist(data, color=\"red\")\ncanvas.add_rug(data)\ncanvas.show()\n</code></pre> </p> <p>If you want to properly visualize the distribution only with the rug plot, you can use the color or length of the rug lines to represent the density of the data points. <code>Rug</code> layer has method <code>color_by_density</code> and <code>scale_by_density</code> to achieve this.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nnp.random.seed(0)\ndata = np.random.normal(size=100)  # sample data\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_rug(data).color_by_density(cmap=\"viridis\")\ncanvas.show()\n</code></pre> </p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nnp.random.seed(0)\ndata = np.random.normal(size=100)  # sample data\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_rug(data).scale_by_density()\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/face_layers/","title":"Bars, Band and Spans","text":"<p>There are several layers that is composed of faces and edges.</p> <ul> <li><code>Bars</code> ... a layer composed of bars.</li> <li><code>Band</code> ... a layer composed of a band region (fill-between region).</li> <li><code>Spans</code> ... a layer composed of infinitely long spans.</li> </ul> <p>These layers have two namespaces: <code>face</code> and <code>edge</code>. <code>face</code> has following properties:</p> <ul> <li><code>color</code> ... color of the faces. Any color-like object is accepted.</li> <li><code>hatch</code> ... hatch pattern of the faces. Should be one of <code>\"\"</code>, <code>\"-\"</code>, <code>\"|</code>, <code>\"+\"</code>,   <code>\"/\"</code>, <code>\"\\\\\"</code>, <code>\"x\"</code> or <code>\".\"</code>.</li> </ul> <p>Note</p> <p><code>hatch</code> is not supported in some backends.</p> <p><code>edge</code> has following properties:</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>Methods for adding these layers always configure the <code>face</code> properties with the arguments. You can use the <code>with_edge</code> method of the output layer to set edge properties. This separation is very helpful to prevent the confusion of the arguments, especially the colors.</p> <p>Following example uses <code>add_bars</code> and <code>add_spans</code> methods to create <code>Bars</code> and <code>Spans</code> layers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nbars_layer = (\n    canvas\n    .add_bars([0, 1, 2, 3], [3, 4, 1, 2], color=\"yellow\")\n    .with_edge(color=\"black\")\n)\n\nspans_layer = (\n    canvas\n    .add_spans([[0.2, 0.8], [1.4, 2.1], [1.8, 3.0]], color=\"blue\")\n    .with_edge(color=\"black\")\n)\ncanvas.y.lim = (0, 5)\ncanvas.show()\n</code></pre> </p> <p>All the properties can be set via properties of <code>face</code> and <code>edge</code>, or the <code>update</code> method.</p> <pre><code>#!skip\nbars_layer.face.color = \"yellow\"\nbars_layer.face.hatch = \"x\"\n\nspans_layer.edge.color = \"black\"\nspans_layer.edge.width = 2\nspans_layer.edge.style = \"--\"\n\n# use `update`\nbars_layer.face.update(color=\"yellow\", hatch=\"x\")\nspans_layer.edge.update(color=\"black\", width=2, style=\"--\")\n</code></pre>"},{"location":"layers/face_layers/#multi-face-and-multi-edge","title":"Multi-face and Multi-edge","text":"<p>As for <code>Markers</code>, <code>Bars</code> and <code>Spans</code> supports multi-face and multi-edge.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_bars([0, 1, 2, 3], [3, 4, 1, 2])\n    .with_face_multi(color=[\"red\", \"#00FF00\", \"rgb(0, 0, 255)\", \"black\"])\n)\ncanvas.show()\n</code></pre> </p> <p>After calling <code>with_face_multi</code>, the layer <code>face</code> property will return arrays instead of scalar values.</p> <pre><code>layer.face.color  # (N, 4) array of RGBA colors\nlayer.face.hatch  # (N,) array of hatchs\nlayer.face.alpha # (N,) array of alpha values\n</code></pre>"},{"location":"layers/layer_groups/","title":"Layer Groups","text":"<p>To plot complex layers, <code>whitecanvas</code> uses the layer-grouping strategy. There are several built-in layer groups.</p> <ul> <li><code>Plot</code> = <code>Line</code> + <code>Markers</code></li> <li><code>LineBand</code> = <code>Line</code> + <code>Band</code></li> <li><code>LabeledLine</code> = <code>Line</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledMarkers</code> = <code>Markers</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledBars</code> = <code>Bars</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledPlot</code> = <code>Plot</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>Stem</code> = <code>Markers</code> + <code>MultiLine</code></li> <li><code>Graph</code> = <code>Markers</code> + <code>MultiLine</code> + <code>Texts</code></li> </ul> <p>These layer groups can be derived from primitive layers. It's very important to note that this layer-grouping architecture makes complex plots to have consistent argument with the individual plot elements.</p>"},{"location":"layers/layer_groups/#layer-groups-with-lines","title":"Layer Groups with Lines","text":"<p>In this section, we will introduce layer groups that are derived from the <code>Line</code> layer.</p>"},{"location":"layers/layer_groups/#add-markers-andor-error-bars","title":"Add markers and/or error bars","text":"<p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = canvas.add_line(\n    [0, 1, 2], [3, 2, 4], color=\"black\", name=\"myplot\",\n).with_markers(\n    symbol=\"o\", color=\"red\"\n)\ncanvas.show()\n</code></pre> </p> <p>The <code>with_markers</code> method returns a <code>Plot</code> layer, which has <code>Line</code> and <code>Markers</code> as its children. Therefore, at the very least, any customization can be done on the children.</p> <pre><code>print(layer)  # Plot&lt;'myplot'&gt;\nprint(layer.line)  # Line&lt;'line-of-myplot'&gt;\nprint(layer.markers)  # Markers&lt;'markers-of-myplot'&gt;\n</code></pre> <p>Once the layer is grouped, layer group instead of the child layers are in the layer list.</p> <pre><code>print(canvas.layers)  # LayerList([Plot&lt;'myplot'&gt;])\n</code></pre> <p>The <code>Plot</code> layer can be further converted into a <code>LabeledPlot</code> layer by adding error bars using <code>with_xerr</code> and/or <code>with_yerr</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"black\")\n    .with_markers(symbol=\"o\", color=\"red\")\n    .with_yerr([0.1, 0.2, 0.3])\n    .with_xerr([0.2, 0.3, 0.2], style=\"--\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/layer_groups/#add-bands","title":"Add bands","text":"<p><code>Band</code> may be used for different purposes.</p> <ol> <li>To fill the area of confidence interval.</li> <li>To fill the area between the line and the x- or y-axis.</li> </ol> <p>Both cases can be achieved using the <code>Line</code> methods.</p> <p>To fill the area that represents the errors, such as confidence interval and standard deviation, use the <code>with_xband</code> or <code>with_yband</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n# one array for the same size of lower and upper bounds\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"blue\")\n    .with_yband([0.2, 0.3, 0.4])\n)\n# two arrays for different sizes of lower and upper bounds\n(\n    canvas\n    .add_line([2, 3, 4], [1, 0, 2], color=\"red\")\n    .with_yband([0.2, 0.3, 0.4], [0.4, 0.6, 0.8])\n)\n\ncanvas.show()\n</code></pre> </p> <p>To fill the area between the line and the axis, use the <code>with_xfill</code> or <code>with_yfill</code> respectively.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([1, 2, 3], [2.4, 3, 4], color=\"blue\")\n    .with_xfill()\n)\n(\n    canvas\n    .add_line([2, 3, 4], [2, 1, 2], color=\"red\")\n    .with_yfill()\n)\n\ncanvas.show()\n</code></pre> </p> <p>Warning</p> <p><code>with_xfill</code> fill the area between the line and the y-axis. This is because the orientation of the filling is in the direction of the y-axis, consistent with the methods such as <code>with_xband</code> and <code>with_xerr</code>.</p>"},{"location":"layers/layer_groups/#add-texts","title":"Add texts","text":"<p>Adding text at the data points can be done using the <code>with_text</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"black\")\n    .with_text([\"i=0\", \"i=1\", \"i=2\"], size=20, color=\"red\")\n)\ncanvas.show()\n</code></pre> </p> <p>You can use text alignment and text offset to adjust the position of the text.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"black\")\n    .with_text([\"i=0\", \"i=1\", \"i=2\"], size=20, color=\"red\")\n    .with_text_offset(0.2, 0.0)\n)\n(\n    canvas\n    .add_line([3, 4, 5], [3, 2, 4], color=\"black\")\n    .with_text([\"i=0\", \"i=1\", \"i=2\"], size=20, color=\"green\", anchor=\"top\")\n)\ncanvas.show()\n</code></pre> </p> <p>You can use \"x\", \"y\" and \"i\" as the placeholders in the text to format the text using the x/y data and the indices.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"black\")\n    .with_text(\"x={x:.2f}, y={y:.2f}, i={i}\", size=20, color=\"red\")\n)\n</code></pre> </p>"},{"location":"layers/layer_groups/#layer-groups-with-markers","title":"Layer Groups with Markers","text":""},{"location":"layers/layer_groups/#markers-with-error-bars","title":"Markers with error bars","text":"<p>Similar to the <code>Line</code> layer, the <code>Markers</code> layer can also be grouped with the <code>Errorbar</code> layer.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_markers([0, 1, 2], [3, 2, 4], color=\"black\", symbol=\"D\", size=10)\n    .with_xerr([0.2, 0.3, 0.4], style=\"--\")\n    .with_yerr([0.3, 0.3, 0.5], style=\":\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/layer_groups/#markers-as-stems","title":"Markers as stems","text":"<p>The <code>Stem</code> layer is a layer group of <code>Markers</code> and <code>MultiLine</code>. It can be created using the <code>with_stem</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nx = np.linspace(0, 4 * np.pi, 50)\n(\n    canvas\n    .add_markers(x, np.sin(x))\n    .with_stem()\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/layer_groups/#markers-as-a-graph-network","title":"Markers as a graph network","text":"<p>A network graph is a collection of nodes and edges. The <code>Graph</code> layer is a layer group that can created using the <code>with_network</code> method of <code>Markers</code>. It uses the list of index pairs to connect markers.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nnodes = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0], [0.5, 1.7]]\nconnections = [[0, 1], [0, 2], [1, 2], [0, 4], [2, 3]]\n\n(\n    canvas\n    .add_markers(nodes, size=40, color=\"skyblue\")\n    .with_edge(width=2, color=\"blue\")\n    .with_network(connections)\n    .with_text([\"i=0\", \"i=1\", \"i=2\", \"i=3\", \"i=4\"], size=20)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/","title":"Lines","text":"<p>There are several layers that is composed of only lines.</p> <ul> <li><code>Line</code> ... a simple line.</li> <li><code>InfLine</code> ... a straight line that extends to infinity</li> <li><code>InfCurve</code> ... a curve that extends to infinity</li> <li><code>Errorbar</code> ... lines representing error bars</li> <li><code>Rug</code> ... lines representing rug plots</li> </ul> <p>These layers have following properties in common.</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>These properties can be configured in function calls, via properties or the <code>update</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n# function call\nlayer = canvas.add_line([0, 2, 1, 3, 4, 2, -1], color=\"black\", width=2, style=\":\")\n\n# properties\nlayer.color = \"#FF36D9\"\nlayer.width = 2.5\nlayer.style = \"-\"\n\n# update method\nlayer.update(color=[0.0, 1.0, 0.0, 1.0], width=1, style=\"--\")\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#line","title":"Line","text":"<p><code>Line</code> is a simple line defined by two arrays of x and y coordinates. It is usually created by the <code>add_line</code> method. This method accepts several ways to define the line coordinates.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.add_line([0, 1, 0, -1, 0])  # only y values\ncanvas.add_line([0, 1, 2, 3, 4], [1, 2, 1, 0, 1])  # x and y values\ncanvas.add_line(np.arange(5), np.array([2, 3, 2, 1, 2]))  # numpy arrays\ncanvas.add_line(np.array([[0, 3], [1, 4], [2, 3], [3, 2], [4, 3]]))  # (N, 2) array\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#infline","title":"InfLine","text":"<p><code>InfLine</code> is a straight line that extends to infinity. Practically, it is achieved by connecting a callback that updates the line coordinates when the canvas view range is updated.</p> <p><code>InfLine</code> is usually created by the <code>add_infline</code> method, or in the specific cases, <code>add_vline</code> and <code>add_hline</code> for vertical and horizontal lines, respectively.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_infline((0, 1), 45, color=\"black\")  # y = x + 1\ncanvas.add_vline(2, color=\"red\")  # x = 2\ncanvas.add_hline(-1, color=\"blue\")  # y = -1\ncanvas.x.lim = (-3, 3)\ncanvas.y.lim = (-3, 3)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#infcurve","title":"InfCurve","text":"<p><code>InfCurve</code> is a curve that extends to infinity, defined by an arbitrary model function. Practically, it is achieved by connecting a callback that resamples the curve when the canvas view range is updated.</p> <p><code>InfCurve</code> is usually created by the [<code>add_infcurve</code>][whitecanvas.canvas.CanvasBase. add_infcurve] method. The input model function must be defined as <code>model(x, ...)</code> where <code>x</code> is <code>ndarray</code> of the x-coordinates and the rest of the arguments are the parameters of the model. The parameters can be set by the <code>update_params</code> method of the returned layer.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ndef model(x, freq, phase):\n    return np.sin(x * freq - phase)\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_infcurve(model, color=\"black\").update_params(freq=2, phase=0)\ncanvas.add_infcurve(model, color=\"black\", style=\":\").update_params(freq=2, phase=1.6)\ncanvas.x.lim = (-3, 3)\ncanvas.y.lim = (-3, 3)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#errorbars","title":"Errorbars","text":"<p><code>Errorbars</code> is a layer that represents error bars with caps. It can be created by the <code>add_errorbars</code> method, but if you intend to add error bars to an existing layer with x/y data, try using the <code>with_xerr</code> and <code>with_yerr</code> methods of the layer to group layers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nx = [0, 1, 2]\nylow = [2, 3, 4]\nyhigh = [4, 5, 5]\ncanvas.add_errorbars(x, ylow, yhigh, capsize=0.5, width=3, color=\"crimson\")\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/markers/","title":"Markers","text":"<p><code>Markers</code> is a layer for scatter plots. It can be created with the <code>add_markers</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nlayer = canvas.add_markers([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.show()\n</code></pre> </p> <p>Symbol and size of the markers can easily be configured with the <code>symbol</code> and <code>size</code> arguments.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nfor i, symbol in enumerate([\"o\", \"s\", \"x\", \"+\"]):\n    for j, size in enumerate([5, 10, 15, 20]):\n        x = [i - 0.2, i - 0.2, i + 0.2, i + 0.2]\n        y = [j - 0.2, j + 0.2, j - 0.2, j + 0.2]\n        layer = canvas.add_markers(x, y, symbol=symbol, size=size)\ncanvas.show()\n</code></pre> </p> <p>Note</p> <p>If the symbol is edge-only, its color and visibility are automatically updated to ensure the markers are informative.</p>"},{"location":"layers/markers/#marker-properties","title":"Marker Properties","text":"<p><code>Markers</code> layer has two namespaces: <code>face</code> and <code>edge</code>. <code>face</code> has following properties:</p> <ul> <li><code>color</code> ... color of the faces. Any color-like object is accepted.</li> <li><code>hatch</code> ... hatch pattern of the faces. Should be one of <code>\"\"</code>, <code>\"-\"</code>, <code>\"|</code>, <code>\"+\"</code>,   <code>\"/\"</code>, <code>\"\\\\\"</code>, <code>\"x\"</code> or <code>\".\"</code>.</li> </ul> <p>Note</p> <p><code>hatch</code> is not supported in some backends.</p> <p><code>edge</code> has following properties:</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>Methods for adding these layers always configure the <code>face</code> properties with the arguments. You can use the <code>with_edge</code> method of the output layer to set edge properties. This separation is very helpful to prevent the confusion of the arguments, especially the colors.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.add_markers(np.sin(np.arange(10)), color=\"yellow\").with_edge(color=\"black\")\ncanvas.show()\n</code></pre> </p> <p>All the properties can be set via properties of <code>face</code> and <code>edge</code>, or the <code>update</code> method.</p> <pre><code>layer.face.color = \"yellow\"\nlayer.face.hatch = \"x\"\n\nlayer.edge.color = \"black\"\nlayer.edge.width = 2\nlayer.edge.style = \"--\"\n\n# use `update`\nlayer.face.update(color=\"yellow\", hatch=\"x\")\nlayer.edge.update(color=\"black\", width=2, style=\"--\")\n</code></pre>"},{"location":"layers/markers/#multi-face-and-multi-edge-markers","title":"Multi-face and Multi-edge Markers","text":"<p><code>Markers</code> supports multi-face and multi-edge. This means that you can create a layer with multiple colors, widths, etc.</p> <p>To do this, you have to call <code>with_face_multi</code> or <code>with_edge_multi</code> method. Here's an example of <code>Markers</code> with multi-faces.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_markers(np.arange(10), np.sin(np.arange(10)))\n    .with_face_multi(color=np.random.random((10, 3)))  # random colors\n)\ncanvas.show()\n</code></pre> </p> <p>After calling <code>with_face_multi</code>, the layer <code>face</code> property will return arrays instead of scalar values.</p> <pre><code>layer.face.color  # (N, 4) array of RGBA colors\nlayer.face.hatch  # (N,) array of hatchs\nlayer.face.alpha # (N,) array of alpha values\n</code></pre> <p>Note</p> <p>IDE can detect whether a <code>Markers</code> layer is multi-face or not. <code>Markers</code> class is a generic class with type variables for the face types. Since <code>with_face_multi</code> is correctly typed, IDE will recognize the returned layer as a multi-face layer.</p> <p>Similarly, you can use <code>with_edge_multi</code> to create multi-edge markers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_markers(np.arange(10), np.sin(np.arange(10)))\n    .with_edge_multi(width=np.abs(np.sin(np.arange(10))) * 2.5)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/markers/#multi-size-markers","title":"Multi-size Markers","text":"<p><code>with_size_multi</code> method can be used to create multi-size markers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_markers(np.arange(10), np.sin(np.arange(10)))\n    .with_size_multi(np.abs(np.sin(np.arange(10))) * 16)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/markers/#methods-for-better-interpretability","title":"Methods for Better Interpretability","text":"<p><code>Markers</code> is implemented with the following methods to make the plot more interpretable.</p>"},{"location":"layers/markers/#color-by-density","title":"Color by density","text":"<p>Scatter plot is good at visualizing the outliers, but not at telling the distribution when the density is high. In this case, <code>color_by_density</code> method is very useful. It colors the markers by the density of the points using kernel density estimation.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_row\n\nrng = np.random.default_rng(999)\nx = rng.normal(size=1000)\ny = rng.normal(size=1000)\n\ngrid = new_row(2, backend=\"matplotlib\")\n(\n    grid\n    .add_canvas(0)\n    .update_labels(title=\"no coloring\")\n    .add_markers(x, y)\n)\n(\n    grid\n    .add_canvas(1)\n    .update_labels(title=\"with coloring\")\n    .add_markers(x, y)\n    .color_by_density(cmap=\"viridis\")\n)\ngrid.show()\n</code></pre> </p>"},{"location":"layers/mouse/","title":"Mouse Interactivity","text":"<p>Layers in <code>whitecanvas</code> support mouse interactivity. Following table shows what feature is supported in which backend.</p> Feature <code>matplotlib</code> <code>plotly</code> <code>bokeh</code> <code>pyqtgraph</code> <code>vispy</code> Hovering \u2713 \u2713 \u2713 \u2713 \u2717 Picking \u2713 \u2713 \u2717 \u2713 \u2717"},{"location":"layers/mouse/#hover-text","title":"Hover Text","text":"<p>Hover text is very useful for interactive data exploration.</p> <p>Note</p> <p>To demonstrate the hover texts in this document, we use <code>plotly</code> backend. This does not mean that hover text is not supported in <code>matplotlib</code>.</p>"},{"location":"layers/mouse/#give-a-sequence-of-hover-texts","title":"Give a sequence of hover texts","text":"<p><code>with_hover_text</code> method sets the hover text to the layer. Following example shows how to set custom hover texts to markers.</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"plotly\", size=(400, 300))\nx = np.arange(10)\ny = np.sin(x)\n\nlayer = (\n    canvas\n    .add_markers(x, y)\n    .with_hover_text([f\"point {i}\" for i in range(10)])\n)\ncanvas.show()\n</code></pre>"},{"location":"layers/mouse/#give-a-hover-template","title":"Give a hover template","text":"<p>If the hover texts are to be determined by the internal data, it's better to define a template for the hover text. <code>with_hover_template</code> method sets the hover template to the layer.</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"plotly\", size=(400, 300))\nx = np.arange(10)\ny = np.sin(x)\n\nlayer = (\n    canvas\n    .add_markers(x, y)\n    .with_hover_template(\"x={x:.2f}, y={y:.2f}, i={i}\")\n)\ncanvas.show()\n</code></pre>"},{"location":"layers/mouse/#picking-data-points","title":"Picking Data Points","text":"<p>Layers also have a <code>clicked</code> event. You can connect a callback to the event to handle the picking. Use <code>layer.events.clicked.connect</code> syntax to do it.</p> <p>Warning</p> <p>The callback function is defined on the Python side. This means that if the backend uses JavaScript like <code>plotly</code>, the callback cannot be executed. If you constructed a <code>plotly</code> canvas with Jupyter Notebook backend by <code>canvas(\"plotly:nb\")</code>, however, callbacks are not disabled owing to the FigureWidget of <code>plotly</code>.</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib:qt\")\nlayer = canvas.add_markers([0, 1, 2], [0, 0, 0])\n\n@layer.events.clicked.connect\ndef _on_pick(picked):\n    print(f\"picked indices: {picked}\")\n</code></pre>"},{"location":"layers/texts/","title":"Texts","text":"<p>Text layer is a collection of text elements. It is usually created by the <code>add_text</code> method.</p> <p>A text can be added by specifying the x and y coordinates, and the text string.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_text(0, 0, \"Hello, World!\", size=20, color=\"black\")\ncanvas.show()\n</code></pre> </p> <p>Multiple texts can be added by specifying the array of x and y coordinates, and the text strings.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nx = [0, 1, 2, 3]\ny = [0, 1, 0, 1]\ntexts = [f\"(x={x[i]}, y={y[i]})\" for i in range(4)]\ncanvas.add_text(x, y, texts, size=20, color=\"black\")\ncanvas.x.lim = (-1, 4)\ncanvas.y.lim = (-1, 2)\ncanvas.show()\n</code></pre> </p> <p>The <code>anchor=</code> argument can be used to specify the text anchor position.</p> <p><pre><code>from whitecanvas import new_row\n\ngrid = new_row(2, backend=\"matplotlib\").fill()\n\ngrid[0].add_markers([0], [0])\nfor anchor in [\"top\", \"bottom\", \"left\", \"right\"]:\n    grid[0].add_text(0, 0, anchor, size=20, color=\"black\", anchor=anchor)\n\ngrid[1].add_markers([0], [0])\nfor anchor in [\"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\"]:\n    grid[1].add_text(0, 0, anchor, size=20, color=\"black\", anchor=anchor)\n\ngrid.show()\n</code></pre> </p> <p><code>matplotlib</code>, <code>pyqtgraph</code> and <code>bokeh</code> backends support background rectangles for the texts. As for the layers with both faces and edges, <code>with_face</code> and <code>with_edge</code> methods can be used to set the background face and edge properties.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n(\n    canvas.add_text(x, y, texts, size=20, color=\"black\")\n    .with_face(color=\"yellow\")\n    .with_edge(color=\"red\", width=2, style=\"--\")\n)\ncanvas.x.lim = (-1, 4)\ncanvas.y.lim = (-1, 2)\ncanvas.show()\n</code></pre> </p>"},{"location":"tools/","title":"Tools","text":"<ul> <li>Tools</li> </ul>"},{"location":"tools/selection/","title":"Selection Tools","text":"<p>Interactive selection in a canvas is an useful feature for many applications. Although mouse events provide a complete functionality for manual selection, implementing a selection tool can be a tedious task.</p> <p><code>whitecanvas</code> has a built-in, ready-to-use selection tool that can be easily added to your canvas. Currently, the selection tool is only available for following backends.</p> <code>matplotlib</code> <code>plotly</code> <code>bokeh</code> <code>pyqtgraph</code> <code>vispy</code> \u2713 \u2717 \u2717 \u2713 \u2713"},{"location":"tools/selection/#line-selection-tool","title":"Line Selection Tool","text":"<p>Line selection tools can be created by <code>line_selector</code> function. Because selection temporarily adds a new layer to the canvas, the selection tool requires a canvas object as an argument. Once selection is done, a selector emits a <code>changed</code> signal.</p> <p><pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.tools import line_selector\n\ncanvas = new_canvas(\"matplotlib\")\n\nselector = line_selector(canvas)  # make a selector\n\n# connect a callback function\n@selector.changed.connect\ndef _on_selection(sel):\n    print(sel)\n\ncanvas.mouse.emulate_drag([(0.2, 0.2), (0.8, 0.6)], button=\"left\")\ncanvas.show()\n</code></pre> </p> Output<pre><code>LineSelection(start=Point(x=0.2, y=0.2), end=Point(x=0.8, y=0.6))\n</code></pre> <p>The emitted object <code>LineSelection</code> is a named tuple of start and end <code>Point</code>s, which is again a named tuple of x and y coordinates.</p> <p>The <code>changed</code> signals are emitted when the selection is done. If you want to make the signal emitted during the mouse drag,</p> <pre><code>selector = line_selector(canvas, tracking=True)\n</code></pre>"},{"location":"tools/selection/#styling-selection","title":"Styling Selection","text":"<p>As all the selection is a layer, you can style the selection.</p> <p><pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.tools import line_selector\n\ncanvas = new_canvas(\"matplotlib\")\nselector = line_selector(canvas)  # make a selector\n\nselector.color = \"red\"\nselector.width = 3\nselector.style = \"--\"\n\ncanvas.mouse.emulate_drag([(0.2, 0.2), (0.8, 0.6)], button=\"left\")\ncanvas.show()\n</code></pre> </p>"},{"location":"tools/selection/#rectangle-selection-tool","title":"Rectangle Selection Tool","text":"<p>Rectangle selector(<code>rect_selector</code>) is similar to the line selector, but it emits a <code>Rect</code> object.</p> <p><pre><code>from whitecanvas import new_canvas\nfrom whitecanvas.tools import rect_selector\n\ncanvas = new_canvas(\"matplotlib\")\n\nselector = rect_selector(canvas)  # make a selector\n\n# connect a callback function\n@selector.changed.connect\ndef _on_selection(sel):\n    print(sel)\n\ncanvas.mouse.emulate_drag([(0.2, 0.2), (0.8, 0.6)], button=\"left\")\ncanvas.show()\n</code></pre> </p> Output<pre><code>Rect(left=0.2, right=0.8, bottom=0.2, top=0.6)\n</code></pre>"},{"location":"tools/selection/#other-selection-tools","title":"Other Selection Tools","text":"<ul> <li>X-span selection (xspan_selector)</li> <li>Y-span selection (yspan_selector)</li> <li>Lasso (free-hand) selection (lasso_selector)</li> <li>Polygon selection (polygon_selector)</li> </ul>"},{"location":"tools/selection/#check-if-selection-contains-points","title":"Check If Selection Contains Points","text":"<p>Mouse selection is usually used to select data points. To do this, you have to connect a callback function that checks if points are inside the selection area.</p> <p>Following example demonstrates how to highlight selected points by a rectangle selection.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\nfrom whitecanvas.tools import rect_selector\n\nrng = np.random.default_rng(1234)\ncanvas = new_canvas(\"matplotlib\")\nlayer = canvas.add_markers(rng.random(100), rng.random(100))\n\nselector = rect_selector(canvas)\n\n@selector.changed.connect\ndef _on_selection():\n    # get the indices of points inside the selection area\n    indices = selector.contains_points(layer.data)\n    # highlight selected points\n    layer.with_face_multi(alpha=np.where(indices, 1, 0.2))\n\ncanvas.mouse.emulate_drag([(0.2, 0.2), (0.8, 0.6)])\ncanvas.show()\n</code></pre> </p> <p>Same methods are defined for other selection tools with area.</p>"}]}