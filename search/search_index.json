{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"whitecanvas","text":"<p><code>whitecanvas</code> is a type safe and backend independent plotting library for Python.</p>"},{"location":"#source","title":"Source","text":"<p>Jump to GitHub repository.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>whitecanvas</code> is available on PyPI.</p> <pre><code>pip install whitecanvas -U\n</code></pre> <p>You can also install backend optional dependencies using one of the following commands.</p> <pre><code>pip install whitecanvas[matplotlib] -U\npip install whitecanvas[pyqtgraph] -U\npip install whitecanvas[vispy] -U\npip install whitecanvas[plotly] -U\npip install whitecanvas[bokeh] -U\n</code></pre>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#create-a-canvas","title":"Create a canvas","text":"<p>The <code>new_canvas</code> function creates a new canvas, in which you can add many graphical elements. Created canvas can be shown by calling <code>show</code>.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas()  # create a canvas\ncanvas.show()  # show the canvas\n</code></pre> </p> <p>As <code>whitecanvas</code> is backend independent, you can specify a plotting backend when creating the canvas.</p> <pre><code>canvas = new_canvas(backend=\"matplotlib\")  # matplotlib backend\n</code></pre> <p>Currently supported backends are:</p> <ul> <li>matplotlib</li> <li>pyqtgraph</li> <li>vispy</li> <li>plotly</li> <li>bokeh</li> </ul> <p>For each backend, they also have their own application backend. For example, <code>matplotlib</code> has <code>Qt</code>, <code>Tk</code> and many other backends, and <code>pyqtgraph</code> has <code>Qt</code> and <code>notebook</code> backend. You can add a suffix with separator \":\" to the backend name to specify which application backend to use.</p> <pre><code>canvas = new_canvas(backend=\"matplotlib:qt\")  # matplotlib with Qt backend\ncanvas = new_canvas(backend=\"pyqtgraph:notebook\")  # pyqtgraph with notebook backend\n</code></pre>"},{"location":"quick_start/#lets-plot","title":"Let's plot!","text":"<p>Here is a simple example to add a line and a scatter plot to the canvas.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1])\ncanvas.show()\n</code></pre> </p> <p>You can also add more options.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line([0, 1, 2, 3], [0, 1, 1, 0], color=\"red\", width=2, style=\":\")\ncanvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1], symbol=\"s\", size=20, color=\"blue\")\ncanvas.show()\n</code></pre> </p> <p>Methods always return a <code>Layer</code> object (with minor exceptions), which is also added to the list-like <code>layers</code> attribute of the canvas.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\nline_layer = canvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\nmarkers_layer = canvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1])\ncanvas.layers[0] is line_layer  # True\ncanvas.layers[1] is markers_layer  # True\n</code></pre> <p>Color, size, style, etc. can also be configured via the layer properties.</p> <pre><code>line_layer.color = \"red\"\nmarkers_layer.symbol = \"s\"\n</code></pre> <p>A major difference between <code>whitecanvas</code> and other plotting libraries is that all the edge properties are set using <code>with_edge</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\nmarkers_layer = canvas.add_markers(\n    [0, 1, 2, 3], [1, 2, 0, 1]\n).with_edge(color=\"black\", width=1)\ncanvas.show()\n</code></pre> </p>"},{"location":"quick_start/#wanna-use-dataframe","title":"Wanna use DataFrame?","text":"<p><code>whitecanvas</code> has a built-in support for DataFrame-like objects for categorical plotting. See Categorical Plotting for more details.</p>"},{"location":"canvas/native_objects/","title":"Working with the Backend Objects","text":""},{"location":"canvas/native_objects/#convert-a-backend-object-to-whitecanvas-canvas","title":"Convert a backend object to <code>whitecanvas</code> canvas","text":"<p>The <code>wrap_canvas</code> converts a backend object to a <code>whitecanvas</code> canvas.</p> <pre><code>from whitecanvas import wrap_canvas\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots()\naxes.set_title(\"Title\")  # operations in the backend side\n\ncanvas = wrap_canvas(axes)  # axes --&gt; canvas\ncanvas.add_line([0, 1, 2, 3, 4])\n\nplt.show()  # backend methods still work\n</code></pre>"},{"location":"canvas/native_objects/#retrieve-the-backend-object-from-a-whitecanvas-canvas","title":"Retrieve the backend object from a <code>whitecanvas</code> canvas","text":"<p>The backend object is available at the <code>native</code>{.interpreted-text role=\"attr\"} property.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n</code></pre>"},{"location":"canvas/native_objects/#combine-whitecanvas-with-applications","title":"Combine <code>whitecanvas</code> with Applications","text":""},{"location":"canvas/native_objects/#1-control-matplotlib-qt-application-with-whitecanvas","title":"1. Control <code>matplotlib</code> Qt application with <code>whitecanvas</code>","text":"<pre><code>#!skip\n# use `%gui qt` in IPython\nfrom whitecanvas import new_canvas\nimport matplotlib.pyplot as plt\nfrom qtpy import QtWidgets as QtW\n\ncanvas = new_canvas(\"matplotlib:qt\")\nqt_canvas = canvas.native.get_figure().canvas\n\nmain = QtW.QMainWindow()\nmain.setWindowTitle(\"myapp\")\nmain.setCentralWidget(qt_canvas)\nmain.show()\n</code></pre> <p>Since the <code>canvas</code> points to the same canvas as in the Qt application, you can control the application with <code>whitecanvas</code> API.</p> <pre><code>canvas.add_line([0, 1, 2, 3, 4])\n</code></pre>"},{"location":"canvas/xy_axis/","title":"Customize X/Y axis","text":"<p>Properties related to the X/Y axis can be customized using the <code>x</code> and <code>y</code> namespaces. Axis limits, color etc. can be set via the namespace.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\n\ncanvas.x.lim = (0, 10)\ncanvas.x.color = \"red\"\ncanvas.x.flipped = True\ncanvas.x.set_gridlines(color=\"gray\", width=1, style=\":\")\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/xy_axis/#labels","title":"Labels","text":"<p>You can set x/y labels using the <code>label</code> property.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.label = \"X axis\"\ncanvas.y.label = \"Y axis\"\ncanvas.show()\n</code></pre> </p> <p>The <code>label</code> property is actually another namespace. You can specify the text, font size, etc. separately.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\ncanvas.x.label.text = \"X axis\"\ncanvas.x.label.size = 20\ncanvas.x.label.family = \"Arial\"\ncanvas.x.label.color = \"red\"\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/xy_axis/#ticks","title":"Ticks","text":"<p>The tick properties can be set via <code>ticks</code> property.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.ticks.color = \"red\"\ncanvas.x.ticks.size = 12\ncanvas.x.ticks.family = \"Arial\"\ncanvas.x.ticks.rotation = 45\ncanvas.show()\n</code></pre> </p> <p>You can also override or reset the tick labels.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.ticks.set_labels([0, 1, 2], [\"zero\", \"one\", \"two\"])\ncanvas.x.ticks.reset_labels()\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/","title":"Categorical Plot","text":"<p>Existing Python plotting libraries such as <code>seaborn</code> and <code>plotly</code> have an excellent support for high-level categorical plotting methods that use DataFrame objects as input.</p> <p>In <code>whitecanvas</code>, similar functions are provided, but these methods do not depend on any external plotting libraries or DataFrames, and are more flexible in some cases.</p>"},{"location":"categorical/#the-categorical-plotters","title":"The Categorical Plotters","text":"<p>Methods starting with \"cat\" return categorical plotters. Methods include:</p> <ul> <li><code>cat</code> ... plotter for numerical data in x/y-axis categorized by such as color.</li> <li><code>cat_x</code> ... plotter for categorical data in x-axis.</li> <li><code>cat_y</code> ... plotter for categorical data in y-axis.</li> <li><code>cat_xy</code> ... plotter for categorical data in both x- and y-axis.</li> </ul> <p>These methods need a tabular data and the names of the columns that will be used as the x and y values. Currently, following objects are allowed as the tabular data input:</p> <ul> <li><code>dict</code> of array-like objects</li> <li><code>pandas.DataFrame</code></li> <li><code>polars.DataFrame</code></li> </ul> <p>Following example shows how to make a strip plot.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nrng = np.random.default_rng(12345)\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"value\": rng.normal(size=130),\n}\n\ncanvas.cat_x(df, x=\"label\", y=\"value\").add_stripplot().with_edge(color=\"black\")\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/","title":"Categorical \u00d7 Numerical Data","text":"<p>In this section, following data will be used as an example:</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nrng = np.random.default_rng(12345)\ndf = {\n    \"category\": [\"A\"] * 40 + [\"B\"] * 50,\n    \"observation\": np.concatenate([rng.random(40), rng.random(50) + 1.3]),\n    \"replicate\": [0] * 23 + [1] * 17 + [0] * 22 + [1] * 28,\n    \"temperature\": rng.normal(scale=2.8, size=90) + 22.0,\n}\n</code></pre> <p>How can we visualize the distributions for each category? There are several plots that use categorical axis as either the x- or y-axis, and numerical axis as the other. Examples are:</p> <ul> <li>Strip plot</li> <li>Swarm plot</li> <li>Violin plot</li> <li>Box plot</li> </ul> <p>Aside from the categorical axis, data points may further be grouped by other features, such as the marker symbol and the marker size. Things are even more complicated when the markers represent numerical values, such as their size being proportional to the value, or colored by a colormap.</p> <p><code>whitecanvas</code> provides a consistent and simple interface to handle all these cases. Methods used for this purpose are <code>cat_x</code> and <code>cat_y</code>, where <code>cat_x</code> will deem the x-axis as categorical, and <code>cat_y</code> will do the same for the y-axis.</p> <pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create the categorical plotter.\ncat_plt_x = canvas.cat_x(df, x=\"category\", y=\"observation\")\ncat_plt_y = canvas.cat_y(df, x=\"observation\", y=\"category\")\n</code></pre> <p><code>cat_x</code> and <code>cat_y</code> use the argument <code>x=</code> and <code>y=</code> to specify the columns that are used for the plot, where <code>x=</code> is the categorical axis for <code>cat_x</code> and <code>y=</code> for <code>cat_y</code>.</p> <pre><code>This is one of the important difference between `seaborn`. In `seaborn`, `orient` are\nused to specify the orientation of the plots. This design forces the user to add the\nargument `orient=` to every plot even though the orientation rarely changes during the\nuse of the same figure. In `whitecanvas`, you don't have to specify the orientation\nonce a categorical plotter is created by either `cat_x` or `cat_y`.\n</code></pre> <p>Multiplt columns can be used for the categorical axis, but only one column can be used for the numerical axis.</p> <pre><code># OK\ncanvas.cat_x(df, x=[\"category\", \"replicate\"], y=\"observation\")\n# OK\ncanvas.cat_y(df, x=\"observation\", y=[\"category\", \"replicate\"])\n# NG\ncanvas.cat_x(df, x=\"category\", y=[\"observation\", \"temperature\"])\n</code></pre>"},{"location":"categorical/cat_num/#non-marker-type-plots","title":"Non-marker-type Plots","text":"<p>Since plots without data point markers are more straightforward, we will start with them. It includes <code>add_violinplot</code>, <code>add_boxplot</code>, <code>add_pointplot</code> and <code>add_barplot</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat_x(df, x=\"category\", y=\"observation\").add_violinplot()\ncanvas.show()\n</code></pre> </p> <p>Violins can also be shown in different color. Specify the <code>color=</code> argument to do that.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p>By default, groups with different colors do not overlap. This is controlled by the <code>dodge=</code> argument. Set <code>dodge=False</code> to make them overlap (although it is not the way we usually do).</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\", dodge=False)\n)\ncanvas.show()\n</code></pre> </p> <p><code>hatch=</code> can also be specified in a similar way. It will change the hatch pattern of the violins.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(hatch=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p><code>color</code> and <code>hatch</code> can overlap with each other or the <code>x=</code> or <code>y=</code> argument.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"category\")\n)\ncanvas.show()\n</code></pre> </p> <p><code>add_boxplot</code>, <code>add_pointplot</code> and <code>add_barplot</code> is very similar to <code>add_violinplot</code>.</p> <p><pre><code>from whitecanvas import hgrid\n\ncanvas = hgrid(ncols=3, size=(1600, 600), backend=\"matplotlib\")\n\nc0 = canvas.add_canvas(0)\nc0.cat_x(df, x=\"category\", y=\"observation\").add_boxplot()\nc0.title = \"boxplot\"\n\nc1 = canvas.add_canvas(1)\nc1.cat_x(df, x=\"category\", y=\"observation\").add_pointplot()\nc1.title = \"pointplot\"\n\nc2 = canvas.add_canvas(2)\nc2.cat_x(df, x=\"category\", y=\"observation\").add_barplot()\nc2.title = \"barplot\"\n\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#marker-type-plots","title":"Marker-type Plots","text":"<p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\")\n)\n</code></pre> </p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n)\n</code></pre> </p> <p>As for the <code>Markers</code> layer, <code>as_edge_only</code> will convert the face features to the edge features.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n    .as_edge_only(width=2)\n)\n</code></pre> </p> <p>Each marker size can represent a numerical value. <code>with_size</code> will map the numerical values of a column to the size of the markers.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot()\n    .with_size(\"temperature\")\n)\n</code></pre> </p> <p>Similarly, each marker color can represent a numerical value. <code>with_colormap</code> will map the value with an arbitrary colormap.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot()\n    .with_colormap(\"temperature\", cmap=\"coolwarm\")\n)\n</code></pre> </p> <p>Swarm plot is another way to visualize all the data points with markers.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_swarmplot(sort=True)\n    .with_colormap(\"temperature\", cmap=\"coolwarm\")\n)\n</code></pre> </p>"},{"location":"categorical/cat_num/#aggregation","title":"Aggregation","text":"<p>Showing the aggregated data is a common way to efficiently visualize a lot of data. This task is usually done by the module specific group-by methods, but <code>whitecanvas</code> provides a built-in method to simplify the process.</p> <p>In following example, <code>mean()</code> is used to prepare a mean-aggregated plotter, which has <code>add_markers</code> method to add the mean markers to the plotter.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create a categorical plotter\ncat_plt = canvas.cat_x(df, x=\"category\", y=\"observation\")\n\n# plot all the data\ncat_plt.add_stripplot(color=\"category\")\n# plot the mean\ncat_plt.mean().add_markers(color=\"category\", size=20)\n\ncanvas.show()\n</code></pre> </p> <p>Similar <code>add_*</code> methods include <code>add_line()</code> and <code>add_bars()</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create a categorical plotter\ncat_plt = canvas.cat_x(df, x=\"category\", y=\"observation\")\n\n# plot all the data\ncat_plt.add_stripplot(color=\"category\")\n# plot the mean\ncat_plt.mean().add_line(width=3, color=\"black\")\n\ncanvas.show()\n</code></pre> </p> <p>Count plot is a special case of the aggregation. Use <code>count()</code> to make the plotter.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\")\n    .count()\n    .add_bars(color=\"replicate\", dodge=True)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/num_num/","title":"Numerical \u00d7 Numerical Data","text":""},{"location":"categorical/num_num/#categorical-lines-and-markers","title":"Categorical Lines and Markers","text":"<p>Line plot and scatter plot use numerical values for both x and y axes. In this case, the plot is categorized by such as color, marker symbol, etc.</p> <pre><code>from whitecanvas import new_canvas\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 5 + [\"B\"] * 5,\n    \"x\": [0, 1, 2, 3, 4, 0, 1, 2, 3, 4],\n    \"y\": [3, 1, 2, 4, 3, 5, 3, 3, 1, 2],\n}\n</code></pre> <p>By setting <code>color=</code> to one of the column name, lines are split by the column and different colors are used for each group.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>By setting <code>style=</code>, different line styles are used instead. In the following example, <code>color=\"black\"</code> means that all the lines should be the same color (black).</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"black\", style=\"label\")\ncanvas.show()\n</code></pre> </p> <p>In the case of markers, you can use symbols to distinguish groups.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_markers(symbol=\"label\")\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/num_num/#distribution-of-numerical-data","title":"Distribution of Numerical Data","text":"<p>There are several ways to visualize the distribution of numerical data.</p> <ul> <li>Histogram</li> <li>Kernel Density Estimation (KDE)</li> </ul> <p>These representations only use one array of numerical data. Therefore, either <code>x</code> or <code>y</code> should be empty in the <code>cat</code> method.</p> <pre><code>import numpy as np\n\nrng = np.random.default_rng(12345)\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"X\": rng.normal(loc=0.0, size=130),\n    \"Y\": rng.normal(loc=1.0, size=130),\n}\n</code></pre> <p><code>x=\"X\"</code> means that the x-axis being \"X\" and the y-axis being the count. Arguments forwards to the <code>histogram</code> method of <code>numpy</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>To transpose the histogram, use <code>y=\"X\"</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, y=\"X\").add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>Histograms can be grouped by color.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_hist(bins=10, color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>If both <code>x</code> and <code>y</code> are set, the plotter cannot determine which axis to use. To tell the plotter which axis to use, call <code>along_x()</code> or <code>along_y()</code> to restrict the dimension.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n# canvas.cat(df, x=\"label\", y=\"X\").add_hist(bins=10)  # This will raise an error\ncanvas.cat(df, x=\"label\", y=\"X\").along_y().add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>KDE can be similarly added.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_kde(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>2-dimensional histogram can be added by <code>add_hist2d</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\", y=\"Y\").add_hist2d(cmap=[\"white\", \"blue\"], bins=(8, 10))\ncanvas.show()\n</code></pre> </p> <p>Note</p> <p><code>add_hist</code> and <code>add_hist2d</code> returns completely different objects (histogram and heatmap) and they are configured by different arguments. That's why <code>whitecanvas</code> split them into two different methods.</p>"},{"location":"layers/face_layers/","title":"Face&amp;Edge-type Layers","text":"<p>There are several layers that is composed of faces and edges.</p> <ul> <li><code>Markers</code> ... a layers composed of markers for scatter plots.</li> <li><code>Bars</code> ... a layer composed of bars.</li> <li><code>Band</code> ... a layer composed of a band region (fill-between region).</li> <li><code>Spans</code> ... a layer composed of infinitely long spans.</li> </ul> <p>These layers have two namespaces: <code>face</code> and <code>edge</code>. <code>face</code> has following properties:</p> <ul> <li><code>color</code> ... color of the faces. Any color-like object is accepted.</li> <li><code>hatch</code> ... hatch pattern of the faces. Should be one of <code>\"\"</code>, <code>\"-\"</code>, <code>\"|</code>, <code>\"+\"</code>,   <code>\"/\"</code>, <code>\"\\\\\"</code>, <code>\"x\"</code> or <code>\".\"</code>.</li> </ul> <p>Note</p> <p><code>hatch</code> is not supported in some backends.</p> <p><code>edge</code> has following properties:</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>Methods for adding these layers always configure the <code>face</code> properties with the arguments. You can use the <code>with_edge</code> method of the output layer to set edge properties. This separation is very helpful to prevent the confusion of the arguments, especially the colors.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = canvas.add_markers(np.arange(10), color=\"yellow\").with_edge(color=\"black\")\ncanvas.show()\n</code></pre> </p> <p>All the properties can be set via properties of <code>face</code> and <code>edge</code>, or the <code>update</code> method.</p> <pre><code>layer.face.color = \"yellow\"\nlayer.face.hatch = \"x\"\n\nlayer.edge.color = \"black\"\nlayer.edge.width = 2\nlayer.edge.style = \"--\"\n\n# use `update`\nlayer.face.update(color=\"yellow\", hatch=\"x\")\nlayer.edge.update(color=\"black\", width=2, style=\"--\")\n</code></pre>"},{"location":"layers/face_layers/#multi-faces-and-multi-edges","title":"Multi-faces and Multi-edges","text":"<p><code>Markers</code> and <code>Bars</code> supports multi-faces and multi-edges. This means that you can create a layer with multiple colors, widths, etc.</p> <p>To do this, you have to call <code>with_face_multi</code> or <code>with_edge_multi</code> method. Here's an example of <code>Markers</code> with multi-faces.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = canvas.add_markers(\n    np.arange(10),\n).with_face_multi(\n    color=np.random.random((10, 3)),  # random colors\n)\ncanvas.show()\n</code></pre> </p> <p>After calling <code>with_face_multi</code>, the layer <code>face</code> property will return arrays instead of scalar values.</p> <pre><code>layer.face.color  # (N, 4) array of RGBA colors\nlayer.face.hatch  # (N,) array of hatchs\nlayer.face.alpha # (N,) array of alpha values\n</code></pre>"},{"location":"layers/layer_groups/","title":"Layer Groups","text":"<p>To plot complex layers, <code>whitecanvas</code> uses the layer-grouping strategy. There are several built-in layer groups.</p> <ul> <li><code>Plot</code> = <code>Line</code> + <code>Markers</code></li> <li><code>LineBand</code> = <code>Line</code> + <code>Band</code></li> <li><code>LabeledLine</code> = <code>Line</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledMarkers</code> = <code>Markers</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledBars</code> = <code>Bars</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledPlot</code> = <code>Plot</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>Stem</code> = <code>Markers</code> + <code>MultiLine</code></li> <li><code>Graph</code> = <code>Markers</code> + <code>MultiLine</code> + <code>Texts</code></li> </ul> <p>These layer groups can be derived from primitive layers. For example, in the following code, markers are added to the line at the node positions, resulting in a <code>Plot</code> layer.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.add_line(\n    [0, 1, 2], [3, 2, 1], color=\"black\",\n).with_markers(\n    symbol=\"o\", color=\"red\"\n)\ncanvas.show()\n</code></pre> </p> <p>The <code>Plot</code> layer can be further converted into a <code>LabeledPlot</code> layer by adding error bars using <code>with_yerr</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.add_line(\n    [0, 1, 2], [3, 2, 1], color=\"black\",\n).with_markers(\n    symbol=\"o\", color=\"red\"\n).with_yerr(\n    [0.1, 0.2, 0.3]\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/line_layers/","title":"Line-type Layers","text":"<p>There are several layers that is composed of only lines.</p> <ul> <li><code>Line</code> ... a simple line.</li> <li><code>InfLine</code> ... a straight line that extends to infinity</li> <li><code>InfCurve</code> ... a curve that extends to infinity</li> <li><code>Errorbar</code> ... lines representing error bars</li> <li><code>Rug</code> ... lines representing rug plots</li> </ul> <p>These layers have following properties in common.</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>,     <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>These properties can be configured in function calls, via properties or the <code>update</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n# function call\nlayer = canvas.add_line(np.arange(10), color=\"black\", width=2, style=\":\")\n\n# properties\nlayer.color = \"#FF36D9\"\nlayer.width = 2.5\nlayer.style = \"-\"\n\n# update method\nlayer.update(color=[0.0, 1.0, 0.0, 1.0], width=1, style=\"--\")\ncanvas.show()\n</code></pre> </p>"}]}