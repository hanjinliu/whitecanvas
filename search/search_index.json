{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"whitecanvas","text":"<p><code>whitecanvas</code> is a type safe and backend independent plotting library for Python.</p>"},{"location":"#source","title":"Source","text":"<p>Jump to GitHub repository.</p>"},{"location":"#project-philosophy","title":"Project Philosophy","text":""},{"location":"#type-safety","title":"Type safety","text":"<p>All the methods should be designed to have nice signature, and should return the same type of object, so that your program can be statically checked by the IDE.</p>"},{"location":"#backend-independency","title":"Backend independency","text":"<p>Every plotting library has their own strength and weakness. Same code should work on different backends, so that you can choose the best one for different purposes.</p> <p>Currently supported backends are <code>matplotlib</code>, <code>pyqtgraph</code>, <code>vispy</code>, <code>plotly</code> and <code>bokeh</code>. If you want other backends, please feel free to open an issue.</p>"},{"location":"#api-tidiness","title":"API tidiness","text":"<p>Most of (probably all of) the plotting libraries rely on the large number of arguments to configure the plot elements. They are usually hard to remember, forcing you to look up the documentation every time you want to make a plot.</p> <p><code>whitecanvas</code> tries to organize the methods, namespaces and arguments carefully so that you can make any kind of plot only with the help of the IDE's auto-completion and suggestions.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>whitecanvas</code> is available on PyPI.</p> <pre><code>pip install whitecanvas -U\n</code></pre> <p>You can also install backend optional dependencies using one of the following commands.</p> <pre><code>pip install whitecanvas[matplotlib] -U\npip install whitecanvas[pyqtgraph] -U\npip install whitecanvas[vispy] -U\npip install whitecanvas[plotly] -U\npip install whitecanvas[bokeh] -U\n</code></pre>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#create-a-canvas","title":"Create a canvas","text":"<p>The <code>new_canvas</code> function creates a new canvas, in which you can add many graphical elements. Created canvas can be shown by calling <code>show</code>.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas()  # create a canvas\ncanvas.show()  # show the canvas\n</code></pre> </p> <p>As <code>whitecanvas</code> is backend independent, you can specify a plotting backend when creating the canvas.</p> <pre><code>canvas = new_canvas(backend=\"matplotlib\")  # matplotlib backend\n</code></pre> <p>Currently supported backends are:</p> <ul> <li>matplotlib</li> <li>pyqtgraph</li> <li>vispy</li> <li>plotly</li> <li>bokeh</li> </ul> <p>For each backend, they also have their own application backend. For example, <code>matplotlib</code> has <code>Qt</code>, <code>Tk</code> and many other backends, and <code>pyqtgraph</code> has <code>Qt</code> and <code>notebook</code> backend. You can add a suffix with separator \":\" to the backend name to specify which application backend to use.</p> <pre><code>canvas = new_canvas(backend=\"matplotlib:qt\")  # matplotlib with Qt backend\ncanvas = new_canvas(backend=\"pyqtgraph:notebook\")  # pyqtgraph with notebook backend\n</code></pre>"},{"location":"quick_start/#lets-plot","title":"Let's plot!","text":"<p>Here is a simple example to add a line and a scatter plot to the canvas.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1])\ncanvas.show()\n</code></pre> </p> <p>You can also add more options.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\ncanvas.add_line([0, 1, 2, 3], [0, 1, 1, 0], color=\"red\", width=2, style=\":\")\ncanvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1], symbol=\"s\", size=20, color=\"blue\")\ncanvas.show()\n</code></pre> </p> <p>Methods always return a <code>Layer</code> object (with minor exceptions), which is also added to the list-like <code>layers</code> attribute of the canvas.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\nline_layer = canvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\nmarkers_layer = canvas.add_markers([0, 1, 2, 3], [1, 2, 0, 1])\ncanvas.layers[0] is line_layer  # True\ncanvas.layers[1] is markers_layer  # True\n</code></pre> <p>Color, size, style, etc. can also be configured via the layer properties.</p> <pre><code>line_layer.color = \"red\"\nmarkers_layer.symbol = \"s\"\n</code></pre> <p>A major difference between <code>whitecanvas</code> and other plotting libraries is that all the edge properties are set using <code>with_edge</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\nmarkers_layer = canvas.add_markers(\n    [0, 1, 2, 3], [1, 2, 0, 1]\n).with_edge(color=\"black\", width=1)\ncanvas.show()\n</code></pre> </p>"},{"location":"quick_start/#wanna-use-dataframes","title":"Wanna use DataFrames?","text":"<p><code>whitecanvas</code> has a built-in support for DataFrame-like objects for categorical plotting. See Categorical Plotting for more details.</p>"},{"location":"api/canvas/","title":"whitecanvas.canvas","text":""},{"location":"api/canvas/#whitecanvas.canvas.Canvas","title":"<code>Canvas</code>","text":"Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>class Canvas(CanvasBase):\n    _CURRENT_INSTANCE: Canvas | None = None\n\n    def __init__(\n        self,\n        backend: str | None = None,\n        *,\n        palette: ColormapType | None = None,\n    ):\n        self._backend = Backend(backend)\n        self._backend_object = self._create_backend_object()\n        super().__init__(palette=palette)\n        self.__class__._CURRENT_INSTANCE = self\n\n    @classmethod\n    def from_backend(\n        cls,\n        obj: protocols.CanvasProtocol,\n        *,\n        palette: ColormapType | None = None,\n        backend: str | None = None,\n    ) -&gt; Self:\n        \"\"\"Create a canvas object from a backend object.\"\"\"\n        with patch_dummy_backend() as name:\n            # this patch will delay initialization by \"_init_canvas\" until the backend\n            # objects are created.\n            self = cls(backend=name, palette=palette)\n        self._backend = Backend(backend)\n        self._backend_object = obj\n        self._init_canvas()\n        return self\n\n    def _create_backend_object(self) -&gt; protocols.CanvasProtocol:\n        return self._backend.get(\"Canvas\")()\n\n    def _get_backend(self):\n        return self._backend\n\n    def _canvas(self) -&gt; protocols.CanvasProtocol:\n        return self._backend_object\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.Canvas.from_backend","title":"<code>from_backend(obj, *, palette=None, backend=None)</code>  <code>classmethod</code>","text":"<p>Create a canvas object from a backend object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>@classmethod\ndef from_backend(\n    cls,\n    obj: protocols.CanvasProtocol,\n    *,\n    palette: ColormapType | None = None,\n    backend: str | None = None,\n) -&gt; Self:\n    \"\"\"Create a canvas object from a backend object.\"\"\"\n    with patch_dummy_backend() as name:\n        # this patch will delay initialization by \"_init_canvas\" until the backend\n        # objects are created.\n        self = cls(backend=name, palette=palette)\n    self._backend = Backend(backend)\n    self._backend_object = obj\n    self._init_canvas()\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase","title":"<code>CanvasBase</code>","text":"<p>Base class for any canvas object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>class CanvasBase(ABC):\n    \"\"\"Base class for any canvas object.\"\"\"\n\n    title = _ns.TitleNamespace()\n    x = _ns.XAxisNamespace()\n    y = _ns.YAxisNamespace()\n    dims = Dims()\n    layers = _ll.LayerList()\n    overlays = _ll.LayerList()\n    events: CanvasEvents\n\n    def __init__(self, palette: ColormapType | None = None):\n        if palette is None:\n            palette = theme.get_theme().palette\n        self._color_palette = ColorPalette(palette)\n        self.events = CanvasEvents()\n        self._is_grouping = False\n        self._autoscale_enabled = True\n        if not self._get_backend().is_dummy():\n            self._init_canvas()\n\n    def _init_canvas(self):\n        # default colors and font\n        _t = theme.get_theme()\n        _ft = _t.font\n        self.x.color = _t.foreground_color\n        self.y.color = _t.foreground_color\n        self.x.label.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.y.label.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.title.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.x.ticks.update(family=_ft.family, color=_ft.color, size=_ft.size)\n        self.y.ticks.update(family=_ft.family, color=_ft.color, size=_ft.size)\n\n        # connect layer events\n        self.layers.events.inserted.connect(self._cb_inserted, unique=True)\n        self.layers.events.removed.connect(self._cb_removed, unique=True)\n        self.layers.events.reordered.connect(self._cb_reordered, unique=True)\n        self.layers.events.connect(self._draw_canvas, unique=True)\n\n        self.overlays.events.inserted.connect(self._cb_overlay_inserted, unique=True)\n        self.overlays.events.removed.connect(self._cb_removed, unique=True)\n        self.overlays.events.connect(self._draw_canvas, unique=True)\n\n        canvas = self._canvas()\n        canvas._plt_connect_xlim_changed(self._emit_xlim_changed)\n        canvas._plt_connect_ylim_changed(self._emit_ylim_changed)\n\n    def _install_mouse_events(self):\n        canvas = self._canvas()\n        canvas._plt_connect_mouse_click(self.events.mouse_clicked.emit)\n        canvas._plt_connect_mouse_click(self.events.mouse_moved.emit)\n        canvas._plt_connect_mouse_drag(self.events.mouse_moved.emit)\n        canvas._plt_connect_mouse_release(self.events.mouse_moved.emit)\n        canvas._plt_connect_mouse_double_click(self.events.mouse_double_clicked.emit)\n        canvas._plt_connect_mouse_double_click(self.events.mouse_moved.emit)\n\n    def _emit_xlim_changed(self, lim):\n        self.x.events.lim.emit(lim)\n        self.events.lims.emit(Rect(*lim, *self.y.lim))\n\n    def _emit_ylim_changed(self, lim):\n        self.y.events.lim.emit(lim)\n        self.events.lims.emit(Rect(*self.x.lim, *lim))\n\n    def _emit_mouse_moved(self, ev):\n        \"\"\"Emit mouse moved event with autoscaling blocked\"\"\"\n        _was_enabled = self._autoscale_enabled\n        # If new layers are added during the mouse move event, the canvas\n        # should not be autoscaled, otherwise unexpected values will be\n        # passed to the callback functions.\n        self._autoscale_enabled = False\n        try:\n            self.events.mouse_moved.emit(ev)\n        finally:\n            self._autoscale_enabled = _was_enabled\n\n    @abstractmethod\n    def _get_backend(self) -&gt; Backend:\n        \"\"\"Return the backend.\"\"\"\n\n    @abstractmethod\n    def _canvas(self) -&gt; protocols.CanvasProtocol:\n        \"\"\"Return the canvas object.\"\"\"\n\n    def _draw_canvas(self):\n        self._canvas()._plt_draw()\n        self.events.drawn.emit()\n\n    @property\n    def native(self) -&gt; Any:\n        \"\"\"Return the native canvas object.\"\"\"\n        return self._canvas()._plt_get_native()\n\n    @property\n    def aspect_ratio(self) -&gt; float | None:\n        \"\"\"Aspect ratio of the canvas (None if not locked).\"\"\"\n        return self._canvas()._plt_get_aspect_ratio()\n\n    @aspect_ratio.setter\n    def aspect_ratio(self, ratio: float | None):\n        if ratio is not None:\n            ratio = float(ratio)\n        self._canvas()._plt_set_aspect_ratio(ratio)\n\n    def autoscale(\n        self,\n        xpad: float | tuple[float, float] | None = None,\n        ypad: float | tuple[float, float] | None = None,\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Autoscale the canvas to fit the contents.\n\n        Parameters\n        ----------\n        xpad : float or (float, float), optional\n            Padding in the x direction.\n        ypad : float or (float, float), optional\n            Padding in the y direction.\n        \"\"\"\n        ar = np.stack([layer.bbox_hint() for layer in self.layers], axis=0)\n        xmin = np.min(ar[:, 0])\n        xmax = np.max(ar[:, 1])\n        ymin = np.min(ar[:, 2])\n        ymax = np.max(ar[:, 3])\n        x0, x1 = self.x.lim\n        y0, y1 = self.y.lim\n        if np.isnan(xmin):\n            xmin = x0\n        if np.isnan(xmax):\n            xmax = x1\n        if np.isnan(ymin):\n            ymin = y0\n        if np.isnan(ymax):\n            ymax = y1\n        if xpad is not None:\n            xrange = xmax - xmin\n            if is_real_number(xpad):\n                dx0 = dx1 = xpad * xrange\n            else:\n                dx0, dx1 = xpad[0] * xrange, xpad[1] * xrange\n            xmin -= dx0\n            xmax += dx1\n        if ypad is not None:\n            yrange = ymax - ymin\n            if is_real_number(ypad):\n                dy0 = dy1 = ypad * yrange\n            else:\n                dy0, dy1 = ypad[0] * yrange, ypad[1] * yrange\n            ymin -= dy0\n            ymax += dy1\n        small_diff = 1e-6\n        if xmax - xmin &lt; small_diff:\n            xmin -= 0.05\n            xmax += 0.05\n        if ymax - ymin &lt; small_diff:\n            ymin -= 0.05\n            ymax += 0.05\n        self.x.lim = xmin, xmax\n        self.y.lim = ymin, ymax\n        return xmin, xmax, ymin, ymax\n\n    def install_second_y(\n        self,\n        *,\n        palette: ColormapType | None = None,\n    ) -&gt; Canvas:\n        \"\"\"Create a twin canvas that share one of the axis.\"\"\"\n        try:\n            new = self._canvas()._plt_twinx()\n        except AttributeError:\n            raise NotImplementedError(\n                f\"Backend {self._get_backend()} does not support `install_second_y`.\"\n            )\n        canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n        canvas._init_canvas()\n        return canvas\n\n    def install_inset(\n        self,\n        rect: Rect | tuple[float, float, float, float],\n        *,\n        palette: ColormapType | None = None,\n    ) -&gt; Canvas:\n        if not isinstance(rect, Rect):\n            rect = Rect(*rect)\n        try:\n            new = self._canvas()._plt_inset(rect)\n        except AttributeError:\n            raise NotImplementedError(\n                f\"Backend {self._get_backend()} does not support `install_inset`\"\n            )\n        canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n        canvas._init_canvas()\n        return canvas\n\n    @property\n    def visible(self):\n        \"\"\"Show the canvas.\"\"\"\n        return self._canvas()._plt_get_visible()\n\n    @visible.setter\n    def visible(self, visible):\n        \"\"\"Hide the canvas.\"\"\"\n        self._canvas()._plt_set_visible(visible)\n\n    @property\n    def lims(self) -&gt; Rect:\n        \"\"\"Return the x/y limits of the canvas.\"\"\"\n        return Rect(*self.x.lim, *self.y.lim)\n\n    @lims.setter\n    def lims(self, lims: tuple[float, float, float, float]):\n        xmin, xmax, ymin, ymax = lims\n        if xmin &gt;= xmax or ymin &gt;= ymax:\n            raise ValueError(f\"Invalid view rect: {Rect(*lims)}\")\n        with self.events.lims.blocked():\n            self.x.lim = xmin, xmax\n            self.y.lim = ymin, ymax\n        self.events.lims.emit(Rect(xmin, xmax, ymin, ymax))\n\n    def update_axes(\n        self,\n        visible: bool = _void,\n        color: ColorType | None = _void,\n    ):\n        if visible is not _void:\n            self.x.ticks.visible = visible\n            self.y.ticks.visible = visible\n        if color is not _void:\n            self.x.color = color\n            self.x.ticks.color = color\n            self.x.label.color = color\n            self.y.color = color\n            self.y.ticks.color = color\n            self.y.label.color = color\n        return self\n\n    def update_labels(\n        self,\n        title: str | None = None,\n        x: str | None = None,\n        y: str | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Helper function to update the title, x, and y labels.\n\n        &gt;&gt;&gt; from whitecanvas import new_canvas\n        &gt;&gt;&gt; canvas = new_canvas(\"matplotlib\").update_labels(\"Title\", \"X\", \"Y\")\n        \"\"\"\n        if title is not None:\n            self.title.text = title\n            self.title.visible = True\n        if x is not None:\n            self.x.label.text = x\n            self.x.label.visible = True\n        if y is not None:\n            self.y.label.text = y\n            self.y.label.visible = True\n        return self\n\n    def cat(\n        self,\n        data: _DF,\n        x: str | None = None,\n        y: str | None = None,\n        *,\n        update_labels: bool = True,\n    ) -&gt; _df.CatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting.\n\n        This method provides categorical plotting methods for the input data.\n        Methods are very similar to `seaborn` and `plotly.express`.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str, optional\n            Name of the column that will be used for the x-axis. Must be numerical.\n        y : str, optional\n            Name of the column that will be used for the y-axis. Must be numerical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n\n        Returns\n        -------\n        CatPlotter\n            Plotter object.\n        \"\"\"\n        plotter = _df.CatPlotter(self, data, x, y, update_label=update_labels)\n        return plotter\n\n    def cat_x(\n        self,\n        data: _DF,\n        x: str | Sequence[str] | None = None,\n        y: str | None = None,\n        *,\n        update_labels: bool = True,\n    ) -&gt; _df.XCatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting with x-axis as a categorical axis.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str or sequence of str, optional\n            Name of the column(s) that will be used for the x-axis. Must be categorical.\n        y : str, optional\n            Name of the column that will be used for the y-axis. Must be numerical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n\n        Returns\n        -------\n        XCatPlotter\n            Plotter object.\n        \"\"\"\n        return _df.XCatPlotter(self, data, x, y, update_labels)\n\n    def cat_y(\n        self,\n        data: _DF,\n        x: str | None = None,\n        y: str | Sequence[str] | None = None,\n        *,\n        update_labels: bool = True,\n    ) -&gt; _df.YCatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting with y-axis as a categorical axis.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str, optional\n            Name of the column that will be used for the x-axis. Must be numerical.\n        y : str or sequence of str, optional\n            Name of the column(s) that will be used for the y-axis. Must be categorical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n\n        Returns\n        -------\n        YCatPlotter\n            Plotter object\n        \"\"\"\n        return _df.YCatPlotter(self, data, y, x, update_labels)\n\n    def cat_xy(\n        self,\n        data: _DF,\n        x: str | Sequence[str],\n        y: str | Sequence[str],\n        *,\n        update_labels: bool = True,\n    ) -&gt; _df.XYCatPlotter[Self, _DF]:\n        \"\"\"\n        Categorize input data for plotting with both axes as categorical.\n\n        Parameters\n        ----------\n        data : tabular data\n            Any categorizable data. Currently, dict, pandas.DataFrame, and\n            polars.DataFrame are supported.\n        x : str or sequence of str, optional\n            Name of the column(s) that will be used for the x-axis. Must be categorical.\n        y : str or sequence of str, optional\n            Name of the column(s) that will be used for the y-axis. Must be categorical.\n        update_labels : bool, default True\n            If True, update the x/y labels to the corresponding names.\n\n        Returns\n        -------\n        XYCatPlotter\n            Plotter object\n        \"\"\"\n        return _df.XYCatPlotter(self, data, x, y, update_labels)\n\n    def stack_over(self, layer: _L0) -&gt; StackOverPlotter[Self, _L0]:\n        \"\"\"\n        Stack new data over the existing layer.\n\n        For example following code\n\n        &gt;&gt;&gt; bars_0 = canvas.add_bars(x, y0)\n        &gt;&gt;&gt; bars_1 = canvas.stack_over(bars_0).add(y1)\n        &gt;&gt;&gt; bars_2 = canvas.stack_over(bars_1).add(y2)\n\n        will result in a bar plot like this\n\n        ```\n         \u250c\u2500\u2500\u2500\u2510\n         \u251c\u2500\u2500\u2500\u2502\u250c\u2500\u2500\u2500\u2510\n         \u2502   \u2502\u251c\u2500\u2500\u2500\u2502\n         \u251c\u2500\u2500\u2500\u2502\u251c\u2500\u2500\u2500\u2502\n        \u2500\u2534\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\n        ```\n        \"\"\"\n        if not isinstance(layer, (_l.Bars, _l.Band, _lg.StemPlot, _lg.LabeledBars)):\n            raise TypeError(\n                f\"Only Bars and Band are supported as an input, \"\n                f\"got {type(layer)!r}.\"\n            )\n        return StackOverPlotter(self, layer)\n\n    # TODO\n    # def annotate(self, layer, at: int):\n    #     ...\n\n    def between(self, l0, l1) -&gt; BetweenPlotter[Self]:\n        return BetweenPlotter(self, l0, l1)\n\n    def imref(self, layer: _l.Image) -&gt; ImageRef[Self]:\n        \"\"\"The Image reference namespace.\"\"\"\n        while isinstance(layer, _l.LayerWrapper):\n            layer = layer._base_layer\n        if not isinstance(layer, _l.Image):\n            raise TypeError(\n                f\"Expected an Image layer or its wrapper, got {type(layer)}.\"\n            )\n        return ImageRef(self, layer)\n\n    def fit(self, layer: _l.DataBoundLayer[_P]) -&gt; FitPlotter[Self, _P]:\n        \"\"\"The fit plotter namespace.\"\"\"\n        return FitPlotter(self, layer)\n\n    @overload\n    def add_line(\n        self, ydata: ArrayLike1D, *, name: str | None = None,\n        color: ColorType | None = None, width: float = 1.0,\n        style: LineStyle | str = LineStyle.SOLID, alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.Line:  # fmt: skip\n        ...\n\n    @overload\n    def add_line(\n        self, xdata: ArrayLike1D, ydata: ArrayLike1D, *, name: str | None = None,\n        color: ColorType | None = None, width: float | None = None,\n        style: LineStyle | str | None = None, alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.Line:  # fmt: skip\n        ...\n\n    @overload\n    def add_line(\n        self, xdata: ArrayLike1D, ydata: Callable[[ArrayLike1D], ArrayLike1D], *,\n        name: str | None = None, color: ColorType | None = None,\n        width: float | None = None, style: LineStyle | str | None = None,\n        alpha: float = 1.0, antialias: bool = True,\n    ) -&gt; _l.Line:  # fmt: skip\n        ...\n\n    def add_line(\n        self,\n        *args,\n        name=None,\n        color=None,\n        width=None,\n        style=None,\n        alpha=1.0,\n        antialias=True,\n    ):\n        \"\"\"\n        Add a Line layer to the canvas.\n\n        &gt;&gt;&gt; canvas.add_line(y, ...)\n        &gt;&gt;&gt; canvas.add_line(x, y, ...)\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        Line\n            The line layer.\n        \"\"\"\n        xdata, ydata = normalize_xy(*args)\n        name = self._coerce_name(_l.Line, name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.Line(\n            xdata, ydata, name=name, color=color, width=width, style=style,\n            alpha=alpha, antialias=antialias, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    @overload\n    def add_markers(\n        self, xdata: ArrayLike1D, ydata: ArrayLike1D, *,\n        name: str | None = None, symbol: Symbol | str | None = None,\n        size: float | None = None, color: ColorType | None = None, alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Markers[_mixin.ConstFace, _mixin.ConstEdge, float]:  # fmt: skip\n        ...\n\n    @overload\n    def add_markers(\n        self, ydata: ArrayLike1D, *,\n        name: str | None = None, symbol: Symbol | str | None = None,\n        size: float | None = None, color: ColorType | None = None, alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Markers[_mixin.ConstFace, _mixin.ConstEdge, float]:  # fmt: skip\n        ...\n\n    def add_markers(\n        self,\n        *args,\n        name=None,\n        symbol=None,\n        size=None,\n        color=None,\n        alpha=1.0,\n        hatch=None,\n    ):\n        \"\"\"\n        Add markers (scatter plot).\n\n        &gt;&gt;&gt; canvas.add_markers(x, y)  # standard usage\n        &gt;&gt;&gt; canvas.add_markers(y)  # use 0, 1, ... for the x values\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the layer.\n        symbol : str or Symbol, optional\n            Marker symbols. Use the theme default if not specified.\n        size : float, optional\n            Marker size. Use the theme default if not specified.\n        color : color-like, optional\n            Color of the marker faces.\n        alpha : float, default 1.0\n            Alpha channel of the marker faces.\n        hatch : str or FacePattern, optional\n            Pattern of the marker faces. Use the theme default if not specified.\n\n        Returns\n        -------\n        Markers\n            The markers layer.\n        \"\"\"\n        xdata, ydata = normalize_xy(*args)\n        name = self._coerce_name(_l.Markers, name)\n        color = self._generate_colors(color)\n        symbol = theme._default(\"markers.symbol\", symbol)\n        size = theme._default(\"markers.size\", size)\n        hatch = theme._default(\"markers.hatch\", hatch)\n        layer = _l.Markers(\n            xdata, ydata, name=name, symbol=symbol, size=size, color=color,\n            alpha=alpha, hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    @overload\n    def add_bars(\n        self, center: ArrayLike1D, height: ArrayLike1D, *,\n        bottom: ArrayLike1D | None = None, name=None,\n        orient: str | Orientation = Orientation.VERTICAL, extent: float | None = None,\n        color: ColorType | None = None, alpha: float = 1.0,\n        hatch: str | Hatch | None = None,\n    ) -&gt; _l.Bars[_mixin.ConstFace, _mixin.ConstEdge]:  # fmt: skip\n        ...\n\n    @overload\n    def add_bars(\n        self, height: ArrayLike1D, *, bottom: ArrayLike1D | None = None,\n        name=None, orient: str | Orientation = Orientation.VERTICAL,\n        extent: float | None = None, color: ColorType | None = None,\n        alpha: float = 1.0, hatch: str | Hatch | None = None,\n    ) -&gt; _l.Bars[_mixin.ConstFace, _mixin.ConstEdge]:  # fmt: skip\n        ...\n\n    def add_bars(\n        self,\n        *args,\n        bottom=None,\n        name=None,\n        orient=Orientation.VERTICAL,\n        extent=None,\n        color=None,\n        alpha=1.0,\n        hatch=None,\n    ):\n        \"\"\"\n        Add a bar plot.\n\n        &gt;&gt;&gt; canvas.add_bars(x, heights)  # standard usage\n        &gt;&gt;&gt; canvas.add_bars(heights)  # use 0, 1, ... for the x values\n        &gt;&gt;&gt; canvas.add_bars(..., orient=\"horizontal\")  # horizontal bars\n\n        Parameters\n        ----------\n        bottom : float or array-like, optional\n            Bottom level of the bars.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default Orientation.VERTICAL\n            Orientation of the bars.\n        extent : float, default 0.8\n            Bar width in the canvas coordinate\n        color : color-like, optional\n            Color of the bars.\n        alpha : float, default 1.0\n            Alpha channel of the bars.\n        hatch : str or FacePattern, default FacePattern.SOLID\n            Pattern of the bar faces.\n\n        Returns\n        -------\n        Bars\n            The bars layer.\n        \"\"\"\n        center, height = normalize_xy(*args)\n        if bottom is not None:\n            bottom = as_array_1d(bottom)\n            if bottom.shape != height.shape:\n                raise ValueError(\"Expected bottom to have the same shape as height\")\n        name = self._coerce_name(_l.Bars, name)\n        color = self._generate_colors(color)\n        extent = theme._default(\"bars.extent\", extent)\n        hatch = theme._default(\"bars.hatch\", hatch)\n        layer = _l.Bars(\n            center, height, bottom, extent=extent, name=name, orient=orient,\n            color=color, alpha=alpha, hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_hist(\n        self,\n        data: ArrayLike1D,\n        *,\n        bins: HistBinType = \"auto\",\n        limits: tuple[float, float] | None = None,\n        name: str | None = None,\n        shape: Literal[\"step\", \"polygon\", \"bars\"] = \"bars\",\n        kind: Literal[\"count\", \"density\", \"frequency\", \"percent\"] = \"count\",\n        orient: str | Orientation = Orientation.VERTICAL,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n    ) -&gt; _lg.Histogram:\n        \"\"\"\n        Add data as a histogram.\n\n        &gt;&gt;&gt; canvas.add_hist(np.random.normal(size=100), bins=12)\n\n        Parameters\n        ----------\n        data : array-like\n            1D Array of data.\n        bins : int or 1D array-like, default \"auto\"\n            Bins of the histogram. This parameter will directly be passed\n            to `np.histogram`.\n        limits : (float, float), optional\n            Limits in which histogram will be built. This parameter will equivalent to\n            the `range` paraneter of `np.histogram`.\n        name : str, optional\n            Name of the layer.\n        shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n            Shape of the histogram. This parameter defines how to convert the data into\n            the line nodes.\n        kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n            Kind of the histogram.\n        orient : str or Orientation, default Orientation.VERTICAL\n            Orientation of the bars.\n        color : color-like, optional\n            Color of the bars.\n\n        Returns\n        -------\n        Bars\n            The bars layer that represents the histogram.\n        \"\"\"\n        name = self._coerce_name(\"histogram\", name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _lg.Histogram.from_array(\n            data, bins=bins, limits=limits, shape=shape, kind=kind, name=name,\n            color=color, width=width, style=style, orient=orient,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_hist2d(\n        self,\n        x: ArrayLike1D,\n        y: ArrayLike1D,\n        *,\n        cmap: ColormapType = \"inferno\",\n        name: str | None = None,\n        bins: HistBinType | tuple[HistBinType, HistBinType] = \"auto\",\n        rangex: tuple[float, float] | None = None,\n        rangey: tuple[float, float] | None = None,\n        density: bool = False,\n    ) -&gt; _l.Image:\n        \"\"\"\n        Add a 2D histogram of given X/Y data.\n\n        &gt;&gt;&gt; x = np.random.normal(size=100)\n        &gt;&gt;&gt; y = np.random.normal(size=200)\n        &gt;&gt;&gt; canvas.add_hist2d(x, y)\n\n        Note that unlike `add_image()` method, this method does not lock the aspect\n        ratio and flip the canvas by default.\n\n        Parameters\n        ----------\n        x : array-like\n            1D Array of X data.\n        y : array-like\n            1D Array of Y data.\n        cmap : ColormapType, default \"gray\"\n            Colormap used for the image.\n        name : str, optional\n            Name of the layer.\n        bins : int or tuple[int, int], optional\n            Bins of the histogram of X/Y dimension respectively. If an integer is given,\n            it will be used for both dimensions.\n        rangex : (float, float), optional\n            Range of x values in which histogram will be built.\n        rangey : (float, float), optional\n            Range of y values in which histogram will be built.\n        density : bool, default False\n            If True, values of the histogram will be normalized so that the total\n            intensity of the histogram will be 1.\n\n        Returns\n        -------\n        Image\n            Image layer representing the 2D histogram.\n        \"\"\"\n        layer = _l.Image.build_hist(\n            x, y, bins=bins, range=(rangex, rangey), density=density, name=name,\n            cmap=cmap, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_cdf(\n        self,\n        data: ArrayLike1D,\n        *,\n        name: str | None = None,\n        orient: str | Orientation = Orientation.VERTICAL,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.Line:\n        \"\"\"\n        Add a empirical cumulative distribution function (CDF) plot.\n\n        &gt;&gt;&gt; canvas.add_cdf(np.random.normal(size=100))\n\n        Parameters\n        ----------\n        data : array-like\n            1D Array of data.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default Orientation.VERTICAL\n            Orientation of the bars.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        Line\n            The line layer that represents the CDF.\n        \"\"\"\n        name = self._coerce_name(\"histogram\", name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.Line.build_cdf(\n            data, orient=orient, name=name, color=color, width=width, style=style,\n            alpha=alpha, antialias=antialias, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_spans(\n        self,\n        spans: ArrayLike,\n        *,\n        name: str | None = None,\n        orient: str | Orientation = Orientation.VERTICAL,\n        color: ColorType = \"blue\",\n        alpha: float = 0.4,\n        hatch: str | Hatch = Hatch.SOLID,\n    ) -&gt; _l.Spans:\n        \"\"\"\n        Add spans that extends infinitely.\n\n        &gt;&gt;&gt; canvas.add_spans([[5, 10], [15, 20]])\n\n           |::::|     |::::|\n           |::::|     |::::|\n        \u2500\u2500\u25005\u2500\u2500\u2500\u250010\u2500\u2500\u2500\u250015\u2500\u2500\u250020\u2500\u2500\u2500\u2500\u2500&gt;\n           |::::|     |::::|\n           |::::|     |::::|\n\n        Parameters\n        ----------\n        spans : (N, 2) array-like\n            Array that contains the start and end points of the spans.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default Orientation.VERTICAL\n            Orientation of the bars.\n        color : color-like, optional\n            Color of the bars.\n        alpha : float, default 0.4\n            Alpha channel of the bars.\n        hatch : str or FacePattern, default FacePattern.SOLID\n            Pattern of the bar faces.\n\n        Returns\n        -------\n        Spans\n            The spans layer.\n        \"\"\"\n        name = self._coerce_name(\"histogram\", name)\n        color = self._generate_colors(color)\n        layer = _l.Spans(\n            spans, name=name, orient=orient, color=color, alpha=alpha,\n            hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_infline(\n        self,\n        pos: tuple[float, float] = (0, 0),\n        angle: float = 0.0,\n        *,\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfLine:\n        \"\"\"\n        Add an infinitely long line to the canvas.\n\n        &gt;&gt;&gt; canvas.add_infline((0, 0), 45)  # y = x\n        &gt;&gt;&gt; canvas.add_infline((1, 0), 90)  # x = 1\n        &gt;&gt;&gt; canvas.add_infline((0, -1), 0)  # y = -1\n\n        Parameters\n        ----------\n        pos : (float, float), default (0, 0)\n            One of the points this line passes.\n        angle : float, default 0.0\n            Angle of the line in degree, defined by the counter-clockwise\n            rotation from the x axis.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfLine\n            The infline layer.\n        \"\"\"\n        name = self._coerce_name(_l.InfLine, name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.InfLine(\n            pos, angle, name=name, color=color, alpha=alpha,\n            width=width, style=style, antialias=antialias,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_infcurve(\n        self,\n        model: Callable[Concatenate[Any, _P], Any],\n        *,\n        bounds: tuple[float, float] = (-float(\"inf\"), float(\"inf\")),\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: str | LineStyle | None = None,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfCurve[_P]:\n        \"\"\"\n        Add an infinite curve to the canvas.\n\n        &gt;&gt;&gt; canvas.add_infcurve(lambda x: x ** 2)  # parabola\n        &gt;&gt;&gt; canvas.add_infcurve(lambda x, a: np.sin(a*x)).with_params(2)  # parametric\n\n        Parameters\n        ----------\n        model : callable\n            The model function. The first argument must be the x coordinates. Same\n            signature as `scipy.optimize.curve_fit`.\n        bounds : (float, float), default (-inf, inf)\n            Lower and upper bounds that the function is defined.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfCurve\n            The infcurve layer.\n        \"\"\"\n        name = self._coerce_name(_l.InfCurve, name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.InfCurve(\n            model, bounds=bounds, name=name, color=color, width=width, alpha=alpha,\n            style=style, antialias=antialias, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_hline(\n        self,\n        y: float,\n        *,\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str = LineStyle.SOLID,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfLine:\n        \"\"\"\n        Add a infinite horizontal line to the canvas.\n\n        Parameters\n        ----------\n        y : float\n            Y coordinate of the line.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfLine\n            The infline layer.\n        \"\"\"\n        return self.add_infline(\n            (0, y), 0, name=name, color=color, width=width, style=style, alpha=alpha,\n            antialias=antialias\n        )  # fmt: skip\n\n    def add_vline(\n        self,\n        x: float,\n        *,\n        name: str | None = None,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str = LineStyle.SOLID,\n        alpha: float = 1.0,\n        antialias: bool = True,\n    ) -&gt; _l.InfLine:\n        \"\"\"\n        Add a infinite vertical line to the canvas.\n\n        Parameters\n        ----------\n        x : float\n            X coordinate of the line.\n        name : str, optional\n            Name of the layer.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        InfLine\n            The infline layer.\n        \"\"\"\n        return self.add_infline(\n            (x, 0), 90, name=name, color=color, width=width, style=style, alpha=alpha,\n            antialias=antialias,\n        )  # fmt: skip\n\n    def add_band(\n        self,\n        xdata: ArrayLike1D,\n        ylow: ArrayLike1D,\n        yhigh: ArrayLike1D,\n        *,\n        name: str | None = None,\n        orient: str | Orientation = Orientation.VERTICAL,\n        color: ColorType | None = None,\n        alpha: float = 1.0,\n        hatch: str | Hatch = Hatch.SOLID,\n    ) -&gt; _l.Band:\n        \"\"\"\n        Add a band (fill-between) layer to the canvas.\n\n        Parameters\n        ----------\n        xdata : array-like\n            X coordinates of the band.\n        ylow : array-like\n            Either lower or upper y coordinates of the band.\n        yhigh : array-like\n            The other y coordinates of the band.\n        name : str, optional\n            Name of the layer, by default None\n        orient : str, Orientation, default Orientation.VERTICAL\n            Orientation of the band. If vertical, band will be filled between\n            vertical orientation.,\n        color : color-like, default None\n            Color of the band face.,\n        alpha : float, default 1.0\n            Alpha channel of the band face.\n        hatch : str, FacePattern, default FacePattern.SOLID\n            Hatch of the band face.\n\n        Returns\n        -------\n        Band\n            The band layer.\n        \"\"\"\n        name = self._coerce_name(_l.Band, name)\n        color = self._generate_colors(color)\n        layer = _l.Band(\n            xdata, ylow, yhigh, name=name, orient=orient, color=color,\n            alpha=alpha, hatch=hatch, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_errorbars(\n        self,\n        xdata: ArrayLike1D,\n        ylow: ArrayLike1D,\n        yhigh: ArrayLike1D,\n        *,\n        name: str | None = None,\n        orient: str | Orientation = Orientation.VERTICAL,\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n        alpha: float = 1.0,\n        antialias: bool = False,\n        capsize: float = 0.0,\n    ) -&gt; _l.Errorbars:\n        \"\"\"\n        Add parallel lines as errorbars.\n\n        Parameters\n        ----------\n        xdata : array-like\n            X coordinates of the errorbars.\n        ylow : array-like\n            Lower bound of the errorbars.\n        yhigh : array-like\n            Upper bound of the errorbars.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default Orientation.VERTICAL\n            Orientation of the errorbars. If vertical, errorbars will be parallel\n            to the y axis.\n        color : color-like, optional\n            Color of the bars.\n        width : float, optional\n            Line width. Use the theme default if not specified.\n        style : str or LineStyle, optional\n            Line style. Use the theme default if not specified.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n        capsize : float, default 0.0\n            Size of the caps of the error indicators\n\n        Returns\n        -------\n        Errorbars\n            The errorbars layer.\n        \"\"\"\n        name = self._coerce_name(_l.Errorbars, name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n        layer = _l.Errorbars(\n            xdata, ylow, yhigh, name=name, color=color, width=width,\n            style=style, antialias=antialias, capsize=capsize, alpha=alpha,\n            orient=orient, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_rug(\n        self,\n        events: ArrayLike1D,\n        *,\n        low: float = 0.0,\n        high: float = 1.0,\n        name: str | None = None,\n        orient: str | Orientation = Orientation.VERTICAL,\n        color: ColorType = \"black\",\n        width: float = 1.0,\n        style: LineStyle | str = LineStyle.SOLID,\n        antialias: bool = True,\n        alpha: float = 1.0,\n    ) -&gt; _l.Rug:\n        \"\"\"\n        Add input data as a rug plot.\n\n        &gt;&gt;&gt; canvas.add_rug([2, 4, 5, 8, 11])\n\n        ```\n          \u2502 \u2502\u2502  \u2502   \u2502\n        \u2500\u2500\u2534\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500&gt; x\n          2 45  8   11\n        ```\n\n        Parameters\n        ----------\n        events : array-like\n            A 1D array of events.\n        low : float, default 0.0\n            The lower bound of the rug lines.\n        high : float, default 1.0\n            The upper bound of the rug lines.\n        name : str, optional\n            Name of the layer.\n        orient : str or Orientation, default Orientation.VERTICAL\n            Orientation of the errorbars. If vertical, rug lines will be parallel\n            to the y axis.\n        color : color-like, optional\n            Color of the bars.\n        width : float, default 1.0\n            Line width.\n        style : str or LineStyle, default LineStyle.SOLID\n            Line style.\n        alpha : float, default 1.0\n            Alpha channel of the line.\n        antialias : bool, default True\n            Antialiasing of the line.\n\n        Returns\n        -------\n        Rug\n            The rug layer.\n        \"\"\"\n        name = self._coerce_name(_l.Errorbars, name)\n        color = self._generate_colors(color)\n        layer = _l.Rug(\n            events, low=low, high=high, name=name, color=color, alpha=alpha,\n            width=width, style=style, antialias=antialias, orient=orient,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_kde(\n        self,\n        data: ArrayLike1D,\n        *,\n        bottom: float = 0.0,\n        name: str | None = None,\n        orient: str | Orientation = Orientation.VERTICAL,\n        band_width: float | Literal[\"scott\", \"silverman\"] = \"scott\",\n        color: ColorType | None = None,\n        width: float | None = None,\n        style: LineStyle | str | None = None,\n    ) -&gt; _lg.Kde:\n        \"\"\"\n        Add data as a band layer representing kernel density estimation (KDE).\n\n        Parameters\n        ----------\n        data : array-like\n            1D data to calculate the KDE.\n        bottom : float, default 0.0\n            Scalar value that define the height of the bottom line.\n        name : str, optional\n            Name of the layer, by default None\n        orient : str, Orientation, default Orientation.VERTICAL\n            Orientation of the KDE.\n        band_width : float or str, default \"scott\"\n            Band width parameter of KDE. Must be a number or a string as the\n            method to automatic determination.\n        color : color-like, default None\n            Color of the band face.\n        width : float, optional\n            Line width of the outline.\n        style : str or LineStyle, optional\n            Line style of the outline.\n\n        Returns\n        -------\n        Kde\n            The KDE layer.\n        \"\"\"\n        name = self._coerce_name(_lg.Kde, name)\n        color = self._generate_colors(color)\n        width = theme._default(\"line.width\", width)\n        style = theme._default(\"line.style\", style)\n\n        layer = _lg.Kde.from_array(\n            data, bottom=bottom, scale=1, band_width=band_width, name=name,\n            orient=orient, color=color, width=width, style=style,\n            backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    @overload\n    def add_text(\n        self, x: ArrayLike1D, y: ArrayLike1D, string: list[str], *,\n        color: ColorType = \"black\", size: float = 12, rotation: float = 0.0,\n        anchor: str | Alignment = Alignment.BOTTOM_LEFT, family: str | None = None,\n    ) -&gt; _l.Texts[_mixin.ConstFace, _mixin.ConstEdge, _mixin.ConstFont]:  # fmt: skip\n        ...\n\n    @overload\n    def add_text(\n        self, x: float, y: float, string: str, *, color: ColorType = \"black\",\n        size: float = 12, rotation: float = 0.0,\n        anchor: str | Alignment = Alignment.BOTTOM_LEFT, family: str | None = None,\n    ) -&gt; _l.Texts[_mixin.ConstFace, _mixin.ConstEdge, _mixin.ConstFont]:  # fmt: skip\n        ...\n\n    def add_text(\n        self,\n        x,\n        y,\n        string,\n        *,\n        color=\"black\",\n        size=12,\n        rotation=0.0,\n        anchor=Alignment.BOTTOM_LEFT,\n        family=None,\n    ):\n        \"\"\"\n        Add a text layer to the canvas.\n\n        &gt;&gt;&gt; canvas.add_text([0, 0], [1, 1], [\"text-0\", \"text-1])\n        &gt;&gt;&gt; canvas.add_text(...).with_face(color=\"red\")  # with background\n        &gt;&gt;&gt; canvas.add_text(...).with_edge(color=\"red\")  # with outline\n\n        Parameters\n        ----------\n        x : float or array-like\n            X position(s) of the text.\n        y : float or array-like\n            Y position(s) of the text.\n        string : str or list[str]\n            Text string to display.\n        color : ColorType, optional\n            Color of the text string.\n        size : float, default 12\n            Point size of the text.\n        rotation : float, default 0.0\n            Rotation angle of the text in degrees.\n        anchor : str or Alignment, default Alignment.BOTTOM_LEFT\n            Anchor position of the text. The anchor position will be the coordinate\n            given by (x, y).\n        family : str, optional\n            Font family of the text.\n\n        Returns\n        -------\n        Texts\n            The text layer.\n        \"\"\"\n        if is_real_number(x) and is_real_number(y) and isinstance(string, str):\n            x, y, string = [x], [y], [string]\n        x_, y_ = normalize_xy(x, y)\n        if isinstance(string, str):\n            string = [string] * x_.size\n        elif len(string) != x_.size:\n            raise ValueError(\"Expected string to have the same size as x/y\")\n        layer = _l.Texts(\n            x_, y_, string, color=color, size=size, rotation=rotation, anchor=anchor,\n            family=family, backend=self._get_backend(),\n        )  # fmt: skip\n        return self.add_layer(layer)\n\n    def add_image(\n        self,\n        image: ArrayLike,\n        *,\n        name: str | None = None,\n        cmap: ColormapType = \"gray\",\n        clim: tuple[float | None, float | None] | None = None,\n        flip_canvas: bool = True,\n        lock_aspect: bool = True,\n    ) -&gt; _l.Image:\n        \"\"\"\n        Add an image layer to the canvas.\n\n        This method automatically flips the image vertically by default. `add_heatmap`\n        does the similar thing with slightly different default settings.\n\n        Parameters\n        ----------\n        image : ArrayLike\n            Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n            RGB(A). Note that the first dimension is the vertical axis.\n        cmap : ColormapType, default \"gray\"\n            Colormap used for the image.\n        clim : (float or None, float or None) or None\n            Contrast limits. If None, the limits are automatically determined by min and\n            max of the data. You can also pass None separately to either limit to use\n            the default behavior.\n        flip_canvas : bool, default True\n            If True, flip the canvas vertically so that the image looks normal.\n        lock_aspect : bool, default True\n            If True, lock the aspect ratio of the canvas to 1:1.\n\n        Returns\n        -------\n        Image\n            The image layer.\n        \"\"\"\n        layer = _l.Image(\n            image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n        )\n        self.add_layer(layer)\n        if flip_canvas and not self.y.flipped:\n            self.y.flipped = True\n        if lock_aspect:\n            self.aspect_ratio = 1.0\n        return layer\n\n    def add_heatmap(\n        self,\n        image: ArrayLike,\n        *,\n        name: str | None = None,\n        cmap: ColormapType = \"inferno\",\n        clim: tuple[float | None, float | None] | None = None,\n        flip_canvas: bool = False,\n    ) -&gt; _l.Image:\n        \"\"\"\n        Add an image layer to the canvas as a heatmap.\n\n        Use `add_image` to add the layer as an image.\n\n        Parameters\n        ----------\n        image : ArrayLike\n            Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n            RGB(A). Note that the first dimension is the vertical axis.\n        cmap : ColormapType, default \"gray\"\n            Colormap used for the image.\n        clim : (float or None, float or None) or None\n            Contrast limits. If None, the limits are automatically determined by min and\n            max of the data. You can also pass None separately to either limit to use\n            the default behavior.\n        flip_canvas : bool, default False\n            If True, flip the canvas vertically so that the image looks normal.\n\n        Returns\n        -------\n        Image\n            The image layer.\n        \"\"\"\n        layer = _l.Image(\n            image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n        )\n        self.add_layer(layer)\n        if flip_canvas and not self.y.flipped:\n            self.y.flipped = True\n        return layer\n\n    def add_layer(\n        self,\n        layer: _L,\n        *,\n        over: _l.Layer | Iterable[_l.Layer] | None = None,\n        under: _l.Layer | Iterable[_l.Layer] | None = None,\n    ) -&gt; _L:\n        \"\"\"Add a layer to the canvas.\"\"\"\n        if over is None and under is None:\n            self.layers.append(layer)\n        elif over is not None:\n            if under is not None:\n                raise ValueError(\"Cannot specify both `over` and `under`\")\n            if isinstance(over, _l.Layer):\n                idx = self.layers.index(over)\n            else:\n                idx = max([self.layers.index(l) for l in over])\n            self.layers.insert(idx + 1, layer)\n        else:\n            idx = self.layers.index(under)\n            if isinstance(under, _l.Layer):\n                idx = self.layers.index(under)\n            else:\n                idx = min([self.layers.index(l) for l in under])\n            self.layers.insert(idx, layer)\n        return layer\n\n    @overload\n    def group_layers(\n        self,\n        layers: Iterable[_l.Layer],\n        name: str | None = None,\n    ) -&gt; _l.LayerGroup:\n        ...\n\n    @overload\n    def group_layers(self, *layers: _l.Layer, name: str | None = None) -&gt; _l.LayerGroup:\n        ...\n\n    def group_layers(self, layers, *more_layers, name=None):\n        \"\"\"\n        Group layers.\n\n        Parameters\n        ----------\n        layers : iterable of Layer\n            Layers to group.\n\n        Returns\n        -------\n        LayerGroup\n            The grouped layer.\n        \"\"\"\n        if more_layers:\n            if not isinstance(layers, _l.Layer):\n                raise TypeError(\"No overload matches the arguments\")\n            layers = [layers, *more_layers]\n        return _lg.LayerTuple(layers, name=name)\n\n    def _coerce_name(self, layer_type: type[_l.Layer] | str, name: str | None) -&gt; str:\n        if name is None:\n            if isinstance(layer_type, str):\n                name = layer_type\n            else:\n                name = layer_type.__name__.lower()\n        basename = name\n        i = 0\n        _exists = {layer.name for layer in self.layers}\n        while name in _exists:\n            name = f\"{basename}-{i}\"\n            i += 1\n        return name\n\n    def _autoscale_for_layer(\n        self,\n        layer: _l.Layer,\n        pad_rel: float | None = None,\n        maybe_empty: bool = True,\n    ):\n        \"\"\"This function will be called when a layer is inserted to the canvas.\"\"\"\n        if pad_rel is None:\n            pad_rel = 0 if isinstance(layer, _l.Image) else 0.025\n        if not self._autoscale_enabled:\n            return\n        xmin, xmax, ymin, ymax = layer.bbox_hint()\n        if len(self.layers) &gt; 1 or not maybe_empty:\n            # NOTE: if there was no layer, so backend may not have xlim/ylim,\n            # or they may be set to a default value.\n            _xmin, _xmax = self.x.lim\n            _ymin, _ymax = self.y.lim\n            _dx = (_xmax - _xmin) * pad_rel\n            _dy = (_ymax - _ymin) * pad_rel\n            xmin = np.min([xmin, _xmin + _dx])\n            xmax = np.max([xmax, _xmax - _dx])\n            ymin = np.min([ymin, _ymin + _dy])\n            ymax = np.max([ymax, _ymax - _dy])\n\n        # this happens when there is &lt;= 1 data\n        small_diff = 1e-6\n        if np.isnan(xmax) or np.isnan(xmin):\n            xmin, xmax = self.x.lim\n        elif xmax - xmin &lt; small_diff:\n            xmin -= 0.05\n            xmax += 0.05\n        else:\n            dx = (xmax - xmin) * pad_rel\n            if (\n                xmin != 0\n                or not isinstance(layer, _ATTACH_TO_AXIS)\n                or layer.orient.is_vertical\n            ):\n                xmin -= dx\n            xmax += dx\n        if np.isnan(ymax) or np.isnan(ymin):\n            ymin, ymax = self.y.lim\n        elif ymax - ymin &lt; small_diff:\n            ymin -= 0.05\n            ymax += 0.05\n        else:\n            dy = (ymax - ymin) * pad_rel\n            if (\n                ymin != 0\n                or not isinstance(layer, _ATTACH_TO_AXIS)\n                or layer.orient.is_horizontal\n            ):\n                ymin -= dy\n            ymax += dy\n        self.lims = xmin, xmax, ymin, ymax\n\n    def _cb_inserted(self, idx: int, layer: _l.Layer):\n        if self._is_grouping:\n            # this happens when the grouped layer is inserted\n            layer._connect_canvas(self)\n            return\n\n        _canvas = self._canvas()\n        for l in _iter_layers(layer):\n            _canvas._plt_add_layer(l._backend)\n            l._connect_canvas(self)\n\n        if isinstance(layer, _l.LayerWrapper):\n            # TODO: check if connecting LayerGroup is necessary\n            layer._connect_canvas(self)\n        # autoscale\n        self._autoscale_for_layer(layer)\n        self._cb_reordered()\n\n    def _cb_overlay_inserted(self, idx: int, layer: _l.Layer):\n        _canvas = self._canvas()\n        fn = self._get_backend().get(\"as_overlay\")\n        for l in _iter_layers(layer):\n            _canvas._plt_add_layer(l._backend)\n            fn(l._backend, _canvas)\n            l._connect_canvas(self)\n\n        if isinstance(layer, _l.LayerWrapper):\n            # TODO: check if connecting LayerGroup is necessary\n            fn(l._backend, _canvas)\n            layer._connect_canvas(self)\n\n    def _cb_removed(self, idx: int, layer: _l.Layer):\n        if self._is_grouping:\n            return\n        _canvas = self._canvas()\n        for l in _iter_layers(layer):\n            _canvas._plt_remove_layer(l._backend)\n            l._disconnect_canvas(self)\n\n    def _cb_reordered(self):\n        layer_backends = []\n        for layer in self.layers:\n            if isinstance(layer, _l.PrimitiveLayer):\n                layer_backends.append(layer._backend)\n            elif isinstance(layer, _l.LayerGroup):\n                for child in layer.iter_children_recursive():\n                    layer_backends.append(child._backend)\n            elif isinstance(layer, _l.LayerWrapper):\n                for child in _iter_layers(layer):\n                    layer_backends.append(child._backend)\n            else:\n                raise RuntimeError(f\"type {type(layer)} not expected\")\n        self._canvas()._plt_reorder_layers(layer_backends)\n\n    def _cb_layer_grouped(self, group: _l.LayerGroup):\n        indices: list[int] = []  # layers to remove\n        not_found: list[_l.PrimitiveLayer] = []  # primitive layers to add\n        id_exists = set(map(id, self.layers.iter_primitives()))\n        for layer in group.iter_children():\n            try:\n                idx = self.layers.index(layer)\n                indices.append(idx)\n            except ValueError:\n                not_found.extend(_iter_layers(layer))\n        if not indices:\n            return\n        self._is_grouping = True\n        try:\n            for idx in reversed(indices):\n                # remove from the layer list since it is directly grouped\n                self.layers.pop(idx)\n            self.layers.append(group)\n            _canvas = self._canvas()\n            for child in not_found:\n                if id(child) in id_exists:\n                    # skip since it is already in the canvas\n                    continue\n                child._connect_canvas(self)\n                _canvas._plt_add_layer(child._backend)\n        finally:\n            self._is_grouping = False\n        self._cb_reordered()\n        self._autoscale_for_layer(group)\n\n    def _generate_colors(self, color: ColorType | None) -&gt; Color:\n        if color is None:\n            color = self._color_palette.next()\n        return color\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.aspect_ratio","title":"<code>aspect_ratio: float | None</code>  <code>property</code> <code>writable</code>","text":"<p>Aspect ratio of the canvas (None if not locked).</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.lims","title":"<code>lims: Rect</code>  <code>property</code> <code>writable</code>","text":"<p>Return the x/y limits of the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.native","title":"<code>native: Any</code>  <code>property</code>","text":"<p>Return the native canvas object.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.visible","title":"<code>visible</code>  <code>property</code> <code>writable</code>","text":"<p>Show the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_band","title":"<code>add_band(xdata, ylow, yhigh, *, name=None, orient=Orientation.VERTICAL, color=None, alpha=1.0, hatch=Hatch.SOLID)</code>","text":"<p>Add a band (fill-between) layer to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>xdata</code> <code>array - like</code> <p>X coordinates of the band.</p> required <code>ylow</code> <code>array - like</code> <p>Either lower or upper y coordinates of the band.</p> required <code>yhigh</code> <code>array - like</code> <p>The other y coordinates of the band.</p> required <code>name</code> <code>str</code> <p>Name of the layer, by default None</p> <code>None</code> <code>orient</code> <code>(str, Orientation)</code> <p>Orientation of the band. If vertical, band will be filled between vertical orientation.,</p> <code>Orientation.VERTICAL</code> <code>color</code> <code>color - like</code> <p>Color of the band face.,</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the band face.</p> <code>1.0</code> <code>hatch</code> <code>(str, FacePattern)</code> <p>Hatch of the band face.</p> <code>FacePattern.SOLID</code> <p>Returns:</p> Type Description <code>Band</code> <p>The band layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_band(\n    self,\n    xdata: ArrayLike1D,\n    ylow: ArrayLike1D,\n    yhigh: ArrayLike1D,\n    *,\n    name: str | None = None,\n    orient: str | Orientation = Orientation.VERTICAL,\n    color: ColorType | None = None,\n    alpha: float = 1.0,\n    hatch: str | Hatch = Hatch.SOLID,\n) -&gt; _l.Band:\n    \"\"\"\n    Add a band (fill-between) layer to the canvas.\n\n    Parameters\n    ----------\n    xdata : array-like\n        X coordinates of the band.\n    ylow : array-like\n        Either lower or upper y coordinates of the band.\n    yhigh : array-like\n        The other y coordinates of the band.\n    name : str, optional\n        Name of the layer, by default None\n    orient : str, Orientation, default Orientation.VERTICAL\n        Orientation of the band. If vertical, band will be filled between\n        vertical orientation.,\n    color : color-like, default None\n        Color of the band face.,\n    alpha : float, default 1.0\n        Alpha channel of the band face.\n    hatch : str, FacePattern, default FacePattern.SOLID\n        Hatch of the band face.\n\n    Returns\n    -------\n    Band\n        The band layer.\n    \"\"\"\n    name = self._coerce_name(_l.Band, name)\n    color = self._generate_colors(color)\n    layer = _l.Band(\n        xdata, ylow, yhigh, name=name, orient=orient, color=color,\n        alpha=alpha, hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_bars","title":"<code>add_bars(*args, bottom=None, name=None, orient=Orientation.VERTICAL, extent=None, color=None, alpha=1.0, hatch=None)</code>","text":"<p>Add a bar plot.</p> <p>canvas.add_bars(x, heights)  # standard usage canvas.add_bars(heights)  # use 0, 1, ... for the x values canvas.add_bars(..., orient=\"horizontal\")  # horizontal bars</p> <p>Parameters:</p> Name Type Description Default <code>bottom</code> <code>float or array - like</code> <p>Bottom level of the bars.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>Orientation.VERTICAL</code> <code>extent</code> <code>float</code> <p>Bar width in the canvas coordinate</p> <code>0.8</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the bars.</p> <code>1.0</code> <code>hatch</code> <code>str or FacePattern</code> <p>Pattern of the bar faces.</p> <code>FacePattern.SOLID</code> <p>Returns:</p> Type Description <code>Bars</code> <p>The bars layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_bars(\n    self,\n    *args,\n    bottom=None,\n    name=None,\n    orient=Orientation.VERTICAL,\n    extent=None,\n    color=None,\n    alpha=1.0,\n    hatch=None,\n):\n    \"\"\"\n    Add a bar plot.\n\n    &gt;&gt;&gt; canvas.add_bars(x, heights)  # standard usage\n    &gt;&gt;&gt; canvas.add_bars(heights)  # use 0, 1, ... for the x values\n    &gt;&gt;&gt; canvas.add_bars(..., orient=\"horizontal\")  # horizontal bars\n\n    Parameters\n    ----------\n    bottom : float or array-like, optional\n        Bottom level of the bars.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default Orientation.VERTICAL\n        Orientation of the bars.\n    extent : float, default 0.8\n        Bar width in the canvas coordinate\n    color : color-like, optional\n        Color of the bars.\n    alpha : float, default 1.0\n        Alpha channel of the bars.\n    hatch : str or FacePattern, default FacePattern.SOLID\n        Pattern of the bar faces.\n\n    Returns\n    -------\n    Bars\n        The bars layer.\n    \"\"\"\n    center, height = normalize_xy(*args)\n    if bottom is not None:\n        bottom = as_array_1d(bottom)\n        if bottom.shape != height.shape:\n            raise ValueError(\"Expected bottom to have the same shape as height\")\n    name = self._coerce_name(_l.Bars, name)\n    color = self._generate_colors(color)\n    extent = theme._default(\"bars.extent\", extent)\n    hatch = theme._default(\"bars.hatch\", hatch)\n    layer = _l.Bars(\n        center, height, bottom, extent=extent, name=name, orient=orient,\n        color=color, alpha=alpha, hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_cdf","title":"<code>add_cdf(data, *, name=None, orient=Orientation.VERTICAL, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add a empirical cumulative distribution function (CDF) plot.</p> <p>canvas.add_cdf(np.random.normal(size=100))</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>1D Array of data.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>Orientation.VERTICAL</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>Line</code> <p>The line layer that represents the CDF.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_cdf(\n    self,\n    data: ArrayLike1D,\n    *,\n    name: str | None = None,\n    orient: str | Orientation = Orientation.VERTICAL,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.Line:\n    \"\"\"\n    Add a empirical cumulative distribution function (CDF) plot.\n\n    &gt;&gt;&gt; canvas.add_cdf(np.random.normal(size=100))\n\n    Parameters\n    ----------\n    data : array-like\n        1D Array of data.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default Orientation.VERTICAL\n        Orientation of the bars.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    Line\n        The line layer that represents the CDF.\n    \"\"\"\n    name = self._coerce_name(\"histogram\", name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.Line.build_cdf(\n        data, orient=orient, name=name, color=color, width=width, style=style,\n        alpha=alpha, antialias=antialias, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_errorbars","title":"<code>add_errorbars(xdata, ylow, yhigh, *, name=None, orient=Orientation.VERTICAL, color=None, width=None, style=None, alpha=1.0, antialias=False, capsize=0.0)</code>","text":"<p>Add parallel lines as errorbars.</p> <p>Parameters:</p> Name Type Description Default <code>xdata</code> <code>array - like</code> <p>X coordinates of the errorbars.</p> required <code>ylow</code> <code>array - like</code> <p>Lower bound of the errorbars.</p> required <code>yhigh</code> <code>array - like</code> <p>Upper bound of the errorbars.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the errorbars. If vertical, errorbars will be parallel to the y axis.</p> <code>Orientation.VERTICAL</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <code>capsize</code> <code>float</code> <p>Size of the caps of the error indicators</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Errorbars</code> <p>The errorbars layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_errorbars(\n    self,\n    xdata: ArrayLike1D,\n    ylow: ArrayLike1D,\n    yhigh: ArrayLike1D,\n    *,\n    name: str | None = None,\n    orient: str | Orientation = Orientation.VERTICAL,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n    alpha: float = 1.0,\n    antialias: bool = False,\n    capsize: float = 0.0,\n) -&gt; _l.Errorbars:\n    \"\"\"\n    Add parallel lines as errorbars.\n\n    Parameters\n    ----------\n    xdata : array-like\n        X coordinates of the errorbars.\n    ylow : array-like\n        Lower bound of the errorbars.\n    yhigh : array-like\n        Upper bound of the errorbars.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default Orientation.VERTICAL\n        Orientation of the errorbars. If vertical, errorbars will be parallel\n        to the y axis.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n    capsize : float, default 0.0\n        Size of the caps of the error indicators\n\n    Returns\n    -------\n    Errorbars\n        The errorbars layer.\n    \"\"\"\n    name = self._coerce_name(_l.Errorbars, name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.Errorbars(\n        xdata, ylow, yhigh, name=name, color=color, width=width,\n        style=style, antialias=antialias, capsize=capsize, alpha=alpha,\n        orient=orient, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_heatmap","title":"<code>add_heatmap(image, *, name=None, cmap='inferno', clim=None, flip_canvas=False)</code>","text":"<p>Add an image layer to the canvas as a heatmap.</p> <p>Use <code>add_image</code> to add the layer as an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ArrayLike</code> <p>Image data. Must be 2D or 3D array. If 3D, the last dimension must be RGB(A). Note that the first dimension is the vertical axis.</p> required <code>cmap</code> <code>ColormapType</code> <p>Colormap used for the image.</p> <code>\"gray\"</code> <code>clim</code> <code>(float or None, float or None) or None</code> <p>Contrast limits. If None, the limits are automatically determined by min and max of the data. You can also pass None separately to either limit to use the default behavior.</p> <code>None</code> <code>flip_canvas</code> <code>bool</code> <p>If True, flip the canvas vertically so that the image looks normal.</p> <code>False</code> <p>Returns:</p> Type Description <code>Image</code> <p>The image layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_heatmap(\n    self,\n    image: ArrayLike,\n    *,\n    name: str | None = None,\n    cmap: ColormapType = \"inferno\",\n    clim: tuple[float | None, float | None] | None = None,\n    flip_canvas: bool = False,\n) -&gt; _l.Image:\n    \"\"\"\n    Add an image layer to the canvas as a heatmap.\n\n    Use `add_image` to add the layer as an image.\n\n    Parameters\n    ----------\n    image : ArrayLike\n        Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n        RGB(A). Note that the first dimension is the vertical axis.\n    cmap : ColormapType, default \"gray\"\n        Colormap used for the image.\n    clim : (float or None, float or None) or None\n        Contrast limits. If None, the limits are automatically determined by min and\n        max of the data. You can also pass None separately to either limit to use\n        the default behavior.\n    flip_canvas : bool, default False\n        If True, flip the canvas vertically so that the image looks normal.\n\n    Returns\n    -------\n    Image\n        The image layer.\n    \"\"\"\n    layer = _l.Image(\n        image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n    )\n    self.add_layer(layer)\n    if flip_canvas and not self.y.flipped:\n        self.y.flipped = True\n    return layer\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_hist","title":"<code>add_hist(data, *, bins='auto', limits=None, name=None, shape='bars', kind='count', orient=Orientation.VERTICAL, color=None, width=None, style=None)</code>","text":"<p>Add data as a histogram.</p> <p>canvas.add_hist(np.random.normal(size=100), bins=12)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>1D Array of data.</p> required <code>bins</code> <code>int or 1D array-like</code> <p>Bins of the histogram. This parameter will directly be passed to <code>np.histogram</code>.</p> <code>\"auto\"</code> <code>limits</code> <code>(float, float)</code> <p>Limits in which histogram will be built. This parameter will equivalent to the <code>range</code> paraneter of <code>np.histogram</code>.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>shape</code> <code>('step', 'polygon', 'bars')</code> <p>Shape of the histogram. This parameter defines how to convert the data into the line nodes.</p> <code>\"step\"</code> <code>kind</code> <code>('count', 'density', 'probability', 'frequency', 'percent')</code> <p>Kind of the histogram.</p> <code>\"count\"</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>Orientation.VERTICAL</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bars</code> <p>The bars layer that represents the histogram.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_hist(\n    self,\n    data: ArrayLike1D,\n    *,\n    bins: HistBinType = \"auto\",\n    limits: tuple[float, float] | None = None,\n    name: str | None = None,\n    shape: Literal[\"step\", \"polygon\", \"bars\"] = \"bars\",\n    kind: Literal[\"count\", \"density\", \"frequency\", \"percent\"] = \"count\",\n    orient: str | Orientation = Orientation.VERTICAL,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n) -&gt; _lg.Histogram:\n    \"\"\"\n    Add data as a histogram.\n\n    &gt;&gt;&gt; canvas.add_hist(np.random.normal(size=100), bins=12)\n\n    Parameters\n    ----------\n    data : array-like\n        1D Array of data.\n    bins : int or 1D array-like, default \"auto\"\n        Bins of the histogram. This parameter will directly be passed\n        to `np.histogram`.\n    limits : (float, float), optional\n        Limits in which histogram will be built. This parameter will equivalent to\n        the `range` paraneter of `np.histogram`.\n    name : str, optional\n        Name of the layer.\n    shape : {\"step\", \"polygon\", \"bars\"}, default \"bars\"\n        Shape of the histogram. This parameter defines how to convert the data into\n        the line nodes.\n    kind : {\"count\", \"density\", \"probability\", \"frequency\", \"percent\"}, optional\n        Kind of the histogram.\n    orient : str or Orientation, default Orientation.VERTICAL\n        Orientation of the bars.\n    color : color-like, optional\n        Color of the bars.\n\n    Returns\n    -------\n    Bars\n        The bars layer that represents the histogram.\n    \"\"\"\n    name = self._coerce_name(\"histogram\", name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _lg.Histogram.from_array(\n        data, bins=bins, limits=limits, shape=shape, kind=kind, name=name,\n        color=color, width=width, style=style, orient=orient,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_hist2d","title":"<code>add_hist2d(x, y, *, cmap='inferno', name=None, bins='auto', rangex=None, rangey=None, density=False)</code>","text":"<p>Add a 2D histogram of given X/Y data.</p> <p>x = np.random.normal(size=100) y = np.random.normal(size=200) canvas.add_hist2d(x, y)</p> <p>Note that unlike <code>add_image()</code> method, this method does not lock the aspect ratio and flip the canvas by default.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>1D Array of X data.</p> required <code>y</code> <code>array - like</code> <p>1D Array of Y data.</p> required <code>cmap</code> <code>ColormapType</code> <p>Colormap used for the image.</p> <code>\"gray\"</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>bins</code> <code>int or tuple[int, int]</code> <p>Bins of the histogram of X/Y dimension respectively. If an integer is given, it will be used for both dimensions.</p> <code>'auto'</code> <code>rangex</code> <code>(float, float)</code> <p>Range of x values in which histogram will be built.</p> <code>None</code> <code>rangey</code> <code>(float, float)</code> <p>Range of y values in which histogram will be built.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, values of the histogram will be normalized so that the total intensity of the histogram will be 1.</p> <code>False</code> <p>Returns:</p> Type Description <code>Image</code> <p>Image layer representing the 2D histogram.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_hist2d(\n    self,\n    x: ArrayLike1D,\n    y: ArrayLike1D,\n    *,\n    cmap: ColormapType = \"inferno\",\n    name: str | None = None,\n    bins: HistBinType | tuple[HistBinType, HistBinType] = \"auto\",\n    rangex: tuple[float, float] | None = None,\n    rangey: tuple[float, float] | None = None,\n    density: bool = False,\n) -&gt; _l.Image:\n    \"\"\"\n    Add a 2D histogram of given X/Y data.\n\n    &gt;&gt;&gt; x = np.random.normal(size=100)\n    &gt;&gt;&gt; y = np.random.normal(size=200)\n    &gt;&gt;&gt; canvas.add_hist2d(x, y)\n\n    Note that unlike `add_image()` method, this method does not lock the aspect\n    ratio and flip the canvas by default.\n\n    Parameters\n    ----------\n    x : array-like\n        1D Array of X data.\n    y : array-like\n        1D Array of Y data.\n    cmap : ColormapType, default \"gray\"\n        Colormap used for the image.\n    name : str, optional\n        Name of the layer.\n    bins : int or tuple[int, int], optional\n        Bins of the histogram of X/Y dimension respectively. If an integer is given,\n        it will be used for both dimensions.\n    rangex : (float, float), optional\n        Range of x values in which histogram will be built.\n    rangey : (float, float), optional\n        Range of y values in which histogram will be built.\n    density : bool, default False\n        If True, values of the histogram will be normalized so that the total\n        intensity of the histogram will be 1.\n\n    Returns\n    -------\n    Image\n        Image layer representing the 2D histogram.\n    \"\"\"\n    layer = _l.Image.build_hist(\n        x, y, bins=bins, range=(rangex, rangey), density=density, name=name,\n        cmap=cmap, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_hline","title":"<code>add_hline(y, *, name=None, color=None, width=None, style=LineStyle.SOLID, alpha=1.0, antialias=True)</code>","text":"<p>Add a infinite horizontal line to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>float</code> <p>Y coordinate of the line.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>SOLID</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfLine</code> <p>The infline layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_hline(\n    self,\n    y: float,\n    *,\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str = LineStyle.SOLID,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfLine:\n    \"\"\"\n    Add a infinite horizontal line to the canvas.\n\n    Parameters\n    ----------\n    y : float\n        Y coordinate of the line.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfLine\n        The infline layer.\n    \"\"\"\n    return self.add_infline(\n        (0, y), 0, name=name, color=color, width=width, style=style, alpha=alpha,\n        antialias=antialias\n    )  # fmt: skip\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_image","title":"<code>add_image(image, *, name=None, cmap='gray', clim=None, flip_canvas=True, lock_aspect=True)</code>","text":"<p>Add an image layer to the canvas.</p> <p>This method automatically flips the image vertically by default. <code>add_heatmap</code> does the similar thing with slightly different default settings.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ArrayLike</code> <p>Image data. Must be 2D or 3D array. If 3D, the last dimension must be RGB(A). Note that the first dimension is the vertical axis.</p> required <code>cmap</code> <code>ColormapType</code> <p>Colormap used for the image.</p> <code>\"gray\"</code> <code>clim</code> <code>(float or None, float or None) or None</code> <p>Contrast limits. If None, the limits are automatically determined by min and max of the data. You can also pass None separately to either limit to use the default behavior.</p> <code>None</code> <code>flip_canvas</code> <code>bool</code> <p>If True, flip the canvas vertically so that the image looks normal.</p> <code>True</code> <code>lock_aspect</code> <code>bool</code> <p>If True, lock the aspect ratio of the canvas to 1:1.</p> <code>True</code> <p>Returns:</p> Type Description <code>Image</code> <p>The image layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_image(\n    self,\n    image: ArrayLike,\n    *,\n    name: str | None = None,\n    cmap: ColormapType = \"gray\",\n    clim: tuple[float | None, float | None] | None = None,\n    flip_canvas: bool = True,\n    lock_aspect: bool = True,\n) -&gt; _l.Image:\n    \"\"\"\n    Add an image layer to the canvas.\n\n    This method automatically flips the image vertically by default. `add_heatmap`\n    does the similar thing with slightly different default settings.\n\n    Parameters\n    ----------\n    image : ArrayLike\n        Image data. Must be 2D or 3D array. If 3D, the last dimension must be\n        RGB(A). Note that the first dimension is the vertical axis.\n    cmap : ColormapType, default \"gray\"\n        Colormap used for the image.\n    clim : (float or None, float or None) or None\n        Contrast limits. If None, the limits are automatically determined by min and\n        max of the data. You can also pass None separately to either limit to use\n        the default behavior.\n    flip_canvas : bool, default True\n        If True, flip the canvas vertically so that the image looks normal.\n    lock_aspect : bool, default True\n        If True, lock the aspect ratio of the canvas to 1:1.\n\n    Returns\n    -------\n    Image\n        The image layer.\n    \"\"\"\n    layer = _l.Image(\n        image, name=name, cmap=cmap, clim=clim, backend=self._get_backend()\n    )\n    self.add_layer(layer)\n    if flip_canvas and not self.y.flipped:\n        self.y.flipped = True\n    if lock_aspect:\n        self.aspect_ratio = 1.0\n    return layer\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_infcurve","title":"<code>add_infcurve(model, *, bounds=(-float('inf'), float('inf')), name=None, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add an infinite curve to the canvas.</p> <p>canvas.add_infcurve(lambda x: x ** 2)  # parabola canvas.add_infcurve(lambda x, a: np.sin(a*x)).with_params(2)  # parametric</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>callable</code> <p>The model function. The first argument must be the x coordinates. Same signature as <code>scipy.optimize.curve_fit</code>.</p> required <code>bounds</code> <code>(float, float)</code> <p>Lower and upper bounds that the function is defined.</p> <code>(-inf, inf)</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfCurve</code> <p>The infcurve layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_infcurve(\n    self,\n    model: Callable[Concatenate[Any, _P], Any],\n    *,\n    bounds: tuple[float, float] = (-float(\"inf\"), float(\"inf\")),\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: str | LineStyle | None = None,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfCurve[_P]:\n    \"\"\"\n    Add an infinite curve to the canvas.\n\n    &gt;&gt;&gt; canvas.add_infcurve(lambda x: x ** 2)  # parabola\n    &gt;&gt;&gt; canvas.add_infcurve(lambda x, a: np.sin(a*x)).with_params(2)  # parametric\n\n    Parameters\n    ----------\n    model : callable\n        The model function. The first argument must be the x coordinates. Same\n        signature as `scipy.optimize.curve_fit`.\n    bounds : (float, float), default (-inf, inf)\n        Lower and upper bounds that the function is defined.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfCurve\n        The infcurve layer.\n    \"\"\"\n    name = self._coerce_name(_l.InfCurve, name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.InfCurve(\n        model, bounds=bounds, name=name, color=color, width=width, alpha=alpha,\n        style=style, antialias=antialias, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_infline","title":"<code>add_infline(pos=(0, 0), angle=0.0, *, name=None, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add an infinitely long line to the canvas.</p> <p>canvas.add_infline((0, 0), 45)  # y = x canvas.add_infline((1, 0), 90)  # x = 1 canvas.add_infline((0, -1), 0)  # y = -1</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>(float, float)</code> <p>One of the points this line passes.</p> <code>(0, 0)</code> <code>angle</code> <code>float</code> <p>Angle of the line in degree, defined by the counter-clockwise rotation from the x axis.</p> <code>0.0</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfLine</code> <p>The infline layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_infline(\n    self,\n    pos: tuple[float, float] = (0, 0),\n    angle: float = 0.0,\n    *,\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfLine:\n    \"\"\"\n    Add an infinitely long line to the canvas.\n\n    &gt;&gt;&gt; canvas.add_infline((0, 0), 45)  # y = x\n    &gt;&gt;&gt; canvas.add_infline((1, 0), 90)  # x = 1\n    &gt;&gt;&gt; canvas.add_infline((0, -1), 0)  # y = -1\n\n    Parameters\n    ----------\n    pos : (float, float), default (0, 0)\n        One of the points this line passes.\n    angle : float, default 0.0\n        Angle of the line in degree, defined by the counter-clockwise\n        rotation from the x axis.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfLine\n        The infline layer.\n    \"\"\"\n    name = self._coerce_name(_l.InfLine, name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.InfLine(\n        pos, angle, name=name, color=color, alpha=alpha,\n        width=width, style=style, antialias=antialias,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_kde","title":"<code>add_kde(data, *, bottom=0.0, name=None, orient=Orientation.VERTICAL, band_width='scott', color=None, width=None, style=None)</code>","text":"<p>Add data as a band layer representing kernel density estimation (KDE).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>1D data to calculate the KDE.</p> required <code>bottom</code> <code>float</code> <p>Scalar value that define the height of the bottom line.</p> <code>0.0</code> <code>name</code> <code>str</code> <p>Name of the layer, by default None</p> <code>None</code> <code>orient</code> <code>(str, Orientation)</code> <p>Orientation of the KDE.</p> <code>Orientation.VERTICAL</code> <code>band_width</code> <code>float or str</code> <p>Band width parameter of KDE. Must be a number or a string as the method to automatic determination.</p> <code>\"scott\"</code> <code>color</code> <code>color - like</code> <p>Color of the band face.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width of the outline.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style of the outline.</p> <code>None</code> <p>Returns:</p> Type Description <code>Kde</code> <p>The KDE layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_kde(\n    self,\n    data: ArrayLike1D,\n    *,\n    bottom: float = 0.0,\n    name: str | None = None,\n    orient: str | Orientation = Orientation.VERTICAL,\n    band_width: float | Literal[\"scott\", \"silverman\"] = \"scott\",\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str | None = None,\n) -&gt; _lg.Kde:\n    \"\"\"\n    Add data as a band layer representing kernel density estimation (KDE).\n\n    Parameters\n    ----------\n    data : array-like\n        1D data to calculate the KDE.\n    bottom : float, default 0.0\n        Scalar value that define the height of the bottom line.\n    name : str, optional\n        Name of the layer, by default None\n    orient : str, Orientation, default Orientation.VERTICAL\n        Orientation of the KDE.\n    band_width : float or str, default \"scott\"\n        Band width parameter of KDE. Must be a number or a string as the\n        method to automatic determination.\n    color : color-like, default None\n        Color of the band face.\n    width : float, optional\n        Line width of the outline.\n    style : str or LineStyle, optional\n        Line style of the outline.\n\n    Returns\n    -------\n    Kde\n        The KDE layer.\n    \"\"\"\n    name = self._coerce_name(_lg.Kde, name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n\n    layer = _lg.Kde.from_array(\n        data, bottom=bottom, scale=1, band_width=band_width, name=name,\n        orient=orient, color=color, width=width, style=style,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_layer","title":"<code>add_layer(layer, *, over=None, under=None)</code>","text":"<p>Add a layer to the canvas.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_layer(\n    self,\n    layer: _L,\n    *,\n    over: _l.Layer | Iterable[_l.Layer] | None = None,\n    under: _l.Layer | Iterable[_l.Layer] | None = None,\n) -&gt; _L:\n    \"\"\"Add a layer to the canvas.\"\"\"\n    if over is None and under is None:\n        self.layers.append(layer)\n    elif over is not None:\n        if under is not None:\n            raise ValueError(\"Cannot specify both `over` and `under`\")\n        if isinstance(over, _l.Layer):\n            idx = self.layers.index(over)\n        else:\n            idx = max([self.layers.index(l) for l in over])\n        self.layers.insert(idx + 1, layer)\n    else:\n        idx = self.layers.index(under)\n        if isinstance(under, _l.Layer):\n            idx = self.layers.index(under)\n        else:\n            idx = min([self.layers.index(l) for l in under])\n        self.layers.insert(idx, layer)\n    return layer\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_line","title":"<code>add_line(*args, name=None, color=None, width=None, style=None, alpha=1.0, antialias=True)</code>","text":"<p>Add a Line layer to the canvas.</p> <p>canvas.add_line(y, ...) canvas.add_line(x, y, ...)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>Line</code> <p>The line layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_line(\n    self,\n    *args,\n    name=None,\n    color=None,\n    width=None,\n    style=None,\n    alpha=1.0,\n    antialias=True,\n):\n    \"\"\"\n    Add a Line layer to the canvas.\n\n    &gt;&gt;&gt; canvas.add_line(y, ...)\n    &gt;&gt;&gt; canvas.add_line(x, y, ...)\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    Line\n        The line layer.\n    \"\"\"\n    xdata, ydata = normalize_xy(*args)\n    name = self._coerce_name(_l.Line, name)\n    color = self._generate_colors(color)\n    width = theme._default(\"line.width\", width)\n    style = theme._default(\"line.style\", style)\n    layer = _l.Line(\n        xdata, ydata, name=name, color=color, width=width, style=style,\n        alpha=alpha, antialias=antialias, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_markers","title":"<code>add_markers(*args, name=None, symbol=None, size=None, color=None, alpha=1.0, hatch=None)</code>","text":"<p>Add markers (scatter plot).</p> <p>canvas.add_markers(x, y)  # standard usage canvas.add_markers(y)  # use 0, 1, ... for the x values</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>symbol</code> <code>str or Symbol</code> <p>Marker symbols. Use the theme default if not specified.</p> <code>None</code> <code>size</code> <code>float</code> <p>Marker size. Use the theme default if not specified.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the marker faces.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the marker faces.</p> <code>1.0</code> <code>hatch</code> <code>str or FacePattern</code> <p>Pattern of the marker faces. Use the theme default if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>Markers</code> <p>The markers layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_markers(\n    self,\n    *args,\n    name=None,\n    symbol=None,\n    size=None,\n    color=None,\n    alpha=1.0,\n    hatch=None,\n):\n    \"\"\"\n    Add markers (scatter plot).\n\n    &gt;&gt;&gt; canvas.add_markers(x, y)  # standard usage\n    &gt;&gt;&gt; canvas.add_markers(y)  # use 0, 1, ... for the x values\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the layer.\n    symbol : str or Symbol, optional\n        Marker symbols. Use the theme default if not specified.\n    size : float, optional\n        Marker size. Use the theme default if not specified.\n    color : color-like, optional\n        Color of the marker faces.\n    alpha : float, default 1.0\n        Alpha channel of the marker faces.\n    hatch : str or FacePattern, optional\n        Pattern of the marker faces. Use the theme default if not specified.\n\n    Returns\n    -------\n    Markers\n        The markers layer.\n    \"\"\"\n    xdata, ydata = normalize_xy(*args)\n    name = self._coerce_name(_l.Markers, name)\n    color = self._generate_colors(color)\n    symbol = theme._default(\"markers.symbol\", symbol)\n    size = theme._default(\"markers.size\", size)\n    hatch = theme._default(\"markers.hatch\", hatch)\n    layer = _l.Markers(\n        xdata, ydata, name=name, symbol=symbol, size=size, color=color,\n        alpha=alpha, hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_rug","title":"<code>add_rug(events, *, low=0.0, high=1.0, name=None, orient=Orientation.VERTICAL, color='black', width=1.0, style=LineStyle.SOLID, antialias=True, alpha=1.0)</code>","text":"<p>Add input data as a rug plot.</p> <p>canvas.add_rug([2, 4, 5, 8, 11])</p> <pre><code>  \u2502 \u2502\u2502  \u2502   \u2502\n\u2500\u2500\u2534\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500&gt; x\n  2 45  8   11\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>array - like</code> <p>A 1D array of events.</p> required <code>low</code> <code>float</code> <p>The lower bound of the rug lines.</p> <code>0.0</code> <code>high</code> <code>float</code> <p>The upper bound of the rug lines.</p> <code>1.0</code> <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the errorbars. If vertical, rug lines will be parallel to the y axis.</p> <code>Orientation.VERTICAL</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>'black'</code> <code>width</code> <code>float</code> <p>Line width.</p> <code>1.0</code> <code>style</code> <code>str or LineStyle</code> <p>Line style.</p> <code>LineStyle.SOLID</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>Rug</code> <p>The rug layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_rug(\n    self,\n    events: ArrayLike1D,\n    *,\n    low: float = 0.0,\n    high: float = 1.0,\n    name: str | None = None,\n    orient: str | Orientation = Orientation.VERTICAL,\n    color: ColorType = \"black\",\n    width: float = 1.0,\n    style: LineStyle | str = LineStyle.SOLID,\n    antialias: bool = True,\n    alpha: float = 1.0,\n) -&gt; _l.Rug:\n    \"\"\"\n    Add input data as a rug plot.\n\n    &gt;&gt;&gt; canvas.add_rug([2, 4, 5, 8, 11])\n\n    ```\n      \u2502 \u2502\u2502  \u2502   \u2502\n    \u2500\u2500\u2534\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500&gt; x\n      2 45  8   11\n    ```\n\n    Parameters\n    ----------\n    events : array-like\n        A 1D array of events.\n    low : float, default 0.0\n        The lower bound of the rug lines.\n    high : float, default 1.0\n        The upper bound of the rug lines.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default Orientation.VERTICAL\n        Orientation of the errorbars. If vertical, rug lines will be parallel\n        to the y axis.\n    color : color-like, optional\n        Color of the bars.\n    width : float, default 1.0\n        Line width.\n    style : str or LineStyle, default LineStyle.SOLID\n        Line style.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    Rug\n        The rug layer.\n    \"\"\"\n    name = self._coerce_name(_l.Errorbars, name)\n    color = self._generate_colors(color)\n    layer = _l.Rug(\n        events, low=low, high=high, name=name, color=color, alpha=alpha,\n        width=width, style=style, antialias=antialias, orient=orient,\n        backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_spans","title":"<code>add_spans(spans, *, name=None, orient=Orientation.VERTICAL, color='blue', alpha=0.4, hatch=Hatch.SOLID)</code>","text":"<p>Add spans that extends infinitely.</p> <p>canvas.add_spans([[5, 10], [15, 20]])</p> :::: :::: \u2500\u2500\u25005\u2500\u2500\u2500\u250010\u2500\u2500\u2500\u250015\u2500\u2500\u250020\u2500\u2500\u2500\u2500\u2500&gt; :::: :::: :::: :::: <p>Parameters:</p> Name Type Description Default <code>spans</code> <code>(N, 2) array-like</code> <p>Array that contains the start and end points of the spans.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>orient</code> <code>str or Orientation</code> <p>Orientation of the bars.</p> <code>Orientation.VERTICAL</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>'blue'</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the bars.</p> <code>0.4</code> <code>hatch</code> <code>str or FacePattern</code> <p>Pattern of the bar faces.</p> <code>FacePattern.SOLID</code> <p>Returns:</p> Type Description <code>Spans</code> <p>The spans layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_spans(\n    self,\n    spans: ArrayLike,\n    *,\n    name: str | None = None,\n    orient: str | Orientation = Orientation.VERTICAL,\n    color: ColorType = \"blue\",\n    alpha: float = 0.4,\n    hatch: str | Hatch = Hatch.SOLID,\n) -&gt; _l.Spans:\n    \"\"\"\n    Add spans that extends infinitely.\n\n    &gt;&gt;&gt; canvas.add_spans([[5, 10], [15, 20]])\n\n       |::::|     |::::|\n       |::::|     |::::|\n    \u2500\u2500\u25005\u2500\u2500\u2500\u250010\u2500\u2500\u2500\u250015\u2500\u2500\u250020\u2500\u2500\u2500\u2500\u2500&gt;\n       |::::|     |::::|\n       |::::|     |::::|\n\n    Parameters\n    ----------\n    spans : (N, 2) array-like\n        Array that contains the start and end points of the spans.\n    name : str, optional\n        Name of the layer.\n    orient : str or Orientation, default Orientation.VERTICAL\n        Orientation of the bars.\n    color : color-like, optional\n        Color of the bars.\n    alpha : float, default 0.4\n        Alpha channel of the bars.\n    hatch : str or FacePattern, default FacePattern.SOLID\n        Pattern of the bar faces.\n\n    Returns\n    -------\n    Spans\n        The spans layer.\n    \"\"\"\n    name = self._coerce_name(\"histogram\", name)\n    color = self._generate_colors(color)\n    layer = _l.Spans(\n        spans, name=name, orient=orient, color=color, alpha=alpha,\n        hatch=hatch, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_text","title":"<code>add_text(x, y, string, *, color='black', size=12, rotation=0.0, anchor=Alignment.BOTTOM_LEFT, family=None)</code>","text":"<p>Add a text layer to the canvas.</p> <p>canvas.add_text([0, 0], [1, 1], [\"text-0\", \"text-1]) canvas.add_text(...).with_face(color=\"red\")  # with background canvas.add_text(...).with_edge(color=\"red\")  # with outline</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or array - like</code> <p>X position(s) of the text.</p> required <code>y</code> <code>float or array - like</code> <p>Y position(s) of the text.</p> required <code>string</code> <code>str or list[str]</code> <p>Text string to display.</p> required <code>color</code> <code>ColorType</code> <p>Color of the text string.</p> <code>'black'</code> <code>size</code> <code>float</code> <p>Point size of the text.</p> <code>12</code> <code>rotation</code> <code>float</code> <p>Rotation angle of the text in degrees.</p> <code>0.0</code> <code>anchor</code> <code>str or Alignment</code> <p>Anchor position of the text. The anchor position will be the coordinate given by (x, y).</p> <code>Alignment.BOTTOM_LEFT</code> <code>family</code> <code>str</code> <p>Font family of the text.</p> <code>None</code> <p>Returns:</p> Type Description <code>Texts</code> <p>The text layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_text(\n    self,\n    x,\n    y,\n    string,\n    *,\n    color=\"black\",\n    size=12,\n    rotation=0.0,\n    anchor=Alignment.BOTTOM_LEFT,\n    family=None,\n):\n    \"\"\"\n    Add a text layer to the canvas.\n\n    &gt;&gt;&gt; canvas.add_text([0, 0], [1, 1], [\"text-0\", \"text-1])\n    &gt;&gt;&gt; canvas.add_text(...).with_face(color=\"red\")  # with background\n    &gt;&gt;&gt; canvas.add_text(...).with_edge(color=\"red\")  # with outline\n\n    Parameters\n    ----------\n    x : float or array-like\n        X position(s) of the text.\n    y : float or array-like\n        Y position(s) of the text.\n    string : str or list[str]\n        Text string to display.\n    color : ColorType, optional\n        Color of the text string.\n    size : float, default 12\n        Point size of the text.\n    rotation : float, default 0.0\n        Rotation angle of the text in degrees.\n    anchor : str or Alignment, default Alignment.BOTTOM_LEFT\n        Anchor position of the text. The anchor position will be the coordinate\n        given by (x, y).\n    family : str, optional\n        Font family of the text.\n\n    Returns\n    -------\n    Texts\n        The text layer.\n    \"\"\"\n    if is_real_number(x) and is_real_number(y) and isinstance(string, str):\n        x, y, string = [x], [y], [string]\n    x_, y_ = normalize_xy(x, y)\n    if isinstance(string, str):\n        string = [string] * x_.size\n    elif len(string) != x_.size:\n        raise ValueError(\"Expected string to have the same size as x/y\")\n    layer = _l.Texts(\n        x_, y_, string, color=color, size=size, rotation=rotation, anchor=anchor,\n        family=family, backend=self._get_backend(),\n    )  # fmt: skip\n    return self.add_layer(layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.add_vline","title":"<code>add_vline(x, *, name=None, color=None, width=None, style=LineStyle.SOLID, alpha=1.0, antialias=True)</code>","text":"<p>Add a infinite vertical line to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate of the line.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> <code>None</code> <code>color</code> <code>color - like</code> <p>Color of the bars.</p> <code>None</code> <code>width</code> <code>float</code> <p>Line width. Use the theme default if not specified.</p> <code>None</code> <code>style</code> <code>str or LineStyle</code> <p>Line style. Use the theme default if not specified.</p> <code>SOLID</code> <code>alpha</code> <code>float</code> <p>Alpha channel of the line.</p> <code>1.0</code> <code>antialias</code> <code>bool</code> <p>Antialiasing of the line.</p> <code>True</code> <p>Returns:</p> Type Description <code>InfLine</code> <p>The infline layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def add_vline(\n    self,\n    x: float,\n    *,\n    name: str | None = None,\n    color: ColorType | None = None,\n    width: float | None = None,\n    style: LineStyle | str = LineStyle.SOLID,\n    alpha: float = 1.0,\n    antialias: bool = True,\n) -&gt; _l.InfLine:\n    \"\"\"\n    Add a infinite vertical line to the canvas.\n\n    Parameters\n    ----------\n    x : float\n        X coordinate of the line.\n    name : str, optional\n        Name of the layer.\n    color : color-like, optional\n        Color of the bars.\n    width : float, optional\n        Line width. Use the theme default if not specified.\n    style : str or LineStyle, optional\n        Line style. Use the theme default if not specified.\n    alpha : float, default 1.0\n        Alpha channel of the line.\n    antialias : bool, default True\n        Antialiasing of the line.\n\n    Returns\n    -------\n    InfLine\n        The infline layer.\n    \"\"\"\n    return self.add_infline(\n        (x, 0), 90, name=name, color=color, width=width, style=style, alpha=alpha,\n        antialias=antialias,\n    )  # fmt: skip\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.autoscale","title":"<code>autoscale(xpad=None, ypad=None)</code>","text":"<p>Autoscale the canvas to fit the contents.</p> <p>Parameters:</p> Name Type Description Default <code>xpad</code> <code>float or (float, float)</code> <p>Padding in the x direction.</p> <code>None</code> <code>ypad</code> <code>float or (float, float)</code> <p>Padding in the y direction.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def autoscale(\n    self,\n    xpad: float | tuple[float, float] | None = None,\n    ypad: float | tuple[float, float] | None = None,\n) -&gt; tuple[float, float, float, float]:\n    \"\"\"\n    Autoscale the canvas to fit the contents.\n\n    Parameters\n    ----------\n    xpad : float or (float, float), optional\n        Padding in the x direction.\n    ypad : float or (float, float), optional\n        Padding in the y direction.\n    \"\"\"\n    ar = np.stack([layer.bbox_hint() for layer in self.layers], axis=0)\n    xmin = np.min(ar[:, 0])\n    xmax = np.max(ar[:, 1])\n    ymin = np.min(ar[:, 2])\n    ymax = np.max(ar[:, 3])\n    x0, x1 = self.x.lim\n    y0, y1 = self.y.lim\n    if np.isnan(xmin):\n        xmin = x0\n    if np.isnan(xmax):\n        xmax = x1\n    if np.isnan(ymin):\n        ymin = y0\n    if np.isnan(ymax):\n        ymax = y1\n    if xpad is not None:\n        xrange = xmax - xmin\n        if is_real_number(xpad):\n            dx0 = dx1 = xpad * xrange\n        else:\n            dx0, dx1 = xpad[0] * xrange, xpad[1] * xrange\n        xmin -= dx0\n        xmax += dx1\n    if ypad is not None:\n        yrange = ymax - ymin\n        if is_real_number(ypad):\n            dy0 = dy1 = ypad * yrange\n        else:\n            dy0, dy1 = ypad[0] * yrange, ypad[1] * yrange\n        ymin -= dy0\n        ymax += dy1\n    small_diff = 1e-6\n    if xmax - xmin &lt; small_diff:\n        xmin -= 0.05\n        xmax += 0.05\n    if ymax - ymin &lt; small_diff:\n        ymin -= 0.05\n        ymax += 0.05\n    self.x.lim = xmin, xmax\n    self.y.lim = ymin, ymax\n    return xmin, xmax, ymin, ymax\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat","title":"<code>cat(data, x=None, y=None, *, update_labels=True)</code>","text":"<p>Categorize input data for plotting.</p> <p>This method provides categorical plotting methods for the input data. Methods are very similar to <code>seaborn</code> and <code>plotly.express</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str</code> <p>Name of the column that will be used for the x-axis. Must be numerical.</p> <code>None</code> <code>y</code> <code>str</code> <p>Name of the column that will be used for the y-axis. Must be numerical.</p> <code>None</code> <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <p>Returns:</p> Type Description <code>CatPlotter</code> <p>Plotter object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat(\n    self,\n    data: _DF,\n    x: str | None = None,\n    y: str | None = None,\n    *,\n    update_labels: bool = True,\n) -&gt; _df.CatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting.\n\n    This method provides categorical plotting methods for the input data.\n    Methods are very similar to `seaborn` and `plotly.express`.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str, optional\n        Name of the column that will be used for the x-axis. Must be numerical.\n    y : str, optional\n        Name of the column that will be used for the y-axis. Must be numerical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n\n    Returns\n    -------\n    CatPlotter\n        Plotter object.\n    \"\"\"\n    plotter = _df.CatPlotter(self, data, x, y, update_label=update_labels)\n    return plotter\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat_x","title":"<code>cat_x(data, x=None, y=None, *, update_labels=True)</code>","text":"<p>Categorize input data for plotting with x-axis as a categorical axis.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the x-axis. Must be categorical.</p> <code>None</code> <code>y</code> <code>str</code> <p>Name of the column that will be used for the y-axis. Must be numerical.</p> <code>None</code> <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <p>Returns:</p> Type Description <code>XCatPlotter</code> <p>Plotter object.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat_x(\n    self,\n    data: _DF,\n    x: str | Sequence[str] | None = None,\n    y: str | None = None,\n    *,\n    update_labels: bool = True,\n) -&gt; _df.XCatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting with x-axis as a categorical axis.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str or sequence of str, optional\n        Name of the column(s) that will be used for the x-axis. Must be categorical.\n    y : str, optional\n        Name of the column that will be used for the y-axis. Must be numerical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n\n    Returns\n    -------\n    XCatPlotter\n        Plotter object.\n    \"\"\"\n    return _df.XCatPlotter(self, data, x, y, update_labels)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat_xy","title":"<code>cat_xy(data, x, y, *, update_labels=True)</code>","text":"<p>Categorize input data for plotting with both axes as categorical.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the x-axis. Must be categorical.</p> required <code>y</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the y-axis. Must be categorical.</p> required <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <p>Returns:</p> Type Description <code>XYCatPlotter</code> <p>Plotter object</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat_xy(\n    self,\n    data: _DF,\n    x: str | Sequence[str],\n    y: str | Sequence[str],\n    *,\n    update_labels: bool = True,\n) -&gt; _df.XYCatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting with both axes as categorical.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str or sequence of str, optional\n        Name of the column(s) that will be used for the x-axis. Must be categorical.\n    y : str or sequence of str, optional\n        Name of the column(s) that will be used for the y-axis. Must be categorical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n\n    Returns\n    -------\n    XYCatPlotter\n        Plotter object\n    \"\"\"\n    return _df.XYCatPlotter(self, data, x, y, update_labels)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.cat_y","title":"<code>cat_y(data, x=None, y=None, *, update_labels=True)</code>","text":"<p>Categorize input data for plotting with y-axis as a categorical axis.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>tabular data</code> <p>Any categorizable data. Currently, dict, pandas.DataFrame, and polars.DataFrame are supported.</p> required <code>x</code> <code>str</code> <p>Name of the column that will be used for the x-axis. Must be numerical.</p> <code>None</code> <code>y</code> <code>str or sequence of str</code> <p>Name of the column(s) that will be used for the y-axis. Must be categorical.</p> <code>None</code> <code>update_labels</code> <code>bool</code> <p>If True, update the x/y labels to the corresponding names.</p> <code>True</code> <p>Returns:</p> Type Description <code>YCatPlotter</code> <p>Plotter object</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def cat_y(\n    self,\n    data: _DF,\n    x: str | None = None,\n    y: str | Sequence[str] | None = None,\n    *,\n    update_labels: bool = True,\n) -&gt; _df.YCatPlotter[Self, _DF]:\n    \"\"\"\n    Categorize input data for plotting with y-axis as a categorical axis.\n\n    Parameters\n    ----------\n    data : tabular data\n        Any categorizable data. Currently, dict, pandas.DataFrame, and\n        polars.DataFrame are supported.\n    x : str, optional\n        Name of the column that will be used for the x-axis. Must be numerical.\n    y : str or sequence of str, optional\n        Name of the column(s) that will be used for the y-axis. Must be categorical.\n    update_labels : bool, default True\n        If True, update the x/y labels to the corresponding names.\n\n    Returns\n    -------\n    YCatPlotter\n        Plotter object\n    \"\"\"\n    return _df.YCatPlotter(self, data, y, x, update_labels)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.fit","title":"<code>fit(layer)</code>","text":"<p>The fit plotter namespace.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def fit(self, layer: _l.DataBoundLayer[_P]) -&gt; FitPlotter[Self, _P]:\n    \"\"\"The fit plotter namespace.\"\"\"\n    return FitPlotter(self, layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.group_layers","title":"<code>group_layers(layers, *more_layers, name=None)</code>","text":"<p>Group layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>iterable of Layer</code> <p>Layers to group.</p> required <p>Returns:</p> Type Description <code>LayerGroup</code> <p>The grouped layer.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def group_layers(self, layers, *more_layers, name=None):\n    \"\"\"\n    Group layers.\n\n    Parameters\n    ----------\n    layers : iterable of Layer\n        Layers to group.\n\n    Returns\n    -------\n    LayerGroup\n        The grouped layer.\n    \"\"\"\n    if more_layers:\n        if not isinstance(layers, _l.Layer):\n            raise TypeError(\"No overload matches the arguments\")\n        layers = [layers, *more_layers]\n    return _lg.LayerTuple(layers, name=name)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.imref","title":"<code>imref(layer)</code>","text":"<p>The Image reference namespace.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def imref(self, layer: _l.Image) -&gt; ImageRef[Self]:\n    \"\"\"The Image reference namespace.\"\"\"\n    while isinstance(layer, _l.LayerWrapper):\n        layer = layer._base_layer\n    if not isinstance(layer, _l.Image):\n        raise TypeError(\n            f\"Expected an Image layer or its wrapper, got {type(layer)}.\"\n        )\n    return ImageRef(self, layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.install_second_y","title":"<code>install_second_y(*, palette=None)</code>","text":"<p>Create a twin canvas that share one of the axis.</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def install_second_y(\n    self,\n    *,\n    palette: ColormapType | None = None,\n) -&gt; Canvas:\n    \"\"\"Create a twin canvas that share one of the axis.\"\"\"\n    try:\n        new = self._canvas()._plt_twinx()\n    except AttributeError:\n        raise NotImplementedError(\n            f\"Backend {self._get_backend()} does not support `install_second_y`.\"\n        )\n    canvas = Canvas.from_backend(new, palette=palette, backend=self._get_backend())\n    canvas._init_canvas()\n    return canvas\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.stack_over","title":"<code>stack_over(layer)</code>","text":"<p>Stack new data over the existing layer.</p> <p>For example following code</p> <p>bars_0 = canvas.add_bars(x, y0) bars_1 = canvas.stack_over(bars_0).add(y1) bars_2 = canvas.stack_over(bars_1).add(y2)</p> <p>will result in a bar plot like this</p> <pre><code> \u250c\u2500\u2500\u2500\u2510\n \u251c\u2500\u2500\u2500\u2502\u250c\u2500\u2500\u2500\u2510\n \u2502   \u2502\u251c\u2500\u2500\u2500\u2502\n \u251c\u2500\u2500\u2500\u2502\u251c\u2500\u2500\u2500\u2502\n\u2500\u2534\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\n</code></pre> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def stack_over(self, layer: _L0) -&gt; StackOverPlotter[Self, _L0]:\n    \"\"\"\n    Stack new data over the existing layer.\n\n    For example following code\n\n    &gt;&gt;&gt; bars_0 = canvas.add_bars(x, y0)\n    &gt;&gt;&gt; bars_1 = canvas.stack_over(bars_0).add(y1)\n    &gt;&gt;&gt; bars_2 = canvas.stack_over(bars_1).add(y2)\n\n    will result in a bar plot like this\n\n    ```\n     \u250c\u2500\u2500\u2500\u2510\n     \u251c\u2500\u2500\u2500\u2502\u250c\u2500\u2500\u2500\u2510\n     \u2502   \u2502\u251c\u2500\u2500\u2500\u2502\n     \u251c\u2500\u2500\u2500\u2502\u251c\u2500\u2500\u2500\u2502\n    \u2500\u2534\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\n    ```\n    \"\"\"\n    if not isinstance(layer, (_l.Bars, _l.Band, _lg.StemPlot, _lg.LabeledBars)):\n        raise TypeError(\n            f\"Only Bars and Band are supported as an input, \"\n            f\"got {type(layer)!r}.\"\n        )\n    return StackOverPlotter(self, layer)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasBase.update_labels","title":"<code>update_labels(title=None, x=None, y=None)</code>","text":"<p>Helper function to update the title, x, and y labels.</p> <p>from whitecanvas import new_canvas canvas = new_canvas(\"matplotlib\").update_labels(\"Title\", \"X\", \"Y\")</p> Source code in <code>whitecanvas\\canvas\\_base.py</code> <pre><code>def update_labels(\n    self,\n    title: str | None = None,\n    x: str | None = None,\n    y: str | None = None,\n) -&gt; Self:\n    \"\"\"\n    Helper function to update the title, x, and y labels.\n\n    &gt;&gt;&gt; from whitecanvas import new_canvas\n    &gt;&gt;&gt; canvas = new_canvas(\"matplotlib\").update_labels(\"Title\", \"X\", \"Y\")\n    \"\"\"\n    if title is not None:\n        self.title.text = title\n        self.title.visible = True\n    if x is not None:\n        self.x.label.text = x\n        self.x.label.visible = True\n    if y is not None:\n        self.y.label.text = y\n        self.y.label.visible = True\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid","title":"<code>CanvasGrid</code>","text":"Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>class CanvasGrid:\n    _CURRENT_INSTANCE: CanvasGrid | None = None\n    events: GridEvents\n\n    def __init__(\n        self,\n        heights: list[int],\n        widths: list[int],\n        *,\n        link_x: bool = False,\n        link_y: bool = False,\n        backend: Backend | str | None = None,\n    ) -&gt; None:\n        self._heights = heights\n        self._widths = widths\n        self._backend = Backend(backend)\n        self._backend_object = self._create_backend()\n        self._canvas_array = np.empty((len(heights), len(widths)), dtype=object)\n        self._canvas_array.fill(None)\n\n        # link axes\n        self._x_linked = link_x\n        self._y_linked = link_y\n\n        # update settings\n        theme = get_theme()\n        self.background_color = theme.background_color\n        self.size = theme.canvas_size\n        self.events = GridEvents()\n        self.__class__._CURRENT_INSTANCE = self\n\n    @classmethod\n    def uniform(\n        cls,\n        nrows: int = 1,\n        ncols: int = 1,\n        *,\n        backend: Backend | str | None = None,\n    ) -&gt; CanvasGrid:\n        \"\"\"\n        Create a canvas grid with uniform row and column sizes.\n\n        Parameters\n        ----------\n        nrows : int\n            The number of rows in the grid.\n        ncols : int\n            The number of columns in the grid.\n        backend : backend-like, optional\n            The backend to use for the grid.\n        \"\"\"\n        return CanvasGrid([10] * nrows, [10] * ncols, backend=backend)\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        \"\"\"The (row, col) shape of the grid\"\"\"\n        return self._canvas_array.shape\n\n    @property\n    def x_linked(self) -&gt; bool:\n        \"\"\"Whether the x-axis of all canvases are linked.\"\"\"\n        return self._x_linked\n\n    @x_linked.setter\n    def x_linked(self, value: bool):\n        self.link_x() if value else self.unlink_x()\n\n    @property\n    def y_linked(self) -&gt; bool:\n        \"\"\"Whether the y-axis of all canvases are linked.\"\"\"\n        return self._y_linked\n\n    @y_linked.setter\n    def y_linked(self, value: bool):\n        self.link_y() if value else self.unlink_y()\n\n    def link_x(self, future: bool = True) -&gt; Self:\n        \"\"\"\n        Link all the x-axes of the canvases in the grid.\n\n        &gt;&gt;&gt; from whitecanvas import grid\n        &gt;&gt;&gt; g = grid(2, 2).link_x()  # link x-axes of all canvases\n\n        Parameters\n        ----------\n        future : bool, default True\n            If Ture, all the canvases added in the future will also be linked. Only link\n            the existing canvases if False.\n        \"\"\"\n        if not self._x_linked:\n            for _, canvas in self.iter_canvas():\n                canvas.x.events.lim.connect(self._align_xlims, unique=True)\n            if future:\n                self._x_linked = True\n        return self\n\n    def link_y(self, future: bool = True) -&gt; Self:\n        \"\"\"\n        Link all the y-axes of the canvases in the grid.\n\n        &gt;&gt;&gt; from whitecanvas import grid\n        &gt;&gt;&gt; g = grid(2, 2).link_y()  # link y-axes of all canvases\n\n        Parameters\n        ----------\n        future : bool, default True\n            If Ture, all the canvases added in the future will also be linked. Only link\n            the existing canvases if False.\n        \"\"\"\n        if not self._y_linked:\n            for _, canvas in self.iter_canvas():\n                canvas.y.events.lim.connect(self._align_ylims, unique=True)\n            if future:\n                self._y_linked = True\n        return self\n\n    def unlink_x(self, future: bool = True) -&gt; Self:\n        \"\"\"Unlink all the x-axes of the canvases in the grid.\"\"\"\n        if self._x_linked:\n            for _, canvas in self.iter_canvas():\n                canvas.x.events.lim.disconnect(self._align_xlims)\n            if future:\n                self._x_linked = False\n        return self\n\n    def unlink_y(self, future: bool = True) -&gt; Self:\n        \"\"\"Unlink all the y-axes of the canvases in the grid.\"\"\"\n        if self._y_linked:\n            for _, canvas in self.iter_canvas():\n                canvas.y.events.lim.disconnect(self._align_ylims)\n            if future:\n                self._y_linked = False\n        return self\n\n    def __repr__(self) -&gt; str:\n        cname = type(self).__name__\n        w, h = self._size\n        hex_id = hex(id(self))\n        return f\"&lt;{cname} ({w:.1f} x {h:.1f}) at {hex_id}&gt;\"\n\n    def __getitem__(self, key: tuple[int, int]) -&gt; Canvas:\n        canvas = self._canvas_array[key]\n        if canvas is None:\n            raise IndexError(f\"Canvas at {key} is not set\")\n        return canvas\n\n    def _create_backend(self) -&gt; protocols.CanvasGridProtocol:\n        return self._backend.get(\"CanvasGrid\")(\n            self._heights, self._widths, self._backend._app\n        )\n\n    def _align_xlims(self, lim: tuple[float, float]):\n        for _, canvas in self.iter_canvas():\n            with canvas.x.events.lim.blocked():\n                canvas.x.lim = lim\n\n    def _align_ylims(self, lim: tuple[float, float]):\n        for _, canvas in self.iter_canvas():\n            with canvas.y.events.lim.blocked():\n                canvas.y.lim = lim\n\n    def fill(self, palette: ColormapType | None = None) -&gt; Self:\n        \"\"\"Fill the grid with canvases.\"\"\"\n        for _ in self.iter_add_canvas(palette=palette):\n            pass\n        return self\n\n    def add_canvas(\n        self,\n        row: int,\n        col: int,\n        rowspan: int = 1,\n        colspan: int = 1,\n        palette: str | None = None,\n    ) -&gt; Canvas:\n        \"\"\"Add a canvas to the grid at the given position\"\"\"\n        for idx, item in np.ndenumerate(self._canvas_array[row, col]):\n            if item is not None:\n                raise ValueError(f\"Canvas already exists at {idx}\")\n        backend_canvas = self._backend_object._plt_add_canvas(\n            row, col, rowspan, colspan\n        )\n        canvas = self._canvas_array[row, col] = Canvas.from_backend(\n            backend_canvas,\n            backend=self._backend,\n            palette=palette,\n        )\n        # Now backend axes/viewbox are created, we can install mouse events\n        canvas._install_mouse_events()\n\n        # link axes if needed\n        if self.x_linked:\n            canvas.x.events.lim.connect(self._align_xlims, unique=True)\n        if self.y_linked:\n            canvas.y.events.lim.connect(self._align_ylims, unique=True)\n        canvas.events.drawn.connect(self.events.drawn.emit, unique=True)\n        return canvas\n\n    def iter_add_canvas(self, **kwargs) -&gt; Iterator[Canvas]:\n        for row in range(len(self._heights)):\n            for col in range(len(self._widths)):\n                yield self.add_canvas(row, col, **kwargs)\n\n    def iter_canvas(self) -&gt; Iterator[tuple[tuple[int, int], Canvas]]:\n        yielded: set[int] = set()\n        for idx, canvas in np.ndenumerate(self._canvas_array):\n            _id = id(canvas)\n            if canvas is None or _id in yielded:\n                continue\n            yield idx, canvas\n            yielded.add(_id)\n\n    def show(self, block=False) -&gt; None:\n        \"\"\"Show the grid.\"\"\"\n        from whitecanvas.backend._app import get_app\n\n        # TODO: implement other event loops\n        app = get_app(self._backend._app)\n        _backend_app = app.get_app()\n        out = self._backend_object._plt_show()\n\n        if out is NotImplemented:\n            from whitecanvas.backend._window import view\n\n            view(self, self._backend.app)\n\n        if block:\n            # TODO: automatically block the event loop or enable ipython\n            # GUI mode if needed.\n            app.run_app()\n\n    @property\n    def background_color(self) -&gt; NDArray[np.floating]:\n        \"\"\"Background color of the canvas.\"\"\"\n        return arr_color(self._backend_object._plt_get_background_color())\n\n    @background_color.setter\n    def background_color(self, color):\n        self._backend_object._plt_set_background_color(arr_color(color))\n\n    def screenshot(self) -&gt; NDArray[np.uint8]:\n        \"\"\"Return a screenshot of the grid.\"\"\"\n        return self._backend_object._plt_screenshot()\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        \"\"\"Size in width x height.\"\"\"\n        return self._size\n\n    @size.setter\n    def size(self, size: tuple[int, int]):\n        w, h = size\n        if w &lt;= 0 or h &lt;= 0:\n            raise ValueError(\"Size must be positive\")\n        self._size = (int(w), int(h))\n        self._backend_object._plt_set_figsize(*self._size)\n\n    def _repr_png_(self):\n        \"\"\"Return PNG representation of the widget for QtConsole.\"\"\"\n        from io import BytesIO\n\n        try:\n            from imageio import imwrite\n        except ImportError:\n            return None\n\n        rendered = self.screenshot()\n        if rendered is not None:\n            with BytesIO() as file_obj:\n                imwrite(file_obj, rendered, format=\"png\")\n                file_obj.seek(0)\n                return file_obj.read()\n        return None\n\n    def _ipython_display_(self, *args: Any, **kwargs: Any) -&gt; Any:\n        if hasattr(self._backend_object, \"_ipython_display_\"):\n            return self._backend_object._ipython_display_(*args, **kwargs)\n        raise NotImplementedError()\n\n    def _repr_mimebundle_(self, *args: Any, **kwargs: Any) -&gt; dict:\n        if hasattr(self._backend_object, \"_repr_mimebundle_\"):\n            return self._backend_object._repr_mimebundle_(*args, **kwargs)\n        raise NotImplementedError()\n\n    def _repr_html_(self, *args: Any, **kwargs: Any) -&gt; str:\n        if hasattr(self._backend_object, \"_repr_html_\"):\n            return self._backend_object._repr_html_(*args, **kwargs)\n        raise NotImplementedError()\n\n    def to_html(self, file: str | None = None) -&gt; str:\n        \"\"\"Return HTML representation of the grid.\"\"\"\n        html = self._backend.get(\"to_html\")(self._backend_object)\n        if file is not None:\n            Path(file).write_text(html, encoding=\"utf-8\")\n        return html\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.background_color","title":"<code>background_color: NDArray[np.floating]</code>  <code>property</code> <code>writable</code>","text":"<p>Background color of the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.shape","title":"<code>shape: tuple[int, int]</code>  <code>property</code>","text":"<p>The (row, col) shape of the grid</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.size","title":"<code>size: tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Size in width x height.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.x_linked","title":"<code>x_linked: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the x-axis of all canvases are linked.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.y_linked","title":"<code>y_linked: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the y-axis of all canvases are linked.</p>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.add_canvas","title":"<code>add_canvas(row, col, rowspan=1, colspan=1, palette=None)</code>","text":"<p>Add a canvas to the grid at the given position</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def add_canvas(\n    self,\n    row: int,\n    col: int,\n    rowspan: int = 1,\n    colspan: int = 1,\n    palette: str | None = None,\n) -&gt; Canvas:\n    \"\"\"Add a canvas to the grid at the given position\"\"\"\n    for idx, item in np.ndenumerate(self._canvas_array[row, col]):\n        if item is not None:\n            raise ValueError(f\"Canvas already exists at {idx}\")\n    backend_canvas = self._backend_object._plt_add_canvas(\n        row, col, rowspan, colspan\n    )\n    canvas = self._canvas_array[row, col] = Canvas.from_backend(\n        backend_canvas,\n        backend=self._backend,\n        palette=palette,\n    )\n    # Now backend axes/viewbox are created, we can install mouse events\n    canvas._install_mouse_events()\n\n    # link axes if needed\n    if self.x_linked:\n        canvas.x.events.lim.connect(self._align_xlims, unique=True)\n    if self.y_linked:\n        canvas.y.events.lim.connect(self._align_ylims, unique=True)\n    canvas.events.drawn.connect(self.events.drawn.emit, unique=True)\n    return canvas\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.fill","title":"<code>fill(palette=None)</code>","text":"<p>Fill the grid with canvases.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def fill(self, palette: ColormapType | None = None) -&gt; Self:\n    \"\"\"Fill the grid with canvases.\"\"\"\n    for _ in self.iter_add_canvas(palette=palette):\n        pass\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.link_x","title":"<code>link_x(future=True)</code>","text":"<p>Link all the x-axes of the canvases in the grid.</p> <p>from whitecanvas import grid g = grid(2, 2).link_x()  # link x-axes of all canvases</p> <p>Parameters:</p> Name Type Description Default <code>future</code> <code>bool</code> <p>If Ture, all the canvases added in the future will also be linked. Only link the existing canvases if False.</p> <code>True</code> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def link_x(self, future: bool = True) -&gt; Self:\n    \"\"\"\n    Link all the x-axes of the canvases in the grid.\n\n    &gt;&gt;&gt; from whitecanvas import grid\n    &gt;&gt;&gt; g = grid(2, 2).link_x()  # link x-axes of all canvases\n\n    Parameters\n    ----------\n    future : bool, default True\n        If Ture, all the canvases added in the future will also be linked. Only link\n        the existing canvases if False.\n    \"\"\"\n    if not self._x_linked:\n        for _, canvas in self.iter_canvas():\n            canvas.x.events.lim.connect(self._align_xlims, unique=True)\n        if future:\n            self._x_linked = True\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.link_y","title":"<code>link_y(future=True)</code>","text":"<p>Link all the y-axes of the canvases in the grid.</p> <p>from whitecanvas import grid g = grid(2, 2).link_y()  # link y-axes of all canvases</p> <p>Parameters:</p> Name Type Description Default <code>future</code> <code>bool</code> <p>If Ture, all the canvases added in the future will also be linked. Only link the existing canvases if False.</p> <code>True</code> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def link_y(self, future: bool = True) -&gt; Self:\n    \"\"\"\n    Link all the y-axes of the canvases in the grid.\n\n    &gt;&gt;&gt; from whitecanvas import grid\n    &gt;&gt;&gt; g = grid(2, 2).link_y()  # link y-axes of all canvases\n\n    Parameters\n    ----------\n    future : bool, default True\n        If Ture, all the canvases added in the future will also be linked. Only link\n        the existing canvases if False.\n    \"\"\"\n    if not self._y_linked:\n        for _, canvas in self.iter_canvas():\n            canvas.y.events.lim.connect(self._align_ylims, unique=True)\n        if future:\n            self._y_linked = True\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.screenshot","title":"<code>screenshot()</code>","text":"<p>Return a screenshot of the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def screenshot(self) -&gt; NDArray[np.uint8]:\n    \"\"\"Return a screenshot of the grid.\"\"\"\n    return self._backend_object._plt_screenshot()\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.show","title":"<code>show(block=False)</code>","text":"<p>Show the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def show(self, block=False) -&gt; None:\n    \"\"\"Show the grid.\"\"\"\n    from whitecanvas.backend._app import get_app\n\n    # TODO: implement other event loops\n    app = get_app(self._backend._app)\n    _backend_app = app.get_app()\n    out = self._backend_object._plt_show()\n\n    if out is NotImplemented:\n        from whitecanvas.backend._window import view\n\n        view(self, self._backend.app)\n\n    if block:\n        # TODO: automatically block the event loop or enable ipython\n        # GUI mode if needed.\n        app.run_app()\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.to_html","title":"<code>to_html(file=None)</code>","text":"<p>Return HTML representation of the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def to_html(self, file: str | None = None) -&gt; str:\n    \"\"\"Return HTML representation of the grid.\"\"\"\n    html = self._backend.get(\"to_html\")(self._backend_object)\n    if file is not None:\n        Path(file).write_text(html, encoding=\"utf-8\")\n    return html\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.uniform","title":"<code>uniform(nrows=1, ncols=1, *, backend=None)</code>  <code>classmethod</code>","text":"<p>Create a canvas grid with uniform row and column sizes.</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>int</code> <p>The number of rows in the grid.</p> <code>1</code> <code>ncols</code> <code>int</code> <p>The number of columns in the grid.</p> <code>1</code> <code>backend</code> <code>backend - like</code> <p>The backend to use for the grid.</p> <code>None</code> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>@classmethod\ndef uniform(\n    cls,\n    nrows: int = 1,\n    ncols: int = 1,\n    *,\n    backend: Backend | str | None = None,\n) -&gt; CanvasGrid:\n    \"\"\"\n    Create a canvas grid with uniform row and column sizes.\n\n    Parameters\n    ----------\n    nrows : int\n        The number of rows in the grid.\n    ncols : int\n        The number of columns in the grid.\n    backend : backend-like, optional\n        The backend to use for the grid.\n    \"\"\"\n    return CanvasGrid([10] * nrows, [10] * ncols, backend=backend)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.unlink_x","title":"<code>unlink_x(future=True)</code>","text":"<p>Unlink all the x-axes of the canvases in the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def unlink_x(self, future: bool = True) -&gt; Self:\n    \"\"\"Unlink all the x-axes of the canvases in the grid.\"\"\"\n    if self._x_linked:\n        for _, canvas in self.iter_canvas():\n            canvas.x.events.lim.disconnect(self._align_xlims)\n        if future:\n            self._x_linked = False\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.CanvasGrid.unlink_y","title":"<code>unlink_y(future=True)</code>","text":"<p>Unlink all the y-axes of the canvases in the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def unlink_y(self, future: bool = True) -&gt; Self:\n    \"\"\"Unlink all the y-axes of the canvases in the grid.\"\"\"\n    if self._y_linked:\n        for _, canvas in self.iter_canvas():\n            canvas.y.events.lim.disconnect(self._align_ylims)\n        if future:\n            self._y_linked = False\n    return self\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas","title":"<code>SingleCanvas</code>","text":"Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>class SingleCanvas(CanvasBase):\n    def __init__(self, grid: CanvasGrid):\n        if grid.shape != (1, 1):\n            raise ValueError(f\"Grid shape must be (1, 1), got {grid.shape}\")\n        self._grid = grid\n        _it = grid.iter_canvas()\n        _, canvas = next(_it)\n        if next(_it, None) is not None:\n            raise ValueError(\"Grid must have only one canvas\")\n        self._main_canvas = canvas\n        super().__init__(palette=self._main_canvas._color_palette)\n\n        # NOTE: events, dims etc are not shared between the main canvas and the\n        # SingleCanvas instance. To avoid confusion, the first and the only canvas\n        # should be replaces with the SingleCanvas instance.\n        grid._canvas_array[0, 0] = self\n        self.events.drawn.connect(self._main_canvas.events.drawn.emit, unique=True)\n\n    def _get_backend(self) -&gt; Backend:\n        \"\"\"Return the backend.\"\"\"\n        return self._main_canvas._backend\n\n    def _canvas(self):\n        return self._main_canvas._backend_object\n\n    @property\n    def native(self) -&gt; Any:\n        \"\"\"The native backend object.\"\"\"\n        return self._main_canvas.native\n\n    def show(self, block: bool = False) -&gt; None:\n        \"\"\"Show the canvas using the method defined in the backend.\"\"\"\n        self._grid.show(block=block)\n\n    @property\n    def background_color(self) -&gt; NDArray[np.floating]:\n        \"\"\"Background color of the canvas.\"\"\"\n        return self._grid.background_color\n\n    @background_color.setter\n    def background_color(self, color):\n        self._grid.background_color = color\n\n    @property\n    def size(self) -&gt; tuple[float, float]:\n        \"\"\"Size of the canvas\"\"\"\n        return self._grid.size\n\n    @size.setter\n    def size(self, size: tuple[float, float]):\n        self._grid.size = size\n\n    def screenshot(self) -&gt; NDArray[np.uint8]:\n        \"\"\"Return a screenshot of the grid.\"\"\"\n        return self._grid.screenshot()\n\n    def _repr_png_(self):\n        \"\"\"Return PNG representation of the widget for QtConsole.\"\"\"\n        return self._grid._repr_png_()\n\n    def _repr_mimebundle_(self, *args: Any, **kwargs: Any) -&gt; dict:\n        return self._grid._repr_mimebundle_(*args, **kwargs)\n\n    def _ipython_display_(self, *args: Any, **kwargs: Any) -&gt; Any:\n        return self._grid._ipython_display_(*args, **kwargs)\n\n    def _repr_html_(self, *args: Any, **kwargs: Any) -&gt; str:\n        return self._grid._repr_html_(*args, **kwargs)\n\n    def to_html(self, file: str | None = None) -&gt; str:\n        \"\"\"Return HTML representation of the canvas.\"\"\"\n        return self._grid.to_html(file=file)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas.background_color","title":"<code>background_color: NDArray[np.floating]</code>  <code>property</code> <code>writable</code>","text":"<p>Background color of the canvas.</p>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas.native","title":"<code>native: Any</code>  <code>property</code>","text":"<p>The native backend object.</p>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas.size","title":"<code>size: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Size of the canvas</p>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas.screenshot","title":"<code>screenshot()</code>","text":"<p>Return a screenshot of the grid.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def screenshot(self) -&gt; NDArray[np.uint8]:\n    \"\"\"Return a screenshot of the grid.\"\"\"\n    return self._grid.screenshot()\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas.show","title":"<code>show(block=False)</code>","text":"<p>Show the canvas using the method defined in the backend.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def show(self, block: bool = False) -&gt; None:\n    \"\"\"Show the canvas using the method defined in the backend.\"\"\"\n    self._grid.show(block=block)\n</code></pre>"},{"location":"api/canvas/#whitecanvas.canvas.SingleCanvas.to_html","title":"<code>to_html(file=None)</code>","text":"<p>Return HTML representation of the canvas.</p> Source code in <code>whitecanvas\\canvas\\_grid.py</code> <pre><code>def to_html(self, file: str | None = None) -&gt; str:\n    \"\"\"Return HTML representation of the canvas.\"\"\"\n    return self._grid.to_html(file=file)\n</code></pre>"},{"location":"api/core/","title":"whitecanvas.core","text":""},{"location":"api/core/#whitecanvas.core.grid","title":"<code>grid(nrows=1, ncols=1, *, size=None, backend=None)</code>","text":"<p>Create a canvas grid with uniform cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>int</code> <p>Number of rows.</p> <code>1</code> <code>ncols</code> <code>int</code> <p>Number of columns.</p> <code>1</code> <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasGrid</code> <p>Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def grid(\n    nrows: int = 1,\n    ncols: int = 1,\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasGrid:\n    \"\"\"\n    Create a canvas grid with uniform cell sizes.\n\n    Parameters\n    ----------\n    nrows : int, default 1\n        Number of rows.\n    ncols : int, default 1\n        Number of columns.\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name.\n\n    Returns\n    -------\n    CanvasGrid\n        Grid of empty canvases.\n    \"\"\"\n    g = CanvasGrid.uniform(nrows, ncols, backend=backend)\n    if size is not None:\n        g.size = size\n    return g\n</code></pre>"},{"location":"api/core/#whitecanvas.core.grid_nonuniform","title":"<code>grid_nonuniform(heights, widths, *, size=None, backend=None)</code>","text":"<p>Create a canvas grid with non-uniform cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>heights</code> <code>list of int</code> <p>Height ratio of the rows.</p> required <code>widths</code> <code>list of int</code> <p>Width ratio the columns.</p> required <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasGrid</code> <p>Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def grid_nonuniform(\n    heights: list[int],\n    widths: list[int],\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasGrid:\n    \"\"\"\n    Create a canvas grid with non-uniform cell sizes.\n\n    Parameters\n    ----------\n    heights : list of int\n        Height ratio of the rows.\n    widths : list of int\n        Width ratio the columns.\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name.\n\n    Returns\n    -------\n    CanvasGrid\n        Grid of empty canvases.\n    \"\"\"\n    g = CanvasGrid(heights, widths, backend=backend)\n    if size is not None:\n        g.size = size\n    return g\n</code></pre>"},{"location":"api/core/#whitecanvas.core.hgrid","title":"<code>hgrid(ncols=1, *, size=None, backend=None)</code>","text":"<p>Create a horizontal canvas grid with uniform cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>ncols</code> <code>int</code> <p>Number of columns.</p> <code>1</code> <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasHGrid</code> <p>1D Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def hgrid(\n    ncols: int = 1,\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasHGrid:\n    \"\"\"\n    Create a horizontal canvas grid with uniform cell sizes.\n\n    Parameters\n    ----------\n    ncols : int, default 1\n        Number of columns.\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name.\n\n    Returns\n    -------\n    CanvasHGrid\n        1D Grid of empty canvases.\n    \"\"\"\n    g = CanvasHGrid.uniform(ncols, backend=backend)\n    if size is not None:\n        g.size = size\n    return g\n</code></pre>"},{"location":"api/core/#whitecanvas.core.hgrid_nonuniform","title":"<code>hgrid_nonuniform(widths, *, size=None, backend=None)</code>","text":"<p>Create a horizontal canvas grid with non-uniform cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>widths</code> <code>list of int</code> <p>Width ratios of columns.</p> required <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasHGrid</code> <p>1D Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def hgrid_nonuniform(\n    widths: list[int],\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasHGrid:\n    \"\"\"\n    Create a horizontal canvas grid with non-uniform cell sizes.\n\n    Parameters\n    ----------\n    widths : list of int\n        Width ratios of columns.\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name.\n\n    Returns\n    -------\n    CanvasHGrid\n        1D Grid of empty canvases.\n    \"\"\"\n    g = CanvasHGrid(widths, backend=backend)\n    if size is not None:\n        g.size = size\n    return g\n</code></pre>"},{"location":"api/core/#whitecanvas.core.new_canvas","title":"<code>new_canvas(backend=None, *, size=None, palette=None)</code>","text":"<p>Create a new canvas with a single cell.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <code>size</code> <code>(int, int)</code> <p>Displaying size of the canvas (in pixels).</p> <code>None</code> <code>palette</code> <code>str or ColormapType</code> <p>Color palette of the canvas. This color palette will be used to generate colors for the plots.</p> <code>None</code> Source code in <code>whitecanvas\\core.py</code> <pre><code>def new_canvas(\n    backend: Backend | str | None = None,\n    *,\n    size: tuple[int, int] | None = None,\n    palette: str | ColormapType | None = None,\n) -&gt; SingleCanvas:\n    \"\"\"\n    Create a new canvas with a single cell.\n\n    Parameters\n    ----------\n    backend : Backend or str, optional\n        Backend name.\n    size : (int, int), optional\n        Displaying size of the canvas (in pixels).\n    palette : str or ColormapType, optional\n        Color palette of the canvas. This color palette will be used to generate colors\n        for the plots.\n    \"\"\"\n    _grid = grid(backend=backend)\n    _grid.add_canvas(0, 0, palette=palette)\n    cvs = SingleCanvas(_grid)\n    if size is not None:\n        cvs.size = size\n    return cvs\n</code></pre>"},{"location":"api/core/#whitecanvas.core.vgrid","title":"<code>vgrid(nrows=1, *, size=None, backend=None)</code>","text":"<p>Create a vertical canvas grid with uniform cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>int</code> <p>Number of rows.</p> <code>1</code> <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasVGrid</code> <p>1D Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def vgrid(\n    nrows: int = 1,\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasVGrid:\n    \"\"\"\n    Create a vertical canvas grid with uniform cell sizes.\n\n    Parameters\n    ----------\n    nrows : int, default 1\n        Number of rows.\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name.\n\n    Returns\n    -------\n    CanvasVGrid\n        1D Grid of empty canvases.\n    \"\"\"\n    g = CanvasVGrid.uniform(nrows, backend=backend)\n    if size is not None:\n        g.size = size\n    return g\n</code></pre>"},{"location":"api/core/#whitecanvas.core.vgrid_nonuniform","title":"<code>vgrid_nonuniform(heights, *, size=None, backend=None)</code>","text":"<p>Create a vertical canvas grid with non-uniform cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>heights</code> <code>list of int</code> <p>Height ratios of rows.</p> required <code>size</code> <code>(int, int)</code> <p>Displaying size of the grid (in pixels).</p> <code>None</code> <code>backend</code> <code>Backend or str</code> <p>Backend name.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanvasVGrid</code> <p>1D Grid of empty canvases.</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def vgrid_nonuniform(\n    heights: list[int],\n    *,\n    size: tuple[int, int] | None = None,\n    backend: Backend | str | None = None,\n) -&gt; CanvasVGrid:\n    \"\"\"\n    Create a vertical canvas grid with non-uniform cell sizes.\n\n    Parameters\n    ----------\n    heights : list of int\n        Height ratios of rows.\n    size : (int, int), optional\n        Displaying size of the grid (in pixels).\n    backend : Backend or str, optional\n        Backend name.\n\n    Returns\n    -------\n    CanvasVGrid\n        1D Grid of empty canvases.\n    \"\"\"\n    g = CanvasVGrid(heights, backend=backend)\n    if size is not None:\n        g.size = size\n    return g\n</code></pre>"},{"location":"api/core/#whitecanvas.core.wrap_canvas","title":"<code>wrap_canvas(obj, palette=None)</code>","text":"<p>Wrap a backend object into a whitecanvas Canvas.</p> <p>import matplotlib.pyplot as plt canvas = wrap_canvas(plt.gca())</p> Source code in <code>whitecanvas\\core.py</code> <pre><code>def wrap_canvas(obj: Any, palette=None) -&gt; Canvas:\n    \"\"\"\n    Wrap a backend object into a whitecanvas Canvas.\n\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; canvas = wrap_canvas(plt.gca())\n    \"\"\"\n    typ = type(obj).__name__\n\n    if _is_in_module(typ, \"matplotlib\", \"Axes\"):\n        from matplotlib.axes import Axes\n\n        from whitecanvas.backend.matplotlib import Canvas as BackendCanvas\n\n        if not isinstance(obj, Axes):\n            raise TypeError(f\"Expected matplotlib Axes, got {typ}\")\n        backend = \"matplotlib\"\n\n    elif _is_in_module(typ, \"plotly\", \"Figure\"):\n        from plotly.graph_objs import Figure\n\n        from whitecanvas.backend.plotly import Canvas as BackendCanvas\n\n        if not isinstance(obj, Figure):\n            raise TypeError(f\"Expected plotly Figure, got {typ}\")\n        backend = \"plotly\"\n    elif _is_in_module(typ, \"bokeh\", \"Plot\"):\n        from bokeh.models import Plot\n\n        from whitecanvas.backend.bokeh import Canvas as BackendCanvas\n\n        if not isinstance(obj, Plot):\n            raise TypeError(f\"Expected bokeh Plot, got {typ}\")\n        backend = \"bokeh\"\n    elif _is_in_module(typ, \"vispy\", \"ViewBox\"):\n        from vispy.scene import ViewBox\n\n        from whitecanvas.backend.vispy import Canvas as BackendCanvas\n\n        if not isinstance(obj, ViewBox):\n            raise TypeError(f\"Expected vispy ViewBox, got {typ}\")\n        backend = \"vispy\"\n    elif _is_in_module(typ, \"pyqtgraph\", \"ViewBox\"):\n        from pyqtgraph import ViewBox\n\n        from whitecanvas.backend.pyqtgraph import Canvas as BackendCanvas\n\n        if not isinstance(obj, ViewBox):\n            raise TypeError(f\"Expected pyqtgraph ViewBox, got {typ}\")\n        backend = \"pyqtgraph\"\n    else:\n        raise TypeError(f\"Cannot convert {typ} to Canvas\")\n    return Canvas.from_backend(BackendCanvas(obj), palette=palette, backend=backend)\n</code></pre>"},{"location":"canvas/","title":"Canvas","text":"<ul> <li>Basics</li> <li>Namespaces</li> <li>Canvas Grid</li> <li>Working with the Backend Objects</li> </ul>"},{"location":"canvas/basics/","title":"Basics","text":"<p>In <code>whitecanvas</code>, a \"canvas\" is an object with a layer list, axes elements, labels and methods to handle them. A \"grid\" is a collection of canvases and is implemented with rendering backends.</p>"},{"location":"canvas/basics/#create-canvases","title":"Create Canvases","text":"<p>Canvas is created by <code>new_canvas</code> method.</p> <ul> <li><code>backend</code>: the name of the backend to use.</li> <li><code>size</code>: the size of the canvas (width \u00d7 height in pixels).</li> <li><code>palette</code>: the name of the color palette to use. Any input that is accepted by the   cmap.Colormap can be used,   which includes:</li> <li>The name of the built-in colormaps, such as \"viridis\", \"plasma\", etc.</li> <li>Sequence of colors, such as <code>[\"red\", \"green\", \"blue\"]</code>.</li> <li>A <code>cmap.Colormap</code> object.</li> </ul> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\", size=(400, 300), palette=\"tab10\")\n</code></pre> <p>A <code>SingleCanvas</code> object is returned. It can be considered as a mixture of a canvas and a grid. All of the functions mentioned above are implemented in this object. Therefore, you can show the canvas by calling the <code>show</code> method.</p> <pre><code>canvas.show()  # show the canvas, depending on the backend\n</code></pre>"},{"location":"canvas/basics/#namespaces","title":"Namespaces","text":"<p>To make the API tidy, each element of a canvas is organized in namespaces. By using namespaces, we can avoid the long list of arguments and make the code more readable. For example, the x-limit of the canvas is controlled by the property <code>canvas.x.lim</code>.</p> <p>Following list shows the namespaces and the properties associated with them.</p> <ul> <li> <p><code>canvas.{x, y}</code>: the x/y-axis.</p> <ul> <li>(property) <code>canvas.{x, y}.lim</code>: the x/y-limit as a tuple of floats.</li> <li>(property) <code>canvas.{x, y}.color</code>: the color of the x/y-axis.</li> <li>(property) <code>canvas.{x, y}.flipped</code>: whether the x/y-axis is flipped.</li> <li><code>canvas.{x, y}.label</code>: the x/y-axis label.<ul> <li>(property) <code>canvas.{x, y}.label.text</code>: the text of the label.</li> <li>(property) <code>canvas.{x, y}.label.color</code>: the color of the label as <code>ndarray</code>.</li> <li>(property) <code>canvas.{x, y}.label.size</code>: the font size of the label.</li> <li>(property) <code>canvas.{x, y}.label.family</code>: the font family of the label.</li> <li>(property) <code>canvas.{x, y}.label.visible</code>: the visibility of the label.</li> </ul> </li> <li><code>canvas.{x, y}.ticks</code>: the x/y-axis ticks.<ul> <li>(property) <code>canvas.{x, y}.ticks.pos</code>: the position of the ticks (read-only).</li> <li>(property) <code>canvas.{x, y}.ticks.labels</code>: the labels of the ticks (read-only).</li> <li>(property) <code>canvas.{x, y}.ticks.color</code>: the color of the ticks.</li> <li>(property) <code>canvas.{x, y}.ticks.size</code>: the size of the ticks.</li> <li>(property) <code>canvas.{x, y}.ticks.rotation</code>: the color of the tick labels.</li> <li>(property) <code>canvas.{x, y}.ticks.visible</code>: the visibility of the ticks.</li> </ul> </li> </ul> </li> <li> <p><code>canvas.title</code>: the title object of the canvas.</p> <ul> <li>(property) <code>canvas.title.text</code>: the text of the title.</li> <li>(property) <code>canvas.title.color</code>: the color of the title as <code>ndarray</code>.</li> <li>(property) <code>canvas.title.size</code>: the font size of the title.</li> <li>(property) <code>canvas.title.family</code>: the font family of the title.</li> <li>(property) <code>canvas.title.visible</code>: the visibility of the title.</li> </ul> </li> </ul> <p>Note</p> <p><code>canvas.title</code>, <code>canvas.{x, y}.label</code> and <code>canvas.{x, y}.ticks</code> share the same properties (<code>color</code>, <code>size</code>, <code>family</code> and <code>visible</code>) related to the text design.</p> <p>Event handlers are also organized in namespaces. At any level, the value-changed event for the parameter <code>X</code> is in <code>events.X</code>. For example, when the x-limit is changed, signal will be emitted from <code>canvas.x.events.lim</code>. See Event Handling for more details.</p>"},{"location":"canvas/basics/#update-canvas-appearance","title":"Update Canvas Appearance","text":"<p>Canvases have helper functions of name <code>update_*</code> to update the appearance. They return the canvas itself, so that you can chain the methods after the constructor.</p> <pre><code># update the color of x/y-axis\ncanvas = new_canvas().update_axes(color=\"gray\")\n\n# update the text labels\ncanvas = new_canvas().update_labels(x=\"time\", y=\"value\", title=\"My Plot\")\n</code></pre>"},{"location":"canvas/basics/#add-layers","title":"Add Layers","text":"<p>All the plotting elements are added to the canvas as a \"layer\". In <code>whitecanvas</code>, a layer is rarely constructed directly, but is returned by the <code>add_*</code> methods. Same method always returns the same type of layer.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nline = canvas.add_line([0, 1, 2, 3], [0, 1, 1, 0])\nmarkers = canvas.add_markers([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.show()\n</code></pre> </p> <p>See Layers for more details.</p>"},{"location":"canvas/grid/","title":"Canvas Grid","text":"<p>A \"canvas grid\" is a grid of canvases (which is called \"figure\" in <code>matplotlib</code>). A grid is composed of multiple canvas objects, so that grid itself does not have either layers or the <code>add_*</code> methods.</p> <p>Once a grid is created, you can add chid canvases using the <code>add_canvas</code> method. The signature of the method differs between 1D and 2D grid.</p>"},{"location":"canvas/grid/#verticalhorizontal-grid","title":"Vertical/Horizontal Grid","text":"<p><pre><code>from whitecanvas import vgrid\n\ngrid = vgrid(3, backend=\"matplotlib\")\n\nc0 = grid.add_canvas(0)\nc0.add_text(0, 0, \"Canvas 0\")\nc1 = grid.add_canvas(1)\nc1.add_text(0, 0, \"Canvas 1\")\nc2 = grid.add_canvas(2)\nc2.add_text(0, 0, \"Canvas 2\")\ngrid.show()\n</code></pre> </p> <p><pre><code>from whitecanvas import hgrid\n\ngrid = hgrid(3, backend=\"matplotlib\")\n\nc0 = grid.add_canvas(0)\nc0.add_text(0, 0, \"Canvas 0\")\nc1 = grid.add_canvas(1)\nc1.add_text(0, 0, \"Canvas 1\")\nc2 = grid.add_canvas(2)\nc2.add_text(0, 0, \"Canvas 2\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/grid/#2d-grid","title":"2D Grid","text":"<p><pre><code>from whitecanvas import grid as grid2d\n\ngrid = grid2d(2, 2, backend=\"matplotlib\")\n\nfor i, j in [(0, 0), (0, 1), (1, 0), (1, 1)]:\n    c = grid.add_canvas(i, j)\n    c.add_text(0, 0, f\"Canvas ({i}, {j})\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/grid/#non-uniform-grid","title":"Non-uniform Grid","text":"<p>The <code>*_nonuniform</code> functions allow you to create a grid with non-uniform sizes. Instead of specifying the number of rows and columns, these functions take a list of size ratios.</p> <p>Note</p> <p>This feature is work in progress. Some backends does not support it yet.</p> <p><pre><code>from whitecanvas import grid_nonuniform\n\ngrid = grid_nonuniform([1, 2], [2, 1], backend=\"matplotlib\")\n\nfor i, j in [(0, 0), (0, 1), (1, 0), (1, 1)]:\n    c = grid.add_canvas(i, j)\n    c.add_text(0, 0, f\"Canvas ({i}, {j})\")\ngrid.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/","title":"Namespaces","text":"<p>Each canvas has several namespaces to control the appearance of the canvas. First of all, the x/y-axis properties are controlled by the <code>x</code> and <code>y</code> namespaces.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(backend=\"matplotlib\")\n\ncanvas.x.lim = (0, 10)\ncanvas.x.color = \"red\"\ncanvas.x.flipped = True\ncanvas.x.set_gridlines(color=\"gray\", width=1, style=\":\")\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/#labels","title":"Labels","text":"<p>You can set x/y labels using the <code>label</code> property.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.label = \"X axis\"\ncanvas.y.label = \"Y axis\"\ncanvas.show()\n</code></pre> </p> <p>The <code>label</code> property is actually another namespace. You can specify the text, font size, etc. separately.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\ncanvas.x.label.text = \"X axis\"\ncanvas.x.label.size = 20\ncanvas.x.label.family = \"Arial\"\ncanvas.x.label.color = \"red\"\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/#ticks","title":"Ticks","text":"<p>The tick properties can be set via <code>ticks</code> property.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.ticks.color = \"red\"\ncanvas.x.ticks.size = 12\ncanvas.x.ticks.family = \"Arial\"\ncanvas.x.ticks.rotation = 45\ncanvas.show()\n</code></pre> </p> <p>You can also override or reset the tick labels.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.x.ticks.set_labels([0, 1, 2], [\"zero\", \"one\", \"two\"])\ncanvas.x.ticks.reset_labels()\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/namespaces/#title","title":"Title","text":"<p>Canvas title can be set via the <code>title</code> namespace.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.title.color = \"teal\"\ncanvas.title.size = 16\ncanvas.title.family = \"Times New Roman\"\ncanvas.show()\n</code></pre> </p>"},{"location":"canvas/native_objects/","title":"Working with the Backend Objects","text":""},{"location":"canvas/native_objects/#convert-a-backend-object-to-whitecanvas-canvas","title":"Convert a backend object to <code>whitecanvas</code> canvas","text":"<p>The <code>wrap_canvas</code> converts a backend object to a <code>whitecanvas</code> canvas.</p> <pre><code>from whitecanvas import wrap_canvas\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots()\naxes.set_title(\"Title\")  # operations in the backend side\n\ncanvas = wrap_canvas(axes)  # axes --&gt; canvas\ncanvas.add_line([0, 1, 2, 3, 4])\n\nplt.show()  # backend methods still work\n</code></pre>"},{"location":"canvas/native_objects/#retrieve-the-backend-object-from-a-whitecanvas-canvas","title":"Retrieve the backend object from a <code>whitecanvas</code> canvas","text":"<p>The backend object is available at the <code>native</code> property.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.native\n</code></pre> Output<pre><code>&lt;Axes: &gt;\n</code></pre>"},{"location":"canvas/native_objects/#combine-whitecanvas-with-applications","title":"Combine <code>whitecanvas</code> with Applications","text":""},{"location":"canvas/native_objects/#1-control-matplotlib-qt-application-with-whitecanvas","title":"1. Control <code>matplotlib</code> Qt application with <code>whitecanvas</code>","text":"<pre><code>#!skip\n# use `%gui qt` in IPython\nfrom whitecanvas import new_canvas\nimport matplotlib.pyplot as plt\nfrom qtpy import QtWidgets as QtW\n\ncanvas = new_canvas(\"matplotlib:qt\")\nqt_canvas = canvas.native.get_figure().canvas\n\nmain = QtW.QMainWindow()\nmain.setWindowTitle(\"myapp\")\nmain.setCentralWidget(qt_canvas)\nmain.show()\n</code></pre> <p>Since the <code>canvas</code> points to the same canvas as in the Qt application, you can control the application with <code>whitecanvas</code> API.</p> <pre><code>canvas.add_line([0, 1, 2, 3, 4])\n</code></pre>"},{"location":"categorical/","title":"Categorical Plot","text":"<p>Existing Python plotting libraries such as <code>seaborn</code> and <code>plotly</code> have an excellent support for high-level categorical plotting methods that use DataFrame objects as input.</p> <p>In <code>whitecanvas</code>, similar functions are provided, but these methods do not depend on any external plotting libraries or DataFrames, and are more flexible in some cases.</p>"},{"location":"categorical/#the-categorical-plotters","title":"The Categorical Plotters","text":"<p>Methods starting with \"cat\" return categorical plotters. Methods include:</p> <ul> <li><code>cat</code> ... plotter for numerical data in x/y-axis categorized by such as color.</li> <li><code>cat_x</code> ... plotter for categorical data in x-axis.</li> <li><code>cat_y</code> ... plotter for categorical data in y-axis.</li> <li><code>cat_xy</code> ... plotter for categorical data in both x- and y-axis.</li> </ul> <p>These methods need a tabular data and the names of the columns that will be used as the x and y values. Currently, following objects are allowed as the tabular data input:</p> <ul> <li><code>dict</code> of array-like objects</li> <li><code>pandas.DataFrame</code></li> <li><code>polars.DataFrame</code></li> </ul> <p>Following example shows how to make a strip plot.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nrng = np.random.default_rng(12345)\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"value\": rng.normal(size=130),\n}\n\ncanvas.cat_x(df, x=\"label\", y=\"value\").add_stripplot().with_edge(color=\"black\")\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/","title":"Categorical \u00d7 Numerical Data","text":"<p>In this section, following data will be used as an example:</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\nrng = np.random.default_rng(12345)\ndf = {\n    \"category\": [\"A\"] * 40 + [\"B\"] * 50,\n    \"observation\": np.concatenate([rng.random(40), rng.random(50) + 1.3]),\n    \"replicate\": [0] * 23 + [1] * 17 + [0] * 22 + [1] * 28,\n    \"temperature\": rng.normal(scale=2.8, size=90) + 22.0,\n}\n</code></pre> <p>How can we visualize the distributions for each category? There are several plots that use categorical axis as either the x- or y-axis, and numerical axis as the other. Examples are:</p> <ul> <li>Strip plot</li> <li>Swarm plot</li> <li>Violin plot</li> <li>Box plot</li> </ul> <p>Aside from the categorical axis, data points may further be grouped by other features, such as the marker symbol and the marker size. Things are even more complicated when the markers represent numerical values, such as their size being proportional to the value, or colored by a colormap.</p> <p><code>whitecanvas</code> provides a consistent and simple interface to handle all these cases. Methods used for this purpose are <code>cat_x</code> and <code>cat_y</code>, where <code>cat_x</code> will deem the x-axis as categorical, and <code>cat_y</code> will do the same for the y-axis.</p> <pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create the categorical plotter.\ncat_plt_x = canvas.cat_x(df, x=\"category\", y=\"observation\")\ncat_plt_y = canvas.cat_y(df, x=\"observation\", y=\"category\")\n</code></pre> <p><code>cat_x</code> and <code>cat_y</code> use the argument <code>x=</code> and <code>y=</code> to specify the columns that are used for the plot, where <code>x=</code> is the categorical axis for <code>cat_x</code> and <code>y=</code> for <code>cat_y</code>.</p> <pre><code>This is one of the important difference between `seaborn`. In `seaborn`, `orient` are\nused to specify the orientation of the plots. This design forces the user to add the\nargument `orient=` to every plot even though the orientation rarely changes during the\nuse of the same figure. In `whitecanvas`, you don't have to specify the orientation\nonce a categorical plotter is created by either `cat_x` or `cat_y`.\n</code></pre> <p>Multiplt columns can be used for the categorical axis, but only one column can be used for the numerical axis.</p> <pre><code># OK\ncanvas.cat_x(df, x=[\"category\", \"replicate\"], y=\"observation\")\n# OK\ncanvas.cat_y(df, x=\"observation\", y=[\"category\", \"replicate\"])\n# NG\ncanvas.cat_x(df, x=\"category\", y=[\"observation\", \"temperature\"])\n</code></pre>"},{"location":"categorical/cat_num/#non-marker-type-plots","title":"Non-marker-type Plots","text":"<p>Since plots without data point markers are more straightforward, we will start with them. It includes <code>add_violinplot</code>, <code>add_boxplot</code>, <code>add_pointplot</code> and <code>add_barplot</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat_x(df, x=\"category\", y=\"observation\").add_violinplot()\ncanvas.show()\n</code></pre> </p> <p>Violins can also be shown in different color. Specify the <code>color=</code> argument to do that.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p>By default, groups with different colors do not overlap. This is controlled by the <code>dodge=</code> argument. Set <code>dodge=False</code> to make them overlap (although it is not the way we usually do).</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"replicate\", dodge=False)\n)\ncanvas.show()\n</code></pre> </p> <p><code>hatch=</code> can also be specified in a similar way. It will change the hatch pattern of the violins.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(hatch=\"replicate\")\n)\ncanvas.show()\n</code></pre> </p> <p><code>color</code> and <code>hatch</code> can overlap with each other or the <code>x=</code> or <code>y=</code> argument.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_violinplot(color=\"category\")\n)\ncanvas.show()\n</code></pre> </p> <p><code>add_boxplot</code>, <code>add_pointplot</code> and <code>add_barplot</code> is very similar to <code>add_violinplot</code>.</p> <p><pre><code>from whitecanvas import hgrid\n\ncanvas = hgrid(ncols=3, size=(1600, 600), backend=\"matplotlib\")\n\nc0 = canvas.add_canvas(0)\nc0.cat_x(df, x=\"category\", y=\"observation\").add_boxplot()\nc0.title = \"boxplot\"\n\nc1 = canvas.add_canvas(1)\nc1.cat_x(df, x=\"category\", y=\"observation\").add_pointplot()\nc1.title = \"pointplot\"\n\nc2 = canvas.add_canvas(2)\nc2.cat_x(df, x=\"category\", y=\"observation\").add_barplot()\nc2.title = \"barplot\"\n\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/cat_num/#marker-type-plots","title":"Marker-type Plots","text":"<p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\")\n)\n</code></pre> </p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n)\n</code></pre> </p> <p>As for the <code>Markers</code> layer, <code>as_edge_only</code> will convert the face features to the edge features.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n    .as_edge_only(width=2)\n)\n</code></pre> </p> <p><code>with_hover_template</code> is also defined. All the column names can be used in the template format string.</p> <pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot(color=\"replicate\", dodge=True)\n    .with_hover_template(\"{category} (rep={replicate})\")\n)\n</code></pre> <p>Each marker size can represent a numerical value. <code>with_size</code> will map the numerical values of a column to the size of the markers.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot()\n    .with_size(\"temperature\")\n)\n</code></pre> </p> <p>Similarly, each marker color can represent a numerical value. <code>with_colormap</code> will map the value with an arbitrary colormap.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_stripplot()\n    .with_colormap(\"temperature\", cmap=\"coolwarm\")\n)\n</code></pre> </p> <p>Swarm plot is another way to visualize all the data points with markers.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\", y=\"observation\")\n    .add_swarmplot(sort=True)\n    .with_colormap(\"temperature\", cmap=\"coolwarm\")\n)\n</code></pre> </p>"},{"location":"categorical/cat_num/#aggregation","title":"Aggregation","text":"<p>Showing the aggregated data is a common way to efficiently visualize a lot of data. This task is usually done by the module specific group-by methods, but <code>whitecanvas</code> provides a built-in method to simplify the process.</p> <p>In following example, <code>mean()</code> is used to prepare a mean-aggregated plotter, which has <code>add_markers</code> method to add the mean markers to the plotter.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create a categorical plotter\ncat_plt = canvas.cat_x(df, x=\"category\", y=\"observation\")\n\n# plot all the data\ncat_plt.add_stripplot(color=\"category\")\n# plot the mean\ncat_plt.mean().add_markers(color=\"category\", size=20)\n\ncanvas.show()\n</code></pre> </p> <p>Similar <code>add_*</code> methods include <code>add_line()</code> and <code>add_bars()</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n\n# create a categorical plotter\ncat_plt = canvas.cat_x(df, x=\"category\", y=\"observation\")\n\n# plot all the data\ncat_plt.add_stripplot(color=\"category\")\n# plot the mean\ncat_plt.mean().add_line(width=3, color=\"black\")\n\ncanvas.show()\n</code></pre> </p> <p>Count plot is a special case of the aggregation. Use <code>count()</code> to make the plotter.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n(\n    canvas\n    .cat_x(df, x=\"category\")\n    .count()\n    .add_bars(color=\"replicate\", dodge=True)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"categorical/num_num/","title":"Numerical \u00d7 Numerical Data","text":""},{"location":"categorical/num_num/#categorical-lines-and-markers","title":"Categorical Lines and Markers","text":"<p>Line plot and scatter plot use numerical values for both x and y axes. In this case, the plot is categorized by such as color, marker symbol, etc.</p> <pre><code>from whitecanvas import new_canvas\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 5 + [\"B\"] * 5,\n    \"x\": [0, 1, 2, 3, 4, 0, 1, 2, 3, 4],\n    \"y\": [3, 1, 2, 4, 3, 5, 3, 3, 1, 2],\n    \"some-info\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"],\n}\n</code></pre> <p>By setting <code>color=</code> to one of the column name, lines are split by the column and different colors are used for each group.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>By setting <code>style=</code>, different line styles are used instead. In the following example, <code>color=\"black\"</code> means that all the lines should be the same color (black).</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_line(color=\"black\", style=\"label\")\ncanvas.show()\n</code></pre> </p> <p>In the case of markers, you can use symbols to distinguish groups.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, \"x\", \"y\").add_markers(symbol=\"label\")\ncanvas.show()\n</code></pre> </p> <p>The layers implement hover texts by default, based on the input data frame.</p> <pre><code>canvas = new_canvas(\"plotly\", size=(400, 300))\ncanvas.cat(df, \"x\", \"y\").add_markers(color=\"label\")\ncanvas.show()\n</code></pre>"},{"location":"categorical/num_num/#distribution-of-numerical-data","title":"Distribution of Numerical Data","text":"<p>There are several ways to visualize the distribution of numerical data.</p> <ul> <li>Histogram</li> <li>Kernel Density Estimation (KDE)</li> </ul> <p>These representations only use one array of numerical data. Therefore, either <code>x</code> or <code>y</code> should be empty in the <code>cat</code> method.</p> <pre><code>import numpy as np\n\nrng = np.random.default_rng(12345)\n\n# sample data\ndf = {\n    \"label\": [\"A\"] * 60 + [\"B\"] * 30 + [\"C\"] * 40,\n    \"X\": rng.normal(loc=0.0, size=130),\n    \"Y\": rng.normal(loc=1.0, size=130),\n}\n</code></pre> <p><code>x=\"X\"</code> means that the x-axis being \"X\" and the y-axis being the count. Arguments forwards to the <code>histogram</code> method of <code>numpy</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>To transpose the histogram, use <code>y=\"X\"</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, y=\"X\").add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>Histograms can be grouped by color.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_hist(bins=10, color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>If both <code>x</code> and <code>y</code> are set, the plotter cannot determine which axis to use. To tell the plotter which axis to use, call <code>along_x()</code> or <code>along_y()</code> to restrict the dimension.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\n# canvas.cat(df, x=\"label\", y=\"X\").add_hist(bins=10)  # This will raise an error\ncanvas.cat(df, x=\"label\", y=\"X\").along_y().add_hist(bins=10)\ncanvas.show()\n</code></pre> </p> <p>KDE can be similarly added.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\").add_kde(color=\"label\")\ncanvas.show()\n</code></pre> </p> <p>2-dimensional histogram can be added by <code>add_hist2d</code>.</p> <p><pre><code>canvas = new_canvas(\"matplotlib\")\ncanvas.cat(df, x=\"X\", y=\"Y\").add_hist2d(cmap=[\"white\", \"blue\"], bins=(8, 10))\ncanvas.show()\n</code></pre> </p> <p>Note</p> <p><code>add_hist</code> and <code>add_hist2d</code> returns completely different objects (histogram and heatmap) and they are configured by different arguments. That's why <code>whitecanvas</code> split them into two different methods.</p>"},{"location":"events/","title":"Event Handling","text":"<p>Listening to the changes in the canvas or layer states is a common task in interactive plotting. Although different backend plotting libraries implement their own event handling systems, <code>whitecanvas</code> provides a unified system using the psygnal library.</p> <p>The common syntax is to use <code>connect</code> function to connect callback function to the event handler.</p> <pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas()\n\n# connect callback function\n@canvas.x.events.lim.connect\ndef _xlim_changed(lim):\n    print(f\"canvas.x.lim changed to {lim}\")\n</code></pre> <ul> <li>Canvas Events</li> <li>Layer Events</li> <li>Mouse Events</li> </ul>"},{"location":"events/canvas_events/","title":"Canvas Events","text":""},{"location":"events/layer_events/","title":"Layer Events","text":""},{"location":"events/mouse_events/","title":"Mouse Events","text":""},{"location":"layers/","title":"Layers","text":"<ul> <li>Lines</li> <li>Markers</li> <li>Layer Groups</li> </ul>"},{"location":"layers/face_layers/","title":"Face&amp;Edge-type Layers","text":"<p>There are several layers that is composed of faces and edges.</p> <ul> <li><code>Bars</code> ... a layer composed of bars.</li> <li><code>Band</code> ... a layer composed of a band region (fill-between region).</li> <li><code>Spans</code> ... a layer composed of infinitely long spans.</li> </ul> <p>These layers have two namespaces: <code>face</code> and <code>edge</code>. <code>face</code> has following properties:</p> <ul> <li><code>color</code> ... color of the faces. Any color-like object is accepted.</li> <li><code>hatch</code> ... hatch pattern of the faces. Should be one of <code>\"\"</code>, <code>\"-\"</code>, <code>\"|</code>, <code>\"+\"</code>,   <code>\"/\"</code>, <code>\"\\\\\"</code>, <code>\"x\"</code> or <code>\".\"</code>.</li> </ul> <p>Note</p> <p><code>hatch</code> is not supported in some backends.</p> <p><code>edge</code> has following properties:</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>Methods for adding these layers always configure the <code>face</code> properties with the arguments. You can use the <code>with_edge</code> method of the output layer to set edge properties. This separation is very helpful to prevent the confusion of the arguments, especially the colors.</p> <p>Following example uses <code>add_bars</code> and <code>add_spans</code> methods to create <code>Bars</code> and <code>Spans</code> layers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nbars_layer = (\n    canvas\n    .add_bars([0, 1, 2, 3], [3, 4, 1, 2], color=\"yellow\")\n    .with_edge(color=\"black\")\n)\n\nspans_layer = (\n    canvas\n    .add_spans([[0.2, 0.8], [1.4, 2.1], [1.8, 3.0]], color=\"blue\")\n    .with_edge(color=\"black\")\n)\ncanvas.y.lim = (0, 5)\ncanvas.show()\n</code></pre> </p> <p>All the properties can be set via properties of <code>face</code> and <code>edge</code>, or the <code>update</code> method.</p> <pre><code>#!skip\nbars_layer.face.color = \"yellow\"\nbars_layer.face.hatch = \"x\"\n\nspans_layer.edge.color = \"black\"\nspans_layer.edge.width = 2\nspans_layer.edge.style = \"--\"\n\n# use `update`\nbars_layer.face.update(color=\"yellow\", hatch=\"x\")\nspans_layer.edge.update(color=\"black\", width=2, style=\"--\")\n</code></pre>"},{"location":"layers/face_layers/#multi-face-and-multi-edge","title":"Multi-face and Multi-edge","text":"<p>As for <code>Markers</code>, <code>Bars</code> and <code>Spans</code> supports multi-face and multi-edge.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_bars([0, 1, 2, 3], [3, 4, 1, 2])\n    .with_face_multi(color=[\"red\", \"#00FF00\", \"rgb(0, 0, 255)\", \"black\"])\n)\ncanvas.show()\n</code></pre> </p> <p>After calling <code>with_face_multi</code>, the layer <code>face</code> property will return arrays instead of scalar values.</p> <pre><code>layer.face.color  # (N, 4) array of RGBA colors\nlayer.face.hatch  # (N,) array of hatchs\nlayer.face.alpha # (N,) array of alpha values\n</code></pre>"},{"location":"layers/layer_groups/","title":"Layer Groups","text":"<p>To plot complex layers, <code>whitecanvas</code> uses the layer-grouping strategy. There are several built-in layer groups.</p> <ul> <li><code>Plot</code> = <code>Line</code> + <code>Markers</code></li> <li><code>LineBand</code> = <code>Line</code> + <code>Band</code></li> <li><code>LabeledLine</code> = <code>Line</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledMarkers</code> = <code>Markers</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledBars</code> = <code>Bars</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>LabeledPlot</code> = <code>Plot</code> + <code>Errorbar</code> \u00d72 + <code>Texts</code></li> <li><code>Stem</code> = <code>Markers</code> + <code>MultiLine</code></li> <li><code>Graph</code> = <code>Markers</code> + <code>MultiLine</code> + <code>Texts</code></li> </ul> <p>These layer groups can be derived from primitive layers. It's very important to note that this layer-grouping architecture makes complex plots to have consistent argument with the individual plot elements.</p>"},{"location":"layers/layer_groups/#layer-groups-with-lines","title":"Layer Groups with Lines","text":"<p>In this section, we will introduce layer groups that are derived from the <code>Line</code> layer.</p>"},{"location":"layers/layer_groups/#add-markers-andor-error-bars","title":"Add markers and/or error bars","text":"<p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = canvas.add_line(\n    [0, 1, 2], [3, 2, 4], color=\"black\", name=\"myplot\",\n).with_markers(\n    symbol=\"o\", color=\"red\"\n)\ncanvas.show()\n</code></pre> </p> <p>The <code>with_markers</code> method returns a <code>Plot</code> layer, which has <code>Line</code> and <code>Markers</code> as its children. Therefore, at the very least, any customization can be done on the children.</p> <pre><code>print(layer)  # Plot&lt;'myplot'&gt;\nprint(layer.line)  # Line&lt;'line-of-myplot'&gt;\nprint(layer.markers)  # Markers&lt;'markers-of-myplot'&gt;\n</code></pre> <p>Once the layer is grouped, layer group instead of the child layers are in the layer list.</p> <pre><code>print(canvas.layers)  # LayerList([Plot&lt;'myplot'&gt;])\n</code></pre> <p>The <code>Plot</code> layer can be further converted into a <code>LabeledPlot</code> layer by adding error bars using <code>with_xerr</code> and/or <code>with_yerr</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"black\")\n    .with_markers(symbol=\"o\", color=\"red\")\n    .with_yerr([0.1, 0.2, 0.3])\n    .with_xerr([0.2, 0.3, 0.2], style=\"--\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/layer_groups/#add-bands","title":"Add bands","text":"<p><code>Band</code> may be used for different purposes.</p> <ol> <li>To fill the area of confidence interval.</li> <li>To fill the area between the line and the x- or y-axis.</li> </ol> <p>Both cases can be achieved using the <code>Line</code> methods.</p> <p>To fill the area that represents the errors, such as confidence interval and standard deviation, use the <code>with_xband</code> or <code>with_yband</code> method.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n# one array for the same size of lower and upper bounds\n(\n    canvas\n    .add_line([0, 1, 2], [3, 2, 4], color=\"blue\")\n    .with_yband([0.2, 0.3, 0.4])\n)\n# two arrays for different sizes of lower and upper bounds\n(\n    canvas\n    .add_line([2, 3, 4], [1, 0, 2], color=\"red\")\n    .with_yband([0.2, 0.3, 0.4], [0.4, 0.6, 0.8])\n)\n\ncanvas.show()\n</code></pre> </p> <p>To fill the area between the line and the axis, use the <code>with_xfill</code> or <code>with_yfill</code> respectively.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_line([1, 2, 3], [2.4, 3, 4], color=\"blue\")\n    .with_xfill()\n)\n(\n    canvas\n    .add_line([2, 3, 4], [2, 1, 2], color=\"red\")\n    .with_yfill()\n)\n\ncanvas.show()\n</code></pre> </p> <p>Warning</p> <p><code>with_xfill</code> fill the area between the line and the y-axis. This is because the orientation of the filling is in the direction of the y-axis, consistent with the methods such as <code>with_xband</code> and <code>with_xerr</code>.</p>"},{"location":"layers/layer_groups/#layer-groups-with-markers","title":"Layer Groups with Markers","text":""},{"location":"layers/layer_groups/#markers-with-error-bars","title":"Markers with error bars","text":"<p>Similar to the <code>Line</code> layer, the <code>Markers</code> layer can also be grouped with the <code>Errorbar</code> layer.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n(\n    canvas\n    .add_markers([0, 1, 2], [3, 2, 4], color=\"black\", symbol=\"D\", size=10)\n    .with_xerr([0.2, 0.3, 0.4], style=\"--\")\n    .with_yerr([0.3, 0.3, 0.5], style=\":\")\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/layer_groups/#markers-as-stems","title":"Markers as stems","text":"<p>The <code>Stem</code> layer is a layer group of <code>Markers</code> and <code>MultiLine</code>. It can be created using the <code>with_stem</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nx = np.linspace(0, 4 * np.pi, 50)\n(\n    canvas\n    .add_markers(x, np.sin(x))\n    .with_stem()\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/layer_groups/#markers-as-a-graph-network","title":"Markers as a graph network","text":"<p>A network graph is a collection of nodes and edges. The <code>Graph</code> layer is a layer group that can created using the <code>with_network</code> method of <code>Markers</code>. It uses the list of index pairs to connect markers.</p> <p><pre><code>from whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nnodes = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0], [0.5, 1.7]]\nconnections = [[0, 1], [0, 2], [1, 2], [0, 4], [2, 3]]\n\n(\n    canvas\n    .add_markers(nodes, size=40, color=\"skyblue\")\n    .with_edge(width=2, color=\"blue\")\n    .with_network(connections)\n    .with_text([\"i=0\", \"i=1\", \"i=2\", \"i=3\", \"i=4\"], size=20)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/","title":"Lines","text":"<p>There are several layers that is composed of only lines.</p> <ul> <li><code>Line</code> ... a simple line.</li> <li><code>InfLine</code> ... a straight line that extends to infinity</li> <li><code>InfCurve</code> ... a curve that extends to infinity</li> <li><code>Errorbar</code> ... lines representing error bars</li> <li><code>Rug</code> ... lines representing rug plots</li> </ul> <p>These layers have following properties in common.</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>These properties can be configured in function calls, via properties or the <code>update</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\n# function call\nlayer = canvas.add_line([0, 2, 1, 3, 4, 2, -1], color=\"black\", width=2, style=\":\")\n\n# properties\nlayer.color = \"#FF36D9\"\nlayer.width = 2.5\nlayer.style = \"-\"\n\n# update method\nlayer.update(color=[0.0, 1.0, 0.0, 1.0], width=1, style=\"--\")\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#line","title":"Line","text":"<p><code>Line</code> is a simple line defined by two arrays of x and y coordinates. It is usually created by the <code>add_line</code> method. This method accepts several ways to define the line coordinates.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.add_line([0, 1, 0, -1, 0])  # only y values\ncanvas.add_line([0, 1, 2, 3, 4], [1, 2, 1, 0, 1])  # x and y values\ncanvas.add_line(np.arange(5), np.array([2, 3, 2, 1, 2]))  # numpy arrays\ncanvas.add_line(np.array([[0, 3], [1, 4], [2, 3], [3, 2], [4, 3]]))  # (N, 2) array\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#infline","title":"InfLine","text":"<p><code>InfLine</code> is a straight line that extends to infinity. Practically, it is achieved by connecting a callback that updates the line coordinates when the canvas view range is updated.</p> <p><code>InfLine</code> is usually created by the <code>add_infline</code> method, or in the specific cases, <code>add_vline</code> and <code>add_hline</code> for vertical and horizontal lines, respectively.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_infline((0, 1), 45, color=\"black\")  # y = x + 1\ncanvas.add_vline(2, color=\"red\")  # x = 2\ncanvas.add_hline(-1, color=\"blue\")  # y = -1\ncanvas.x.lim = (-3, 3)\ncanvas.y.lim = (-3, 3)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#infcurve","title":"InfCurve","text":"<p><code>InfCurve</code> is a curve that extends to infinity, defined by an arbitrary model function. Practically, it is achieved by connecting a callback that resamples the curve when the canvas view range is updated.</p> <p><code>InfCurve</code> is usually created by the [<code>add_infcurve</code>][whitecanvas.canvas.CanvasBase. add_infcurve] method. The input model function must be defined as <code>model(x, ...)</code> where <code>x</code> is <code>ndarray</code> of the x-coordinates and the rest of the arguments are the parameters of the model. The parameters can be set by the <code>with_params</code> method of the returned layer.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ndef model(x, freq, phase):\n    return np.sin(x * freq - phase)\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_infcurve(model, color=\"black\").with_params(freq=2, phase=0)\ncanvas.add_infcurve(model, color=\"black\", style=\":\").with_params(freq=2, phase=1.6)\ncanvas.x.lim = (-3, 3)\ncanvas.y.lim = (-3, 3)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#errorbars","title":"Errorbars","text":"<p><code>Errorbars</code> is a layer that represents error bars with caps. It can be created by the <code>add_errorbars</code> method, but if you intend to add error bars to an existing layer with x/y data, try using the <code>with_xerr</code> and <code>with_yerr</code> methods of the layer to group layers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nx = [0, 1, 2]\nylow = [2, 3, 4]\nyhigh = [4, 5, 5]\ncanvas.add_errorbars(x, ylow, yhigh, capsize=0.5, width=3, color=\"crimson\")\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/lines/#rug","title":"Rug","text":"<p><code>Rug</code> is a layer that represents rug plot (or event plot). It can be created by the <code>add_rug</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\ncanvas.add_rug([0.0, 0.1, 0.3, 0.8, 1.4, 3.5], color=\"black\", width=2)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/markers/","title":"Markers","text":"<p><code>Markers</code> is a layer for scatter plots. It can be created with the <code>add_markers</code> method.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nlayer = canvas.add_markers([0, 1, 2, 3], [0, 1, 1, 0])\ncanvas.show()\n</code></pre> </p> <p>Symbol and size of the markers can easily be configured with the <code>symbol</code> and <code>size</code> arguments.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nfor i, symbol in enumerate([\"o\", \"s\", \"x\", \"+\"]):\n    for j, size in enumerate([5, 10, 15, 20]):\n        x = [i - 0.2, i - 0.2, i + 0.2, i + 0.2]\n        y = [j - 0.2, j + 0.2, j - 0.2, j + 0.2]\n        layer = canvas.add_markers(x, y, symbol=symbol, size=size)\ncanvas.show()\n</code></pre> </p> <p>Note</p> <p>If the symbol is edge-only, its color and visibility are automatically updated to ensure the markers are informative.</p>"},{"location":"layers/markers/#marker-properties","title":"Marker Properties","text":"<p><code>Markers</code> layer has two namespaces: <code>face</code> and <code>edge</code>. <code>face</code> has following properties:</p> <ul> <li><code>color</code> ... color of the faces. Any color-like object is accepted.</li> <li><code>hatch</code> ... hatch pattern of the faces. Should be one of <code>\"\"</code>, <code>\"-\"</code>, <code>\"|</code>, <code>\"+\"</code>,   <code>\"/\"</code>, <code>\"\\\\\"</code>, <code>\"x\"</code> or <code>\".\"</code>.</li> </ul> <p>Note</p> <p><code>hatch</code> is not supported in some backends.</p> <p><code>edge</code> has following properties:</p> <ul> <li><code>color</code> ... color of the lines. Any color-like object is accepted.</li> <li><code>width</code> ... width of the lines. Should be a non-negative number.</li> <li><code>style</code> ... style of the lines. Should be one of <code>\"-\"</code>, <code>\":\"</code>, <code>\"-.\"</code>, <code>\"--\"</code>.</li> </ul> <p>Note</p> <p><code>style</code> is not supported in some backends.</p> <p>Methods for adding these layers always configure the <code>face</code> properties with the arguments. You can use the <code>with_edge</code> method of the output layer to set edge properties. This separation is very helpful to prevent the confusion of the arguments, especially the colors.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\ncanvas.add_markers(np.sin(np.arange(10)), color=\"yellow\").with_edge(color=\"black\")\ncanvas.show()\n</code></pre> </p> <p>All the properties can be set via properties of <code>face</code> and <code>edge</code>, or the <code>update</code> method.</p> <pre><code>layer.face.color = \"yellow\"\nlayer.face.hatch = \"x\"\n\nlayer.edge.color = \"black\"\nlayer.edge.width = 2\nlayer.edge.style = \"--\"\n\n# use `update`\nlayer.face.update(color=\"yellow\", hatch=\"x\")\nlayer.edge.update(color=\"black\", width=2, style=\"--\")\n</code></pre>"},{"location":"layers/markers/#multi-face-and-multi-edge-markers","title":"Multi-face and Multi-edge Markers","text":"<p><code>Markers</code> supports multi-face and multi-edge. This means that you can create a layer with multiple colors, widths, etc.</p> <p>To do this, you have to call <code>with_face_multi</code> or <code>with_edge_multi</code> method. Here's an example of <code>Markers</code> with multi-faces.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_markers(np.arange(10), np.sin(np.arange(10)))\n    .with_face_multi(color=np.random.random((10, 3)))  # random colors\n)\ncanvas.show()\n</code></pre> </p> <p>After calling <code>with_face_multi</code>, the layer <code>face</code> property will return arrays instead of scalar values.</p> <pre><code>layer.face.color  # (N, 4) array of RGBA colors\nlayer.face.hatch  # (N,) array of hatchs\nlayer.face.alpha # (N,) array of alpha values\n</code></pre> <p>Note</p> <p>IDE can detect whether a <code>Markers</code> layer is multi-face or not. <code>Markers</code> class is a generic class with type variables for the face types. Since <code>with_face_multi</code> is correctly typed, IDE will recognize the returned layer as a multi-face layer.</p> <p>Similarly, you can use <code>with_edge_multi</code> to create multi-edge markers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_markers(np.arange(10), np.sin(np.arange(10)))\n    .with_edge_multi(width=np.abs(np.sin(np.arange(10))) * 2.5)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/markers/#multi-size-markers","title":"Multi-size Markers","text":"<p><code>with_size_multi</code> method can be used to create multi-size markers.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\n\nlayer = (\n    canvas\n    .add_markers(np.arange(10), np.sin(np.arange(10)))\n    .with_size_multi(np.abs(np.sin(np.arange(10))) * 16)\n)\ncanvas.show()\n</code></pre> </p>"},{"location":"layers/markers/#hover-text","title":"Hover Text","text":"<p>Hover text is very useful for interactive data exploration. <code>whitecanvas</code> supports hover texts in different backends.</p> <p>Note</p> <p>To demonstrate the hover texts in this document, we use <code>plotly</code> backend. This does not mean that hover text is not supported in <code>matplotlib</code>.</p>"},{"location":"layers/markers/#give-a-sequence-of-hover-texts","title":"Give a sequence of hover texts","text":"<p><code>with_hover_text</code> method sets the hover text of the markers.</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"plotly\", size=(400, 300))\nx = np.arange(10)\ny = np.sin(x)\n\nlayer = (\n    canvas\n    .add_markers(x, y)\n    .with_hover_text([f\"point {i}\" for i in range(10)])\n)\ncanvas.show()\n</code></pre>"},{"location":"layers/markers/#give-a-hover-template","title":"Give a hover template","text":"<pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"plotly\", size=(400, 300))\nx = np.arange(10)\ny = np.sin(x)\n\nlayer = (\n    canvas\n    .add_markers(x, y)\n    .with_hover_template(\"x={x:.2f}, y={y:.2f}, i={i}\")\n)\ncanvas.show()\n</code></pre>"},{"location":"layers/markers/#picking-markers","title":"Picking Markers","text":"<p>Markers have a <code>picked</code> event. You can connect a callback to the event to handle the picking.</p> <pre><code>import numpy as np\nfrom whitecanvas import new_canvas\n\ncanvas = new_canvas(\"matplotlib\")\nlayer = canvas.add_markers([0, 1, 2], [0, 0, 0])\n\n@layer.events.picked.connect\ndef _on_pick(picked):\n    print(f\"picked indices: {picked}\")\n</code></pre>"},{"location":"layers/markers/#methods-for-better-interpretability","title":"Methods for Better Interpretability","text":"<p><code>Markers</code> is implemented with the following methods to make the plot more interpretable.</p>"},{"location":"layers/markers/#color-by-density","title":"Color by density","text":"<p>Scatter plot is good at visualizing the outliers, but not at telling the distribution when the density is high. In this case, <code>color_by_density</code> method is very useful. It colors the markers by the density of the points using kernel density estimation.</p> <p><pre><code>import numpy as np\nfrom whitecanvas import hgrid\n\nrng = np.random.default_rng(999)\nx = rng.normal(size=1000)\ny = rng.normal(size=1000)\n\ngrid = hgrid(2, backend=\"matplotlib\")\n(\n    grid\n    .add_canvas(0)\n    .update_labels(title=\"no coloring\")\n    .add_markers(x, y)\n)\n(\n    grid\n    .add_canvas(1)\n    .update_labels(title=\"with coloring\")\n    .add_markers(x, y)\n    .color_by_density(cmap=\"viridis\")\n)\ngrid.show()\n</code></pre> </p>"}]}